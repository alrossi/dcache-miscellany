diff --git a/modules/dcache-qos/src/test/java/org/dcache/qos/TestBase.java b/modules/dcache-qos/src/test/java/org/dcache/qos/TestBase.java
new file mode 100644
index 0000000000..7ba2894fc0
--- /dev/null
+++ b/modules/dcache-qos/src/test/java/org/dcache/qos/TestBase.java
@@ -0,0 +1,718 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos;
+
+import com.google.common.collect.ImmutableList;
+import diskCacheV111.poolManager.Pool;
+import diskCacheV111.poolManager.PoolSelectionUnitV2;
+import diskCacheV111.pools.PoolV2Mode;
+import diskCacheV111.util.CacheException;
+import diskCacheV111.util.PnfsId;
+import diskCacheV111.vehicles.Message;
+import java.io.File;
+import java.util.Arrays;
+import java.util.concurrent.TimeUnit;
+import java.util.stream.Collectors;
+import org.dcache.pool.classic.Cancellable;
+import org.dcache.pool.migration.ProportionalPoolSelectionStrategy;
+import org.dcache.poolmanager.PoolMonitor;
+import org.dcache.qos.data.PoolQoSStatus;
+import org.dcache.qos.local.clients.LocalQoSAdjustmentClient;
+import org.dcache.qos.local.clients.LocalQoSRequirementsClient;
+import org.dcache.qos.local.clients.LocalQoSScannerClient;
+import org.dcache.qos.local.clients.LocalQoSVerificationClient;
+import org.dcache.qos.services.adjuster.adjusters.QoSAdjusterFactory;
+import org.dcache.qos.services.adjuster.data.QoSAdjusterTaskMap;
+import org.dcache.qos.services.adjuster.handlers.QoSAdjustTaskCompletionHandler;
+import org.dcache.qos.services.adjuster.handlers.QoSAdjusterTaskHandler;
+import org.dcache.qos.services.adjuster.util.QoSAdjusterCounters;
+import org.dcache.qos.services.engine.handler.FileQoSStatusHandler;
+import org.dcache.qos.services.engine.provider.ALRPStorageUnitQoSProvider;
+import org.dcache.qos.services.engine.util.QoSEngineCounters;
+import org.dcache.qos.services.scanner.data.PoolFilter;
+import org.dcache.qos.services.scanner.data.PoolOperationMap;
+import org.dcache.qos.services.scanner.handlers.PoolOpChangeHandler;
+import org.dcache.qos.services.scanner.handlers.PoolOperationHandler;
+import org.dcache.qos.services.scanner.handlers.PoolTaskCompletionHandler;
+import org.dcache.qos.services.scanner.util.QoSScannerCounters;
+import org.dcache.qos.services.scanner.util.ScannerMapInitializer;
+import org.dcache.qos.services.verifier.data.FileQoSOperationMap;
+import org.dcache.qos.services.verifier.data.PoolInfoDiff;
+import org.dcache.qos.services.verifier.data.PoolInfoMap;
+import org.dcache.qos.services.verifier.handlers.CheckpointHandler;
+import org.dcache.qos.services.verifier.handlers.FileQoSOperationHandler;
+import org.dcache.qos.services.verifier.handlers.PoolGroupAndTagsQoSVerifier;
+import org.dcache.qos.services.verifier.handlers.PoolInfoChangeHandler;
+import org.dcache.qos.services.verifier.util.PoolInfoLocationSelector;
+import org.dcache.qos.services.verifier.util.QoSVerifierCounters;
+import org.dcache.qos.util.QoSHistory;
+import org.dcache.vehicles.FileAttributes;
+import org.junit.After;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public abstract class TestBase implements Cancellable {
+    protected static final Logger    LOGGER = LoggerFactory.getLogger(TestBase.class);
+    protected static final Exception FORCED_FAILURE = new Exception("Forced failure for test purposes");
+    protected static final String    CHKPTFILE      = "/tmp/checkpoint-file";
+    protected static final String    POOLSFILE      = "/tmp/excluded-pools";
+
+    protected ALRPStorageUnitQoSProvider requirementsProvider;
+
+    protected FileQoSOperationHandler operationHandler;
+    protected PoolOperationHandler poolOperationHandler;
+    protected FileQoSOperationMap fileOperationMap;
+    protected PoolOperationMap poolOperationMap;
+    protected PoolInfoMap poolInfoMap;
+    protected PoolInfoLocationSelector locationSelector;
+
+    protected QoSAdjusterTaskHandler adjusterTaskHandler;
+    protected QoSAdjusterTaskMap adjusterTaskMap;
+    protected QoSAdjusterFactory adjusterFactory;
+
+    protected QoSAdjustTaskCompletionHandler taskCompletionHandler;
+    protected PoolTaskCompletionHandler poolTaskCompletionHandler;
+
+    protected PoolOpChangeHandler poolOpChangeHandler;
+    protected PoolInfoChangeHandler poolInfoChangeHandler;
+
+    protected LocalQoSAdjustmentClient adjustmentListener;
+    protected LocalQoSRequirementsClient requirementsListener;
+    protected LocalQoSScannerClient poolScanResponseListener;
+    protected LocalQoSVerificationClient verificationListener;
+    protected PoolGroupAndTagsQoSVerifier statusVerifier;
+
+    protected QoSVerifierCounters verifierCounters;
+    protected QoSAdjusterCounters adjusterCounters;
+    protected QoSEngineCounters engineCounters;
+    protected QoSScannerCounters scannerCounters;
+
+    protected QoSHistory verifierHistory;
+    protected QoSHistory adjusterHistory;
+
+    protected TestSynchronousExecutor shortJobExecutor;
+    protected TestSynchronousExecutor longJobExecutor;
+    protected TestSynchronousExecutor scheduledExecutorService;
+
+    protected TestStub              testPnfsManagerStub;
+    protected TestStub              testPinManagerStub;
+    protected TestSelectionUnit     testSelectionUnit;
+    protected TestCostModule        testCostModule;
+    protected TestPoolMonitor       testPoolMonitor;
+    protected TestNamespaceAccess   testNamespaceAccess;
+
+    protected TestSelectionUnit   newSelectionUnit;
+    protected TestCostModule      newCostModule;
+    protected TestPoolMonitor     newPoolMonitor;
+    protected TestStub testPoolStub;
+
+    private boolean isCancelled = false;
+    private boolean isDone      = false;
+
+    /*
+     * Whether the tasks should fail or cancel.
+     */
+    private TestSynchronousExecutor.Mode shortTaskExecutionMode = TestSynchronousExecutor.Mode.NOP;
+    private TestSynchronousExecutor.Mode longTaskExecutionMode  = TestSynchronousExecutor.Mode.NOP;
+    private TestSynchronousExecutor.Mode scheduledExecutionMode = TestSynchronousExecutor.Mode.NOP;
+
+    private CheckpointHandler checkpointHandler;
+
+    @Override
+    public void cancel(String explanation) {
+        isCancelled = true;
+    }
+
+    @After
+    public void shutDown() {
+        clearAll();
+    }
+
+    private void clearAll() {
+        clearInMemory();
+        if (testNamespaceAccess != null) {
+            testNamespaceAccess.clear();
+            testNamespaceAccess = null;
+        }
+        File file = new File(CHKPTFILE);
+        if (file.exists()) {
+            file.delete();
+        }
+    }
+
+    protected FileAttributes aCustodialNearlineFile() throws CacheException {
+        return testNamespaceAccess.getRequiredAttributes(
+                        TestData.CUSTODIAL_NEARLINE[0]);
+    }
+
+    protected FileAttributes aCustodialOnlineFile() throws CacheException {
+        return testNamespaceAccess.getRequiredAttributes(
+                        TestData.CUSTODIAL_ONLINE[0]);
+    }
+
+    protected FileAttributes aDeletedReplicaOnlineFileWithBothTags()
+                    throws CacheException {
+        FileAttributes attributes = testNamespaceAccess.getRequiredAttributes(
+                        TestData.REPLICA_ONLINE[3]);
+        testNamespaceAccess.delete(attributes.getPnfsId(), false);
+        attributes.getLocations().clear();
+        return attributes;
+    }
+
+    protected FileAttributes aFileWithAReplicaOnAllResilientPools()
+                    throws CacheException {
+        FileAttributes attributes = aReplicaOnlineFileWithNoTags();
+        attributes.setLocations(testCostModule.pools.stream().filter(
+                        (p) -> p.contains("qos")).collect(
+                        Collectors.toList()));
+        return attributes;
+    }
+
+    protected FileAttributes aFileWithThreeReplicasInsteadOfTwo()
+                    throws CacheException {
+        return testNamespaceAccess.getRequiredAttributes(
+                        TestData.REPLICA_ONLINE[1]);
+    }
+
+    protected FileAttributes aNonResilientFile() throws CacheException {
+        return testNamespaceAccess.getRequiredAttributes(
+                        TestData.CUSTODIAL_NEARLINE[0]);
+    }
+
+    protected FileAttributes aReplicaOnlineFileWithBothTags()
+                    throws CacheException {
+        return testNamespaceAccess.getRequiredAttributes(
+                        TestData.REPLICA_ONLINE[3]);
+    }
+
+    protected FileAttributes aReplicaOnlineFileWithBothTagsButNoLocations()
+                    throws CacheException {
+        FileAttributes attributes = testNamespaceAccess.getRequiredAttributes(
+                        TestData.REPLICA_ONLINE[3]);
+        testNamespaceAccess.delete(attributes.getPnfsId(), true);
+        return testNamespaceAccess.getRequiredAttributes(
+                        TestData.REPLICA_ONLINE[3]);
+    }
+
+    protected FileAttributes aReplicaOnlineFileWithHostTag()
+                    throws CacheException {
+        return testNamespaceAccess.getRequiredAttributes(
+                        TestData.REPLICA_ONLINE[0]);
+    }
+
+    protected FileAttributes aReplicaOnlineFileWithNoTags()
+                    throws CacheException {
+        return testNamespaceAccess.getRequiredAttributes(
+                        TestData.REPLICA_ONLINE[4]);
+    }
+
+    protected FileAttributes aReplicaOnlineFileWithRackTag()
+                    throws CacheException {
+        return testNamespaceAccess.getRequiredAttributes(
+                        TestData.REPLICA_ONLINE[2]);
+    }
+
+    protected void clearInMemory() {
+        verifierCounters = null;
+        if (fileOperationMap != null) {
+            fileOperationMap.shutdown();
+            fileOperationMap = null;
+        }
+        if (poolOperationMap != null) {
+            poolOperationMap.shutdown();
+            poolOperationMap = null;
+        }
+        poolInfoMap = null;
+        if (shortJobExecutor != null) {
+            shortJobExecutor.shutdown();
+            shortJobExecutor = null;
+        }
+        if (longJobExecutor != null) {
+            longJobExecutor.shutdown();
+            longJobExecutor = null;
+        }
+        testSelectionUnit = null;
+        testCostModule = null;
+        testPoolMonitor = null;
+    }
+
+    protected void createAccess() {
+        /**
+         * Some tests may try to simulate restart against a persistent namespace
+         */
+        if (testNamespaceAccess == null) {
+            testNamespaceAccess = new TestNamespaceAccess();
+        }
+    }
+
+    protected void createAdjusterTaskMap() {
+        adjusterTaskMap = new QoSAdjusterTaskMap();
+        adjusterFactory = new QoSAdjusterFactory();
+        adjusterCounters = new QoSAdjusterCounters();
+    }
+
+    protected void createAdjusterTaskHandler() {
+        adjusterTaskHandler = new QoSAdjusterTaskHandler();
+    }
+
+    protected void createCellStubs() {
+        testPnfsManagerStub = new TestStub();
+        testPinManagerStub = new TestStub();
+        testPoolStub = new TestStub();
+    }
+
+    protected void createChangeHandlers() {
+        poolOpChangeHandler = new PoolOpChangeHandler();
+        poolInfoChangeHandler = new PoolInfoChangeHandler();
+    }
+
+    protected void createCostModule() {
+        testCostModule = new TestCostModule();
+    }
+
+    protected void createCounters() {
+        verifierCounters = new QoSVerifierCounters();
+        adjusterCounters = new QoSAdjusterCounters();
+        engineCounters = new QoSEngineCounters();
+        scannerCounters = new QoSScannerCounters();
+    }
+
+    protected void createLocationSelector() {
+        locationSelector = new PoolInfoLocationSelector();
+    }
+
+    protected void createFileOperationHandler() {
+        operationHandler = new FileQoSOperationHandler();
+        taskCompletionHandler = new QoSAdjustTaskCompletionHandler();
+    }
+
+    protected void createFileOperationMap() {
+        fileOperationMap = new FileQoSOperationMap();
+        checkpointHandler = new CheckpointHandler();
+    }
+
+    protected void createLocalClients() {
+        verificationListener = new LocalQoSVerificationClient();
+        adjustmentListener = new LocalQoSAdjustmentClient();
+        requirementsListener = new LocalQoSRequirementsClient();
+        poolScanResponseListener = new LocalQoSScannerClient();
+        statusVerifier = new PoolGroupAndTagsQoSVerifier();
+    }
+
+    protected void createPoolInfoMap() {
+        poolInfoMap = new PoolInfoMap() {
+            /*
+             * For the purposes of testing, we ignore the difference
+             * concerning uninitialized pools.
+             */
+            @Override
+            public PoolInfoDiff compare(PoolMonitor poolMonitor) {
+                PoolInfoDiff diff = super.compare(poolMonitor);
+                diff.getUninitializedPools().clear();
+                return diff;
+            }
+        };
+    }
+
+    protected void createPoolMonitor() {
+        testPoolMonitor = new TestPoolMonitor();
+    }
+
+    protected void createPoolOperationHandler() {
+        poolOperationHandler = new PoolOperationHandler();
+        poolTaskCompletionHandler = new PoolTaskCompletionHandler();
+    }
+
+    protected void createPoolOperationMap() {
+        poolOperationMap = new PoolOperationMap();
+    }
+
+    protected void createRequirementsProvider() {
+        requirementsProvider = new ALRPStorageUnitQoSProvider() {
+          protected FileAttributes fetchAttributes(PnfsId pnfsId) throws QoSException {
+              try {
+                  return testNamespaceAccess.getRequiredAttributes(pnfsId);
+              } catch (CacheException e) {
+                  throw new QoSException(e);
+              }
+          }
+        };
+        requirementsProvider.setPoolMonitor(testPoolMonitor);
+    }
+
+    protected void createSelectionUnit() {
+        testSelectionUnit = new TestSelectionUnit();
+    }
+
+    protected void createNewPool(String name) {
+        if (newPoolMonitor != null) {
+            newSelectionUnit.psu.createPool(name, false, false, false);
+            newSelectionUnit.psu.setPoolEnabled(name);
+            Pool pool = (Pool)newSelectionUnit.getPool(name);
+            pool.setPoolMode(new PoolV2Mode(PoolV2Mode.ENABLED));
+            newCostModule.addPool(name, 2);
+        }
+    }
+
+    protected void createNewPoolMonitor() {
+        newSelectionUnit = new TestSelectionUnit();
+        newSelectionUnit.load();
+        newCostModule = new TestCostModule();
+        newCostModule.load();
+        newPoolMonitor = new TestPoolMonitor();
+        newPoolMonitor.setCostModule(newCostModule);
+        newPoolMonitor.setSelectionUnit(newSelectionUnit);
+    }
+
+    protected void deleteAllLocationsForFile(PnfsId pnfsid) {
+        testNamespaceAccess.delete(pnfsid, true);
+    }
+
+    protected void deleteFileFromNamespace(PnfsId pnfsid) {
+        testNamespaceAccess.delete(pnfsid, false);
+    }
+
+    protected PoolSelectionUnitV2 getUpdatedPsu() {
+        if (newSelectionUnit == null) {
+            return null;
+        }
+        return newSelectionUnit.psu;
+    }
+
+    protected void initializeCostModule() {
+        testCostModule.load();
+    }
+
+    protected void initializeCounters() {
+        verifierCounters.initialize();
+        engineCounters.initialize();
+        scannerCounters.initialize();
+        adjusterCounters.initialize();
+    }
+
+    protected void initializePoolInfoMap() {
+        poolInfoMap.apply(poolInfoMap.compare(testPoolMonitor));
+    }
+
+    protected void initializeSelectionUnit() {
+        testSelectionUnit.load();
+    }
+
+    protected void loadFilesWithAllLocationsMissing() {
+        testNamespaceAccess.loadMissingResilientLocations();
+    }
+
+    protected void loadFilesWithExcessLocations() {
+        testNamespaceAccess.loadExcessResilient();
+    }
+
+    protected void loadFilesWithNonTaggedExcessLocations() {
+        testNamespaceAccess.loadNonTaggedExcessResilient();
+    }
+
+    protected void loadFilesWithRequiredLocations() {
+        testNamespaceAccess.loadRequiredResilient();
+    }
+
+    protected void loadNewFilesOnPoolsWithHostAndRackTags() {
+        testNamespaceAccess.loadNewResilientOnHostAndRackTagsDefined();
+    }
+
+    protected void loadNewFilesOnPoolsWithHostTags() {
+        testNamespaceAccess.loadNewResilientOnHostTagDefined();
+    }
+
+    protected void loadNewFilesWithUnmappedStorageUnit() {
+        testNamespaceAccess.loadNewResilientWithUnmappedStorageUnit();
+    }
+
+    protected void loadNewFilesWithStorageUnitMatchingPattern(){
+        testNamespaceAccess.loadNewFilesWithStorageUnitMatchingPattern();
+    }
+
+    protected void loadNewFilesOnPoolsWithNoTags() {
+        testNamespaceAccess.loadNewResilient();
+    }
+
+    protected void loadNonResilientFiles() {
+        testNamespaceAccess.loadNonResilient();
+    }
+
+    protected void makeNonResilient(String unit) {
+        testSelectionUnit.makeStorageUnitNonResilient(unit);
+        poolInfoMap.setUnitConstraints(unit, 1, ImmutableList.of());
+    }
+
+    protected void offlinePools(String... pool) {
+        testSelectionUnit.setOffline(pool);
+        for (String p : pool) {
+            poolInfoMap.updatePoolMode(p, new PoolV2Mode(PoolV2Mode.DISABLED_STRICT));
+        }
+    }
+
+    protected void printHistory() {
+        if (verifierHistory != null) {
+            System.out.println(verifierHistory.ascending(false));
+        }
+
+        if (adjusterHistory != null) {
+            System.out.println(adjusterHistory.ascending(false));
+        }
+    }
+
+    protected void setAllPoolsToEnabled() {
+        Arrays.stream(testPoolMonitor.getPoolSelectionUnit()
+            .getDefinedPools(false))
+            .forEach(p -> poolInfoMap.updatePoolMode(p, new PoolV2Mode(PoolV2Mode.ENABLED)));
+    }
+
+    protected void setAllPoolsOperationsToEnabled() {
+        PoolQoSStatus status = PoolQoSStatus.getStatusFor(new PoolV2Mode(PoolV2Mode.ENABLED));
+        Arrays.stream(testPoolMonitor.getPoolSelectionUnit()
+            .getDefinedPools(false))
+            .forEach(p -> poolOperationMap.updateStatus(p, status));
+    }
+
+    protected void setExcluded(String pool) {
+        PoolFilter filter = new PoolFilter();
+        filter.setPools(pool);
+        poolOperationMap.setIncluded(filter, false);
+    }
+
+    protected void setLongExecutionMode(TestSynchronousExecutor.Mode mode) {
+        longTaskExecutionMode = mode;
+        setLongTaskExecutor();
+    }
+
+    protected void setScheduledExecutionMode(
+                    TestSynchronousExecutor.Mode mode) {
+        scheduledExecutionMode = mode;
+        setScheduledExecutor();
+    }
+
+    protected <T extends Message> void setPoolMessageProcessor(
+                    TestMessageProcessor<T> processor) {
+        testPoolStub.setProcessor(processor);
+    }
+
+    protected void setShortExecutionMode(TestSynchronousExecutor.Mode mode) {
+        shortTaskExecutionMode = mode;
+        setShortTaskExecutor();
+    }
+
+    protected void setUpBase() throws CacheException {
+        createAccess();
+        createCellStubs();
+        createCostModule();
+        createSelectionUnit();
+        createPoolMonitor();
+        createCounters();
+        createPoolInfoMap();
+        createLocationSelector();
+
+        wirePoolMonitor();
+        wireLocationSelector();
+
+        initializeCostModule();
+        initializeSelectionUnit();
+        initializePoolInfoMap();
+
+        /*
+         * Leave out other initializations here; taken care of in
+         * the specific test case.
+         */
+    }
+
+    protected void turnOnRegex() {
+        testSelectionUnit.setUseRegex();
+        poolInfoMap.apply(poolInfoMap.compare(testPoolMonitor));
+    }
+
+    protected void wireAdjusterTaskHandler() {
+        adjusterTaskHandler.setTaskMap(adjusterTaskMap);
+        adjusterTaskHandler.setTaskService(longJobExecutor);
+        adjusterTaskHandler.setVerificationListener(verificationListener);
+    }
+
+    protected void wireAdjusterTaskMap() {
+        adjusterFactory.setCompletionHandler(taskCompletionHandler);
+        adjusterFactory.setScheduledExecutor(scheduledExecutorService);
+        adjusterFactory.setPinManager(testPinManagerStub);
+        adjusterFactory.setPools(testPoolStub);
+        adjusterTaskMap.setFactory(adjusterFactory);
+        adjusterTaskMap.setCounters(adjusterCounters);
+        adjusterTaskMap.setExecutorService(longJobExecutor);
+        adjusterTaskMap.setHandler(adjusterTaskHandler);
+        adjusterTaskMap.setMaxRetries(0);
+        adjusterHistory = new QoSHistory();
+        adjusterHistory.setCapacity(100);
+        adjusterHistory.initialize();
+        adjusterTaskMap.setHistory(adjusterHistory);
+    }
+
+    protected void wireChangeHandlers() {
+        poolInfoChangeHandler.setPoolInfoMap(poolInfoMap);
+        poolInfoChangeHandler.setFileOperationMap(fileOperationMap);
+        poolOpChangeHandler.setPoolOperationHandler(poolOperationHandler);
+        poolOpChangeHandler.setPoolOperationMap(poolOperationMap);
+        poolOpChangeHandler.setMapInitializer(new ScannerMapInitializer());
+        poolOpChangeHandler.setPoolMonitor(testPoolMonitor);
+        poolOpChangeHandler.setRefreshService(scheduledExecutorService);
+    }
+
+    protected void wireFileOperationHandler() {
+        operationHandler.setFileOpMap(fileOperationMap);
+        operationHandler.setPoolInfoMap(poolInfoMap);
+        operationHandler.setTaskExecutor(scheduledExecutorService);
+        operationHandler.setUpdateExecutor(longJobExecutor);
+        operationHandler.setBulkExecutor(longJobExecutor);
+        operationHandler.setStatusVerifier(statusVerifier);
+        operationHandler.setScanResponseListener(poolScanResponseListener);
+        operationHandler.setRequirementsListener(requirementsListener);
+        operationHandler.setAdjustmentListener(adjustmentListener);
+        FileQoSStatusHandler statusHandler = new FileQoSStatusHandler();
+        statusHandler.setQosTransitionTopic(testPoolStub);
+        statusHandler.setQoSEngineCounters(engineCounters);
+        operationHandler.setActionCompletedListener(statusHandler);
+        operationHandler.setCounters(verifierCounters);
+    }
+
+    protected void wireFileOperationMap() {
+        fileOperationMap.setCheckpointExpiry(Long.MAX_VALUE);
+        fileOperationMap.setCheckpointExpiryUnit(TimeUnit.MILLISECONDS);
+        fileOperationMap.setCheckpointFilePath(CHKPTFILE);
+        fileOperationMap.setCheckpointHandler(checkpointHandler);
+        checkpointHandler.setFileQoSOperationMap(fileOperationMap);
+        checkpointHandler.setPoolInfoMap(poolInfoMap);
+        fileOperationMap.setCounters(verifierCounters);
+        verifierHistory = new QoSHistory();
+        verifierHistory.setCapacity(100);
+        verifierHistory.initialize();
+        fileOperationMap.setHistory(verifierHistory);
+        fileOperationMap.setOperationHandler(operationHandler);
+        fileOperationMap.setPoolInfoMap(poolInfoMap);
+        fileOperationMap.setMaxRunning(2);
+        fileOperationMap.setMaxRetries(2);
+    }
+
+    protected void wireLocalClients() {
+        adjustmentListener.setTaskHandler(adjusterTaskHandler);
+        requirementsListener.setProvider(requirementsProvider);
+        statusVerifier.setPoolInfoMap(poolInfoMap);
+        statusVerifier.setPools(testPoolStub);
+        statusVerifier.setLocationSelector(locationSelector);
+        verificationListener.setFileOpHandler(operationHandler);
+
+        if (testNamespaceAccess != null) {
+            testNamespaceAccess.setPools(testPoolStub);
+            testNamespaceAccess.setVerificationListener(verificationListener);
+        }
+
+        poolScanResponseListener.setCompletionHandler(poolTaskCompletionHandler);
+    }
+
+    protected void wireLocationSelector() {
+        locationSelector.setPoolInfoMap(poolInfoMap);
+        locationSelector.setPoolSelectionStrategy(
+                        new ProportionalPoolSelectionStrategy());
+    }
+
+    protected void wirePoolMonitor() {
+        testPoolMonitor.setCostModule(testCostModule);
+        testPoolMonitor.setSelectionUnit(testSelectionUnit);
+    }
+
+    protected void wirePoolOperationHandler() {
+        poolTaskCompletionHandler.setMap(poolOperationMap);
+        poolOperationHandler.setCompletionHandler(poolTaskCompletionHandler);
+        poolOperationHandler.setNamespace(testNamespaceAccess);
+        poolOperationHandler.setOperationMap(poolOperationMap);
+        poolOperationHandler.setScanResponseListener(poolScanResponseListener);
+        poolOperationHandler.setTaskService(longJobExecutor);
+        poolOperationHandler.setVerificationListener(verificationListener);
+        poolOperationHandler.setUpdateService(shortJobExecutor);
+    }
+
+    protected void wirePoolOperationMap() {
+        poolOperationMap.setDownGracePeriod(0);
+        poolOperationMap.setDownGracePeriodUnit(TimeUnit.MINUTES);
+        poolOperationMap.setRestartGracePeriod(0);
+        poolOperationMap.setRestartGracePeriodUnit(TimeUnit.MINUTES);
+        poolOperationMap.setMaxConcurrentRunning(2);
+        poolOperationMap.setRescanWindow(0);
+        poolOperationMap.setRescanWindowUnit(TimeUnit.HOURS);
+        poolOperationMap.setHandler(poolOperationHandler);
+        poolOperationMap.setExcludedPoolsFile(POOLSFILE);
+        poolOperationMap.setChangeHandler(poolOpChangeHandler);
+        poolOperationMap.setCounters(scannerCounters);
+    }
+
+    private void setLongTaskExecutor() {
+        longJobExecutor = new TestSynchronousExecutor(longTaskExecutionMode);
+    }
+
+    private void setScheduledExecutor() {
+        scheduledExecutorService = new TestSynchronousExecutor(scheduledExecutionMode);
+    }
+
+    private void setShortTaskExecutor() {
+        shortJobExecutor = new TestSynchronousExecutor(shortTaskExecutionMode);
+    }
+}
diff --git a/modules/dcache-qos/src/test/java/org/dcache/qos/TestCostModule.java b/modules/dcache-qos/src/test/java/org/dcache/qos/TestCostModule.java
new file mode 100644
index 0000000000..3f028cd1d1
--- /dev/null
+++ b/modules/dcache-qos/src/test/java/org/dcache/qos/TestCostModule.java
@@ -0,0 +1,203 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
+import diskCacheV111.poolManager.CostModule;
+import diskCacheV111.pools.PoolCostInfo;
+import dmg.cells.nucleus.CellAddressCore;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+import javax.annotation.Nullable;
+import org.dcache.pool.classic.IoQueueManager;
+import org.dcache.poolmanager.PoolInfo;
+
+final class TestCostModule implements CostModule {
+    private static PoolCostInfo buildPoolCost(String name,
+                                              int moverActive,
+                                              int moverMaxActive,
+                                              int moverQueued,
+                                              int restoreActive,
+                                              int restoreMaxActive,
+                                              int restoreQueued,
+                                              int storeActive,
+                                              int storeMaxActive,
+                                              int storeQueued,
+                                              long total,
+                                              long free,
+                                              long precious,
+                                              long removable) {
+        PoolCostInfo poolCost
+                        = new PoolCostInfo(name, IoQueueManager.DEFAULT_QUEUE);
+
+        poolCost.setQueueSizes(restoreActive,
+                               restoreMaxActive,
+                               restoreQueued,
+                               storeActive,
+                               storeMaxActive,
+                               storeQueued);
+
+        poolCost.addExtendedMoverQueueSizes(IoQueueManager.DEFAULT_QUEUE,
+                                            moverActive,
+                                            moverMaxActive,
+                                            moverQueued,
+                                            0, 0);
+
+        poolCost.setSpaceUsage(total, free, precious, removable);
+
+        return poolCost;
+    }
+
+    private static ImmutableMap<String, String> getTagMap(int i) {
+        Map<String, String> map = new HashMap<>();
+        String[] pooltags = TestData.POOL_TAGS[i];
+        for (String tag: pooltags) {
+            String[] keyValue = tag.split("[:]");
+            map.put(keyValue[0], keyValue[1]);
+        }
+        return ImmutableMap.copyOf(map);
+    }
+
+    final Set<String> pools = new HashSet<>();
+    final Map<String, PoolInfo> poolInfoMap = new HashMap<>();
+    final Map<String, PoolCostInfo> poolCostInfoMap = new HashMap<>();
+
+    @Override
+    public PoolCostInfo getPoolCostInfo(String poolName) {
+        return poolCostInfoMap.get(poolName);
+    }
+
+    @Nullable
+    @Override
+    public PoolInfo getPoolInfo(String pool) {
+        return poolInfoMap.get(pool);
+    }
+
+    @Override
+    public Collection<PoolCostInfo> getPoolCostInfos() {
+        return ImmutableList.copyOf(poolCostInfoMap.values());
+    }
+
+    @Override
+    public Map<String, PoolInfo> getPoolInfoAsMap(Iterable<String> pools) {
+        Map<String, PoolInfo> map = new HashMap<>();
+        pools.forEach((p)->map.put(p, poolInfoMap.get(p)));
+        return map;
+    }
+
+    @Override
+    public double getPoolsPercentilePerformanceCost(double fraction) {
+        return 0;
+    }
+
+    String dumpInfo() {
+        StringBuilder builder = new StringBuilder();
+        String[] keys = poolInfoMap.keySet().toArray(String[]::new);
+        Arrays.sort(keys);
+        for (String pool: keys) {
+            builder.append(pool).append("\n");
+            PoolInfo info = poolInfoMap.get(pool);
+            builder.append("\tAddress:\t:").append(info.getAddress()).append("\n");
+            builder.append("\tCost Info:\t:").append(info.getCostInfo()).append("\n");
+            builder.append("\tPool Tags:\t:").append(info.getTags()).append("\n");
+        }
+        return builder.toString();
+    }
+
+    TestCostModule load() {
+        for (int k = 0; k < TestData.POOL_TYPE.length; ++k) {
+            for (int i = 0; i < TestData.POOL_COUNT[k]; ++i) {
+                String name = TestData.POOL_TYPE[k] + i;
+                addPool(name, i);
+            }
+        }
+
+        return this;
+    }
+
+    void addPool(String name, int index) {
+        int [] metric = TestData.COST_METRICS[index];
+        long[] space = TestData.POOL_SPACE[index];
+        PoolCostInfo cost = buildPoolCost(name, metric[0],
+                        metric[1],
+                        metric[2],
+                        metric[3],
+                        metric[4],
+                        metric[5],
+                        metric[6],
+                        metric[7],
+                        metric[8],
+                        space[0],
+                        space[1],
+                        space[2],
+                        space[3]);
+        pools.add(name);
+        poolCostInfoMap.put(name, cost);
+        PoolInfo info = new PoolInfo(new CellAddressCore(name),
+                        cost,
+                        getTagMap(index));
+        poolInfoMap.put(name, info);
+    }
+}
diff --git a/modules/dcache-qos/src/test/java/org/dcache/qos/TestData.java b/modules/dcache-qos/src/test/java/org/dcache/qos/TestData.java
new file mode 100644
index 0000000000..e12ec4d32b
--- /dev/null
+++ b/modules/dcache-qos/src/test/java/org/dcache/qos/TestData.java
@@ -0,0 +1,308 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos;
+
+import diskCacheV111.util.PnfsId;
+
+final class TestData {
+    static final PnfsId[] CUSTODIAL_NEARLINE = {
+                    new PnfsId("0000B64FF6C247D84D42BE5ACE9CB688AD00")
+    };
+
+    static final PnfsId[] REPLICA_ONLINE = {
+                    new PnfsId("0000B64FF6C247D84D42BE5ACE9CB688AD10"),
+                    new PnfsId("0000B64FF6C247D84D42BE5ACE9CB688AD11"),
+                    new PnfsId("0000B64FF6C247D84D42BE5ACE9CB688AD12"),
+                    new PnfsId("0000B64FF6C247D84D42BE5ACE9CB688AD13"),
+                    new PnfsId("0000B64FF6C247D84D42BE5ACE9CB688AD14"),
+    };
+
+    static final PnfsId[] CUSTODIAL_ONLINE = {
+                    new PnfsId("0000B64FF6C247D84D42BE5ACE9CB688AD20"),
+                    new PnfsId("0000B64FF6C247D84D42BE5ACE9CB688AD21"),
+                    new PnfsId("0000B64FF6C247D84D42BE5ACE9CB688AD22"),
+                    new PnfsId("0000B64FF6C247D84D42BE5ACE9CB688AD23"),
+                    new PnfsId("0000B64FF6C247D84D42BE5ACE9CB688AD24"),
+    };
+
+    static final int[][] COST_METRICS = {
+                    {0, 100, 0, 0, 0, 0, 0, 0, 0},
+                    {50, 100, 0, 0, 0, 0, 0, 0, 0},
+                    {0, 100, 0, 0, 0, 1, 0, 0, 1},
+                    {0, 100, 0, 10, 0, 0, 0, 0, 0},
+                    {50, 100, 0, 10, 0, 0, 5, 0, 0},
+                    {0, 100, 0, 0, 0, 0, 0, 0, 0},
+                    {50, 100, 0, 0, 0, 0, 0, 0, 0},
+                    {0, 100, 0, 0, 0, 1, 0, 0, 1},
+                    {0, 100, 0, 10, 0, 0, 0, 0, 0},
+                    {50, 100, 0, 10, 0, 0, 5, 0, 0},
+                    {0, 100, 0, 0, 0, 0, 0, 0, 0},
+                    {50, 100, 0, 0, 0, 0, 0, 0, 0},
+                    {0, 100, 0, 0, 0, 1, 0, 0, 1},
+                    {0, 100, 0, 10, 0, 0, 0, 0, 0},
+                    {50, 100, 0, 10, 0, 0, 5, 0, 0}
+    };
+
+    static final long[][] POOL_SPACE = {
+                    {10000000L, 9500000L, 0, 0},
+                    {10000000L, 600000L, 0, 0},
+                    {10000000L, 30000L, 0, 0},
+                    {10000000L, 8000000L, 0, 0},
+                    {10000000L, 40000L, 0, 0},
+                    {10000000L, 9200000L, 0, 0},
+                    {10000000L, 7500000L, 0, 0},
+                    {10000000L, 390000L, 0, 0},
+                    {10000000L, 9500000L, 0, 0},
+                    {10000000L, 600000L, 0, 0},
+                    {10000000L, 30000L, 0, 0},
+                    {10000000L, 8000000L, 0, 0},
+                    {10000000L, 40000L, 0, 0},
+                    {10000000L, 9200000L, 0, 0},
+                    {10000000L, 7500000L, 0, 0}
+    };
+
+    static final String[][] POOL_TAGS = {
+                    {},
+                    {},
+                    {},
+                    {},
+                    {},
+                    {"hostname:h0"},
+                    {"hostname:h0"},
+                    {"hostname:h1"},
+                    {"hostname:h1"},
+                    {"hostname:h2"},
+                    {"hostname:h0", "rack:r0"},
+                    {"hostname:h1", "rack:r0"},
+                    {"hostname:h2", "rack:r0"},
+                    {"hostname:h0", "rack:r1"},
+                    {"hostname:h1", "rack:r1"}
+    };
+
+    static final String[] POOL_TYPE = {
+                    "standard_pool-",
+                    "qos_pool-"
+    };
+
+    static final int[] POOL_COUNT = {
+                    2,
+                    POOL_TAGS.length
+    };
+
+    static final String HSM = "enstore";
+
+    static final String[] PROTOCOL_UNITS = {
+                    "*/*"
+    };
+
+    static final String[] NET_UNITS = {
+                    "::/0",
+                    "0.0.0.0/0.0.0.0"
+    };
+
+    static final String[] STORAGE_CLASSES = {
+                    "qos-0.dcache-devel-test",
+                    "qos-1.dcache-devel-test",
+                    "qos-2.dcache-devel-test",
+                    "qos-3.dcache-devel-test",
+                    "qos-4.dcache-devel-test",
+                    "standard.dcache-devel-test",
+                    "*@*",
+                    "^test.*"
+    };
+
+    static final String[] STORAGE_UNITS = {
+                    getStorageUnitName(STORAGE_CLASSES[0]),
+                    getStorageUnitName(STORAGE_CLASSES[1]),
+                    getStorageUnitName(STORAGE_CLASSES[2]),
+                    getStorageUnitName(STORAGE_CLASSES[3]),
+                    getStorageUnitName(STORAGE_CLASSES[4]),
+                    getStorageUnitName(STORAGE_CLASSES[5]),
+                    STORAGE_CLASSES[6],
+                    STORAGE_CLASSES[7]
+    };
+
+    static final String[][] STORAGE_UNITS_SET = {
+                    {"2", "hostname"},
+                    {"2", "hostname,rack"},
+                    {"2", "rack"},
+                    {"2", "hostname,rack"},
+                    {"3", ""},
+                    null,
+                    {"2", ""},
+                    {"4", ""}
+    };
+
+    static final String[][] POOL_GROUPS = {
+                    {"standard-group", ""},
+                    {"qos-group", "-primary"},
+                    {"pattern-group", "-primary"}
+    };
+
+    static final String[] UNIT_GROUPS= {
+                    "world-net",
+                    "any-protocol",
+                    "standard-storage",
+                    "qos-storage",
+                    "pattern-storage"
+    };
+
+    static final String[][] UNIT_GROUPS_ADD = {
+                    {UNIT_GROUPS[0], NET_UNITS[0], "true"},
+                    {UNIT_GROUPS[0], NET_UNITS[1], "true"},
+                    {UNIT_GROUPS[1], PROTOCOL_UNITS[0], "false"},
+                    {UNIT_GROUPS[2], STORAGE_UNITS[5], "false"},
+                    {UNIT_GROUPS[3], STORAGE_UNITS[0], "false"},
+                    {UNIT_GROUPS[3], STORAGE_UNITS[1], "false"},
+                    {UNIT_GROUPS[3], STORAGE_UNITS[2], "false"},
+                    {UNIT_GROUPS[3], STORAGE_UNITS[3], "false"},
+                    {UNIT_GROUPS[3], STORAGE_UNITS[4], "false"},
+                    {UNIT_GROUPS[3], STORAGE_UNITS[6], "false"},
+                    {UNIT_GROUPS[4], STORAGE_UNITS[7], "false"}
+    };
+
+    static final String[][] LINKS = {
+                    {"standard-link", UNIT_GROUPS[0], UNIT_GROUPS[1], UNIT_GROUPS[2]},
+                    {"qos-link", UNIT_GROUPS[0], UNIT_GROUPS[1], UNIT_GROUPS[3]},
+                    {"pattern-link", UNIT_GROUPS[0], UNIT_GROUPS[1], UNIT_GROUPS[4]}
+    };
+
+    static final String[][] LINKS_SET = {
+                    {"10", "10", "10", "-1", null},
+                    {"10", "10", "10", "-1", null},
+                    {"10", "10", "10", "-1", null}
+    };
+
+    static final String[][] LINKS_ADD = {
+                    {POOL_GROUPS[0][0]},
+                    {POOL_GROUPS[1][0]},
+                    {POOL_GROUPS[2][0]}
+    };
+
+    static String getStorageUnitName(String storageClass) {
+        return storageClass + "@" + HSM;
+    }
+
+    static final String[][] NON_RESILIENT_LOCATIONS = {
+                    {"standard_pool-0"}
+    };
+
+    static final String[][] NEW_RESILIENT_LOCATIONS = {
+                    {"qos_pool-0"},     // (3,H)   : {}
+                    {"qos_pool-1"},     // (2,H,R) : {}
+                    {"qos_pool-2"},     // (2,R)   : {}
+                    {"qos_pool-3"},     // (3,H,R) : {}
+                    {"qos_pool-4"},     // (3)     : {}
+    };
+
+    static final String[][] NEW_RESILIENT_LOCATIONS_H = {
+                    {"qos_pool-5"},     // (3,H)   : {H0}
+                    {"qos_pool-6"},     // (2,H,R) : {H0}
+                    {"qos_pool-7"},     // (2,R)   : {H1}
+                    {"qos_pool-8"},     // (3,H,R) : {H1}
+                    {"qos_pool-9"},     // (3)     : {H2}
+    };
+
+    static final String[][] NEW_RESILIENT_LOCATIONS_HR = {
+                    {"qos_pool-10"},    // (3,H)   : {H0,R0}
+                    {"qos_pool-10"},    // (2,H,R) : {H0,R0}
+                    {"qos_pool-10"},    // (2,R)   : {H0,R0}
+                    {"qos_pool-10"},    // (3,H,R) : {H0,R0}
+                    {"qos_pool-10"},    // (3)     : {H0,R0}
+    };
+
+    static final String[][] MIN_RESILIENT_LOCATIONS = {
+                    {"qos_pool-5", "qos_pool-12"},
+                    {"qos_pool-10", "qos_pool-13"},
+                    {"qos_pool-5", "qos_pool-10"},
+                    {"qos_pool-11", "qos_pool-13"},
+                    {"qos_pool-7", "qos_pool-9", "qos_pool-11"},
+    };
+
+    static final String[][] EXCESS_RESILIENT_LOCATIONS = {
+                    {"qos_pool-4", "qos_pool-5", "qos_pool-7",
+                                    "qos_pool-12"},
+                    {"qos_pool-3", "qos_pool-10", "qos_pool-13"},
+                    {"qos_pool-5", "qos_pool-10", "qos_pool-14"},
+                    {"qos_pool-0", "qos_pool-1", "qos_pool-2",
+                                    "qos_pool-11", "qos_pool-13"},
+                    {"qos_pool-5", "qos_pool-7", "qos_pool-9",
+                                    "qos_pool-11", "qos_pool-12"},
+    };
+
+    static final String[][] NON_TAGGED_EXCESS_RESILIENT_LOCATIONS = {
+                    {},
+                    {"qos_pool-6", "qos_pool-8", "qos_pool-10"},
+                    {},
+                    {},
+                    {},
+    };
+
+    static final String[][] MISSING_RESILIENT_LOCATIONS = {
+                    {},
+                    {},
+                    {},
+                    {},
+                    {}
+    };
+
+    private TestData() {
+    }
+}
diff --git a/modules/dcache-qos/src/test/java/org/dcache/qos/TestMessageProcessor.java b/modules/dcache-qos/src/test/java/org/dcache/qos/TestMessageProcessor.java
new file mode 100644
index 0000000000..10d69a4984
--- /dev/null
+++ b/modules/dcache-qos/src/test/java/org/dcache/qos/TestMessageProcessor.java
@@ -0,0 +1,66 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos;
+
+import diskCacheV111.vehicles.Message;
+
+public interface TestMessageProcessor<T extends Message> {
+    void processMessage(T message) throws Exception;
+}
diff --git a/modules/dcache-qos/src/test/java/org/dcache/qos/TestNamespaceAccess.java b/modules/dcache-qos/src/test/java/org/dcache/qos/TestNamespaceAccess.java
new file mode 100644
index 0000000000..abef3b3b90
--- /dev/null
+++ b/modules/dcache-qos/src/test/java/org/dcache/qos/TestNamespaceAccess.java
@@ -0,0 +1,287 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos;
+
+import com.google.common.collect.ArrayListMultimap;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Multimap;
+import diskCacheV111.util.AccessLatency;
+import diskCacheV111.util.CacheException;
+import diskCacheV111.util.FileNotFoundCacheException;
+import diskCacheV111.util.PnfsId;
+import diskCacheV111.util.RetentionPolicy;
+import diskCacheV111.vehicles.GenericStorageInfo;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.stream.Collectors;
+import org.dcache.qos.data.QoSMessageType;
+import org.dcache.qos.services.scanner.data.PoolScanSummary;
+import org.dcache.qos.services.scanner.namespace.LocalNamespaceAccess;
+import org.dcache.qos.util.CacheExceptionUtils;
+import org.dcache.qos.vehicles.QoSBatchedVerificationRequest;
+import org.dcache.vehicles.FileAttributes;
+
+public final class TestNamespaceAccess extends LocalNamespaceAccess {
+    final Multimap<String, FileAttributes> locationsToFiles = ArrayListMultimap.create();
+    final Map<PnfsId, FileAttributes>      fileAttributes   = new HashMap<>();
+
+    public FileAttributes getRequiredAttributes(PnfsId pnfsId)
+        throws CacheException {
+        if (fileAttributes.containsKey(pnfsId)) {
+            return fileAttributes.get(pnfsId);
+        }
+        throw new FileNotFoundCacheException(pnfsId.toString());
+    }
+
+    @Override
+    public void handlePnfsidsForPool(PoolScanSummary scan) throws CacheException {
+        String pool = scan.getPool();
+        String group = scan.getGroup();
+        String storageUnit = scan.getStorageUnit();
+        QoSMessageType type = scan.getType();
+        List<PnfsId> replicas = locationsToFiles.get(scan.getPool())
+                                                .stream()
+                                                .map(FileAttributes::getPnfsId)
+                                                .collect(Collectors.toList());
+        QoSBatchedVerificationRequest request
+            = new QoSBatchedVerificationRequest(pool, replicas, type, group, storageUnit, false);
+            try {
+                verificationListener.fileQoSVerificationRequested(request);
+            } catch (QoSException e) {
+               throw CacheExceptionUtils.getCacheExceptionFrom(e);
+            }
+        replicas.stream().forEach(r->scan.incrementCount());
+    }
+
+    void clear() {
+        fileAttributes.clear();
+        locationsToFiles.clear();
+    }
+
+    void delete(PnfsId pnfsId, boolean locationsOnly) {
+        FileAttributes attributes = locationsOnly ?
+                        fileAttributes.get(pnfsId) :
+                        fileAttributes.remove(pnfsId);
+        attributes.getLocations().stream().forEach(
+                        (l) -> locationsToFiles.remove(l, attributes));
+        attributes.getLocations().clear();
+    }
+
+    void loadExcessResilient() {
+        for (int i = 0; i < TestData.REPLICA_ONLINE.length; ++i) {
+            loadRequired(TestData.REPLICA_ONLINE[i], AccessLatency.ONLINE,
+                         RetentionPolicy.REPLICA, TestData.HSM,
+                         TestData.STORAGE_CLASSES[i],
+                         TestData.EXCESS_RESILIENT_LOCATIONS[i]);
+        }
+
+        for (int i = 0; i < TestData.CUSTODIAL_ONLINE.length; ++i) {
+            loadRequired(TestData.CUSTODIAL_ONLINE[i], AccessLatency.ONLINE,
+                         RetentionPolicy.CUSTODIAL, TestData.HSM,
+                         TestData.STORAGE_CLASSES[i],
+                         TestData.EXCESS_RESILIENT_LOCATIONS[i]);
+        }
+    }
+
+    void loadNewResilient() {
+        for (int i = 0; i < TestData.REPLICA_ONLINE.length; ++i) {
+            loadRequired(TestData.REPLICA_ONLINE[i], AccessLatency.ONLINE,
+                         RetentionPolicy.REPLICA, TestData.HSM,
+                         TestData.STORAGE_CLASSES[i],
+                         TestData.NEW_RESILIENT_LOCATIONS[i]);
+        }
+
+        for (int i = 0; i < TestData.CUSTODIAL_ONLINE.length; ++i) {
+            loadRequired(TestData.CUSTODIAL_ONLINE[i], AccessLatency.ONLINE,
+                         RetentionPolicy.CUSTODIAL, TestData.HSM,
+                         TestData.STORAGE_CLASSES[i],
+                         TestData.NEW_RESILIENT_LOCATIONS[i]);
+        }
+    }
+
+    void loadNewResilientOnHostAndRackTagsDefined() {
+        for (int i = 0; i < TestData.REPLICA_ONLINE.length; ++i) {
+            loadRequired(TestData.REPLICA_ONLINE[i], AccessLatency.ONLINE,
+                         RetentionPolicy.REPLICA, TestData.HSM,
+                         TestData.STORAGE_CLASSES[i],
+                         TestData.NEW_RESILIENT_LOCATIONS_HR[i]);
+        }
+
+        for (int i = 0; i < TestData.CUSTODIAL_ONLINE.length; ++i) {
+            loadRequired(TestData.CUSTODIAL_ONLINE[i], AccessLatency.ONLINE,
+                         RetentionPolicy.CUSTODIAL, TestData.HSM,
+                         TestData.STORAGE_CLASSES[i],
+                         TestData.NEW_RESILIENT_LOCATIONS_HR[i]);
+        }
+    }
+
+    void loadNewResilientWithUnmappedStorageUnit() {
+        for (int i = 0; i < TestData.REPLICA_ONLINE.length; ++i) {
+            loadRequired(TestData.REPLICA_ONLINE[i], AccessLatency.ONLINE,
+                         RetentionPolicy.REPLICA, TestData.HSM,
+                         "unmapped-storage",
+                         TestData.NEW_RESILIENT_LOCATIONS_H[i]);
+        }
+    }
+
+    void loadNewFilesWithStorageUnitMatchingPattern(){
+        for (int i = 0; i < TestData.REPLICA_ONLINE.length; ++i) {
+            loadRequired(TestData.REPLICA_ONLINE[i], AccessLatency.ONLINE,
+                         RetentionPolicy.REPLICA, TestData.HSM,
+                         "test-storage",
+                         TestData.NEW_RESILIENT_LOCATIONS_H[i]);
+        }
+    }
+
+    void loadNewResilientOnHostTagDefined() {
+        for (int i = 0; i < TestData.REPLICA_ONLINE.length; ++i) {
+            loadRequired(TestData.REPLICA_ONLINE[i], AccessLatency.ONLINE,
+                         RetentionPolicy.REPLICA, TestData.HSM,
+                         TestData.STORAGE_CLASSES[i],
+                         TestData.NEW_RESILIENT_LOCATIONS_H[i]);
+        }
+
+        for (int i = 0; i < TestData.CUSTODIAL_ONLINE.length; ++i) {
+            loadRequired(TestData.CUSTODIAL_ONLINE[i], AccessLatency.ONLINE,
+                         RetentionPolicy.CUSTODIAL, TestData.HSM,
+                         TestData.STORAGE_CLASSES[i],
+                         TestData.NEW_RESILIENT_LOCATIONS_H[i]);
+        }
+    }
+
+    void loadNonResilient() {
+        int k = TestData.REPLICA_ONLINE.length;
+        for (int i = 0; i < TestData.CUSTODIAL_NEARLINE.length; ++i) {
+            loadRequired(TestData.CUSTODIAL_NEARLINE[i], AccessLatency.NEARLINE,
+                         RetentionPolicy.CUSTODIAL, TestData.HSM,
+                         TestData.STORAGE_CLASSES[k++],
+                         TestData.NON_RESILIENT_LOCATIONS[i]);
+        }
+    }
+
+    void loadNonTaggedExcessResilient() {
+        for (int i = 0; i < TestData.REPLICA_ONLINE.length; ++i) {
+            loadRequired(TestData.REPLICA_ONLINE[i], AccessLatency.ONLINE,
+                         RetentionPolicy.REPLICA, TestData.HSM,
+                         TestData.STORAGE_CLASSES[i],
+                         TestData.NON_TAGGED_EXCESS_RESILIENT_LOCATIONS[i]);
+        }
+    }
+
+    void loadMissingResilientLocations() {
+        for (int i = 0; i < TestData.REPLICA_ONLINE.length; ++i) {
+            loadRequired(TestData.REPLICA_ONLINE[i], AccessLatency.ONLINE,
+                         RetentionPolicy.REPLICA, TestData.HSM,
+                         TestData.STORAGE_CLASSES[i],
+                         TestData.MISSING_RESILIENT_LOCATIONS[i]);
+        }
+
+        for (int i = 0; i < TestData.CUSTODIAL_ONLINE.length; ++i) {
+            loadRequired(TestData.CUSTODIAL_ONLINE[i], AccessLatency.ONLINE,
+                         RetentionPolicy.CUSTODIAL, TestData.HSM,
+                         TestData.STORAGE_CLASSES[i],
+                         TestData.MISSING_RESILIENT_LOCATIONS[i]);
+        }
+    }
+
+    void loadRequired(PnfsId pnfsId, AccessLatency accessLatency,
+                      RetentionPolicy retentionPolicy, String hsm,
+                      String storageClass, String... locations) {
+        FileAttributes attr = new FileAttributes();
+        attr.setAccessTime(System.currentTimeMillis());
+        attr.setPnfsId(pnfsId);
+        attr.setAccessLatency(accessLatency);
+        attr.setRetentionPolicy(retentionPolicy);
+        attr.setHsm(hsm);
+        attr.setStorageClass(storageClass);
+        attr.setStorageInfo(new GenericStorageInfo(hsm, storageClass));
+        attr.setLocations(Lists.newArrayList(locations));
+        attr.setSize(2L);
+        fileAttributes.put(pnfsId, attr);
+        for (String pool : locations) {
+            locationsToFiles.put(pool, attr);
+        }
+        if (retentionPolicy == RetentionPolicy.CUSTODIAL) {
+            try {
+                attr.getStorageInfo().addLocation(new URI(pnfsId + "-TAPELOC"));
+            } catch (URISyntaxException e) {
+            }
+        }
+    }
+
+    void loadRequiredResilient() {
+        for (int i = 0; i < TestData.REPLICA_ONLINE.length; ++i) {
+            loadRequired(TestData.REPLICA_ONLINE[i], AccessLatency.ONLINE,
+                         RetentionPolicy.REPLICA, TestData.HSM,
+                         TestData.STORAGE_CLASSES[i],
+                         TestData.MIN_RESILIENT_LOCATIONS[i]);
+        }
+
+        for (int i = 0; i < TestData.CUSTODIAL_ONLINE.length; ++i) {
+            loadRequired(TestData.CUSTODIAL_ONLINE[i], AccessLatency.ONLINE,
+                         RetentionPolicy.CUSTODIAL, TestData.HSM,
+                         TestData.STORAGE_CLASSES[i],
+                         TestData.MIN_RESILIENT_LOCATIONS[i]);
+        }
+    }
+}
diff --git a/modules/dcache-qos/src/test/java/org/dcache/qos/TestNotifyProcessor.java b/modules/dcache-qos/src/test/java/org/dcache/qos/TestNotifyProcessor.java
new file mode 100644
index 0000000000..8dad56878b
--- /dev/null
+++ b/modules/dcache-qos/src/test/java/org/dcache/qos/TestNotifyProcessor.java
@@ -0,0 +1,66 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos;
+
+import java.io.Serializable;
+
+public interface TestNotifyProcessor {
+    void processMessage(Serializable message);
+}
diff --git a/modules/dcache-qos/src/test/java/org/dcache/qos/TestPoolMonitor.java b/modules/dcache-qos/src/test/java/org/dcache/qos/TestPoolMonitor.java
new file mode 100644
index 0000000000..fb6b3344a4
--- /dev/null
+++ b/modules/dcache-qos/src/test/java/org/dcache/qos/TestPoolMonitor.java
@@ -0,0 +1,119 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos;
+
+import java.util.Collection;
+import java.util.Set;
+
+import diskCacheV111.poolManager.CostModule;
+import diskCacheV111.poolManager.PoolSelectionUnit;
+import diskCacheV111.pools.PoolCostInfo;
+import diskCacheV111.util.FileLocality;
+import diskCacheV111.vehicles.ProtocolInfo;
+
+import org.dcache.poolmanager.PartitionManager;
+import org.dcache.poolmanager.PoolMonitor;
+import org.dcache.poolmanager.PoolSelector;
+import org.dcache.vehicles.FileAttributes;
+
+public final class TestPoolMonitor implements PoolMonitor {
+    private TestCostModule costModule;
+    private TestSelectionUnit selectionUnit;
+
+    @Override
+    public CostModule getCostModule() {
+        return costModule;
+    }
+
+    @Override
+    public FileLocality getFileLocality(FileAttributes attributes,
+                    String hostName) {
+        throw new UnsupportedOperationException("getFileLocality");
+    }
+
+    @Override
+    public PartitionManager getPartitionManager() {
+        throw new UnsupportedOperationException("getPartitionManager");
+    }
+
+    @Override
+    public PoolSelectionUnit getPoolSelectionUnit() {
+        return selectionUnit;
+    }
+
+    @Override
+    public PoolSelector getPoolSelector(FileAttributes fileAttributes,
+                    ProtocolInfo protocolInfo, String linkGroup, Set<String> excludedHosts) {
+        throw new UnsupportedOperationException("getPoolSelector");
+    }
+
+    @Override
+    public Collection<PoolCostInfo> queryPoolsByLinkName(String linkName) {
+        throw new UnsupportedOperationException("queryPoolsByLinkName");
+    }
+
+    public void setCostModule(TestCostModule costModule) {
+        this.costModule = costModule;
+    }
+
+    public void setSelectionUnit(TestSelectionUnit selectionUnit) {
+        this.selectionUnit = selectionUnit;
+    }
+}
diff --git a/modules/dcache-qos/src/test/java/org/dcache/qos/TestSelectionUnit.java b/modules/dcache-qos/src/test/java/org/dcache/qos/TestSelectionUnit.java
new file mode 100644
index 0000000000..c4e900c1d2
--- /dev/null
+++ b/modules/dcache-qos/src/test/java/org/dcache/qos/TestSelectionUnit.java
@@ -0,0 +1,321 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos;
+
+import com.google.common.collect.ImmutableList;
+
+import java.net.UnknownHostException;
+import java.util.Collection;
+import java.util.Map;
+import java.util.NoSuchElementException;
+import java.util.Set;
+import java.util.function.Predicate;
+
+import diskCacheV111.poolManager.PoolPreferenceLevel;
+import diskCacheV111.poolManager.PoolSelectionUnit;
+import diskCacheV111.poolManager.PoolSelectionUnitV2;
+import diskCacheV111.poolManager.StorageUnit;
+import diskCacheV111.pools.PoolV2Mode;
+
+import dmg.cells.nucleus.CellAddressCore;
+
+import org.dcache.vehicles.FileAttributes;
+
+final class TestSelectionUnit implements PoolSelectionUnit {
+    PoolSelectionUnitV2 psu;
+
+    @Override
+    public String[] getActivePools() {
+        return psu.getActivePools();
+    }
+
+    @Override
+    public Collection<SelectionPool> getAllDefinedPools(boolean enabledOnly) {
+        return psu.getAllDefinedPools(enabledOnly);
+    }
+
+    @Override
+    public String[] getDefinedPools(boolean enabledOnly) {
+        return psu.getDefinedPools(enabledOnly);
+    }
+
+    @Override
+    public SelectionLink getLinkByName(String linkName)
+                    throws NoSuchElementException {
+        return psu.getLinkByName(linkName);
+    }
+
+    @Override
+    public SelectionLinkGroup getLinkGroupByName(String linkGroupName)
+                    throws NoSuchElementException {
+        return psu.getLinkGroupByName(linkGroupName);
+    }
+
+    @Override
+    public Map<String, SelectionLinkGroup> getLinkGroups() {
+        return psu.getLinkGroups();
+    }
+
+    @Override
+    public Map<String, SelectionLink> getLinks() {
+        return psu.getLinks();
+    }
+
+    @Override
+    public Collection<SelectionLink> getLinksPointingToPoolGroup(
+                    String poolGroup) throws NoSuchElementException {
+        return psu.getLinksPointingToPoolGroup(poolGroup);
+    }
+
+    @Override
+    public String getNetIdentifier(String address) throws UnknownHostException {
+        return psu.getNetIdentifier(address);
+    }
+
+    @Override
+    public SelectionPool getPool(String poolName) {
+        return psu.getPool(poolName);
+    }
+
+    @Override
+    public boolean isEnabledRegex() {
+        return psu.isEnabledRegex();
+    }
+
+    @Override
+    public boolean updatePool(String poolName, CellAddressCore address, String hostName,
+                              long serialId, PoolV2Mode mode,
+                              Set<String> hsmInstances, Map<String,String> tags) {
+        return psu.updatePool(poolName, address, hostName, serialId, mode, hsmInstances, tags);
+    }
+
+    @Override
+    public Map<String, SelectionPoolGroup> getPoolGroups() {
+        return psu.getPoolGroups();
+    }
+
+    @Override
+    public Collection<SelectionPoolGroup> getPoolGroupsOfPool(String poolName) {
+        return psu.getPoolGroupsOfPool(poolName);
+    }
+
+    @Override
+    public Map<String, SelectionPool> getPools() {
+        return psu.getPools();
+    }
+
+    @Override
+    public Collection<SelectionPool> getPoolsByPoolGroup(String poolGroup)
+                    throws NoSuchElementException {
+        return psu.getPoolsByPoolGroup(poolGroup);
+    }
+
+    @Override
+    public String getProtocolUnit(String protocolUnitName) {
+        return psu.getProtocolUnit(protocolUnitName);
+    }
+
+    @Override
+    public Map<String, SelectionUnit> getSelectionUnits() {
+        return psu.getSelectionUnits();
+    }
+
+    @Override
+    public StorageUnit getStorageUnit(String storageClass) {
+        return psu.getStorageUnit(storageClass);
+    }
+
+    @Override
+    public Map<String, SelectionUnitGroup> getUnitGroups() {
+        return psu.getUnitGroups();
+    }
+
+    @Override
+    public String getVersion() {
+        return psu.getVersion();
+    }
+
+    @Override
+    public PoolPreferenceLevel[] match(DirectionType type, String net,
+                                       String protocol, FileAttributes fileAttributes,
+                                       String linkGroup,
+                                       Predicate<String> exclude) {
+        return psu.match(type, net, protocol, fileAttributes, linkGroup, exclude);
+    }
+
+    String getInfo() {
+        StringBuilder builder = new StringBuilder();
+        builder.append("UNITS:\n");
+        psu.getSelectionUnits().values().stream().forEach(
+                        (u) -> builder.append("\t").append(u).append("\n"));
+        builder.append("UNIT GROUPS:\n");
+        psu.getUnitGroups().values().stream().forEach(
+                        (u) -> builder.append("\t").append(u).append("\n"));
+        builder.append("LINKS:\n");
+        psu.getLinks().values().stream().forEach(
+                        (u) -> builder.append("\t").append(u).append("\n"));
+        builder.append("POOL GROUPS:\n");
+        psu.getPoolGroups().values().stream().forEach(
+                        (u) -> builder.append("\t").append(u.getName()).append(
+                                        "\t").append(u).append("\n"));
+        builder.append("POOLS:\n");
+        psu.getPools().values().stream().forEach(
+                        (u) -> builder.append("\t").append(u).append("\n"));
+        return builder.toString();
+    }
+
+    void load() {
+        PoolSelectionUnitV2 v2 = new PoolSelectionUnitV2();
+        createUnits(v2);
+        createUnitGroups(v2);
+        createPools(v2);
+        createPoolGroups(v2);
+        createLinks(v2);
+        psu = v2;
+    }
+
+    void makeStorageUnitNonResilient(String unitKey) {
+        psu.setStorageUnit(unitKey, null, null);
+    }
+
+    void setOffline(String... offline) {
+        for (String pool : offline) {
+            psu.setActive(pool, false);
+            psu.setPoolDisabled(pool);
+        }
+    }
+
+    void setUseRegex() {
+        psu.setRegex("on");
+    }
+
+    private void createLinks(PoolSelectionUnitV2 psu) {
+        for (int i = 0; i < TestData.LINKS.length; ++i) {
+            String link = TestData.LINKS[i][0];
+            psu.createLink(link, ImmutableList.of(TestData.LINKS[i][1],
+                            TestData.LINKS[i][2], TestData.LINKS[i][3]));
+            psu.setLink(link, TestData.LINKS_SET[i][0],
+                            TestData.LINKS_SET[i][1], TestData.LINKS_SET[i][2],
+                            TestData.LINKS_SET[i][3], TestData.LINKS_SET[i][4]);
+            for (String toAdd : TestData.LINKS_ADD[i]) {
+                psu.addLink(link, toAdd);
+            }
+        }
+    }
+
+    private void createPoolGroups(PoolSelectionUnitV2 psu) {
+        for (int i = 0; i < TestData.POOL_GROUPS.length; ++i) {
+            String name = TestData.POOL_GROUPS[i][0];
+            psu.createPoolGroup(name, "-resilient".equals(TestData.POOL_GROUPS[i][1])
+                || "-primary".equals(TestData.POOL_GROUPS[i][1]));
+            String prefix = name.substring(0, name.indexOf("-"));
+            psu.getAllDefinedPools(false).stream().filter(
+                            (p) -> p.getName().startsWith(prefix)).forEach(
+                            (p) -> psu.addToPoolGroup(name, p.getName()));
+        }
+    }
+
+    private void createPools(PoolSelectionUnitV2 psu) {
+        for (int i = 0; i < TestData.POOL_TYPE.length; ++i) {
+            String prefix = TestData.POOL_TYPE[i];
+            for (int k = 0; k < TestData.POOL_COUNT[i]; ++k) {
+                String pool = prefix + k;
+                psu.createPool(pool, false, false, false);
+                psu.setActive(pool, true);
+                psu.setPoolEnabled(pool);
+                psu.getPool(pool).setPoolMode(
+                                new PoolV2Mode(PoolV2Mode.ENABLED));
+            }
+        }
+    }
+
+    private void createUnitGroups(PoolSelectionUnitV2 psu) {
+        for (String unitGroup : TestData.UNIT_GROUPS) {
+            psu.createUnitGroup(unitGroup);
+        }
+
+        for (int i = 0; i < TestData.UNIT_GROUPS_ADD.length; ++i) {
+            psu.addToUnitGroup(TestData.UNIT_GROUPS_ADD[i][0],
+                            TestData.UNIT_GROUPS_ADD[i][1],
+                            Boolean.parseBoolean(
+                                            TestData.UNIT_GROUPS_ADD[i][2]));
+        }
+    }
+
+    private void createUnits(PoolSelectionUnitV2 psu) {
+        for (String unit : TestData.PROTOCOL_UNITS) {
+            psu.createUnit(unit, false, false, false, true);
+        }
+
+        for (String unit : TestData.NET_UNITS) {
+            psu.createUnit(unit, true, false, false, false);
+        }
+
+        for (int i = 0; i < TestData.STORAGE_UNITS.length; ++i) {
+            psu.createUnit(TestData.STORAGE_UNITS[i], false, true, false,
+                            false);
+            if (TestData.STORAGE_UNITS_SET[i] != null) {
+                psu.setStorageUnit(TestData.STORAGE_UNITS[i],
+                                Integer.parseInt(TestData.STORAGE_UNITS_SET[i][0]),
+                                TestData.STORAGE_UNITS_SET[i][1].split("[,]"));
+            }
+        }
+    }
+}
diff --git a/modules/dcache-qos/src/test/java/org/dcache/qos/TestStub.java b/modules/dcache-qos/src/test/java/org/dcache/qos/TestStub.java
new file mode 100644
index 0000000000..8389c06461
--- /dev/null
+++ b/modules/dcache-qos/src/test/java/org/dcache/qos/TestStub.java
@@ -0,0 +1,162 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.ListenableFutureTask;
+
+import java.io.Serializable;
+import java.util.Map;
+import java.util.concurrent.Executor;
+
+import diskCacheV111.util.CacheException;
+import diskCacheV111.vehicles.Message;
+
+import dmg.cells.nucleus.CellEndpoint;
+import dmg.cells.nucleus.CellMessage;
+import dmg.cells.nucleus.CellMessageAnswerable;
+import dmg.cells.nucleus.CellPath;
+import dmg.cells.nucleus.SerializationException;
+
+import org.dcache.cells.CellStub;
+
+public final class TestStub extends CellStub {
+    private TestMessageProcessor processor;
+    private TestNotifyProcessor notifyProcessor;
+
+    public TestStub() {
+        super();
+        setCellEndpoint(new CellEndpoint() {
+            @Override
+            public void sendMessage(CellMessage envelope, SendFlag... flags)
+                            throws SerializationException {
+
+            }
+
+            @Override
+            public void sendMessage(CellMessage envelope,
+                                    CellMessageAnswerable callback, Executor executor,
+                                    long timeout, SendFlag... flags) throws SerializationException {
+
+            }
+
+            @Override
+            public Map<String, Object> getDomainContext() {
+                return null;
+            }
+        });
+    }
+
+    @Override
+    public CellPath getDestinationPath() {
+        return new CellPath("testCell", "testDomain");
+    }
+
+    public <T extends Message> T sendAndWait(T msg, long timeout)
+                    throws CacheException, InterruptedException{
+        send(msg);
+        return msg;
+    }
+
+    @Override
+    public void notify(Serializable message) {
+        if (notifyProcessor != null) {
+            notifyProcessor.processMessage(message);
+        }
+    }
+
+    @Override public <T extends Message> ListenableFuture<T> send(CellPath destination,
+                                                                  T message, CellEndpoint.SendFlag... flags) {
+        return send(message, flags);
+    }
+
+    @Override
+    public <T extends Message> ListenableFuture<T> send(final T message, CellEndpoint.SendFlag... flags) {
+        ListenableFutureTask<T> future;
+        future = ListenableFutureTask.create(() -> {
+                    processor.processMessage(message);
+                    return message;
+                });
+        future.run();
+        return future;
+    }
+
+    public <T> ListenableFuture<T> send(CellPath destination,
+                                        Serializable message,
+                                        Class<T> type,
+                                        long timeout,
+                                        CellEndpoint.SendFlag... flags) {
+        ListenableFutureTask<T> future;
+        future = ListenableFutureTask.create(() -> {
+            processor.processMessage((Message)message);
+            return type.cast(message);
+        });
+        future.run();
+        return future;
+    }
+
+    public void setProcessor(TestMessageProcessor processor) {
+        this.processor = processor;
+    }
+
+    public void setNotifyProcessor(TestNotifyProcessor notifyProcessor) {
+        this.notifyProcessor = notifyProcessor;
+    }
+}
diff --git a/modules/dcache-qos/src/test/java/org/dcache/qos/TestSynchronousExecutor.java b/modules/dcache-qos/src/test/java/org/dcache/qos/TestSynchronousExecutor.java
new file mode 100644
index 0000000000..fc7077073a
--- /dev/null
+++ b/modules/dcache-qos/src/test/java/org/dcache/qos/TestSynchronousExecutor.java
@@ -0,0 +1,224 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos;
+
+import java.util.Collection;
+import java.util.List;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+import java.util.concurrent.FutureTask;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.ScheduledFuture;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+import java.util.stream.Collectors;
+import org.dcache.qos.util.ExceptionMessage;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public final class TestSynchronousExecutor implements ScheduledExecutorService {
+    public enum Mode {
+        NOP, RUN, FAIL
+    }
+
+    final Logger logger = LoggerFactory.getLogger(this.getClass());
+
+    final Mode mode;
+
+    public TestSynchronousExecutor(Mode mode) {
+        this.mode = mode;
+    }
+
+    @Override
+    public boolean awaitTermination(long timeout, TimeUnit unit)
+                    throws InterruptedException {
+        return false;
+    }
+
+    @Override
+    public void execute(Runnable command) {
+        switch (mode) {
+            case NOP:
+            case FAIL:
+                break;
+            default:
+                command.run();
+        }
+    }
+
+    @Override
+    public <T> List<Future<T>> invokeAll(
+                    Collection<? extends Callable<T>> tasks)
+                    throws InterruptedException {
+        return tasks.stream().map((t) -> submit(t)).collect(
+                        Collectors.toList());
+    }
+
+    @Override
+    public <T> List<Future<T>> invokeAll(
+                    Collection<? extends Callable<T>> tasks, long timeout,
+                    TimeUnit unit) throws InterruptedException {
+        return invokeAll(tasks);
+    }
+
+    @Override
+    public <T> T invokeAny(Collection<? extends Callable<T>> tasks)
+                    throws InterruptedException, ExecutionException {
+        Callable<T> chosen = tasks.iterator().next();
+        submit(chosen);
+        return null;
+    }
+
+    @Override
+    public <T> T invokeAny(Collection<? extends Callable<T>> tasks,
+                           long timeout, TimeUnit unit)
+                    throws InterruptedException, ExecutionException,
+                    TimeoutException {
+        return invokeAny(tasks);
+    }
+
+    @Override
+    public boolean isShutdown() {
+        return false;
+    }
+
+    @Override
+    public boolean isTerminated() {
+        return false;
+    }
+
+    @Override
+    public ScheduledFuture<?> schedule(Runnable command, long delay,
+                                       TimeUnit unit) {
+
+        execute(command);
+        return null;
+    }
+
+    @Override
+    public <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay,
+                                           TimeUnit unit) {
+        submit(callable);
+        return null;
+    }
+
+    @Override
+    public ScheduledFuture<?> scheduleAtFixedRate(Runnable command,
+                                                  long initialDelay,
+                                                  long period, TimeUnit unit) {
+        execute(command);
+        return null;
+    }
+
+    @Override
+    public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command,
+                                                     long initialDelay,
+                                                     long delay,
+                                                     TimeUnit unit) {
+        execute(command);
+        return null;
+    }
+
+    @Override
+    public void shutdown() {
+    }
+
+    @Override
+    public List<Runnable> shutdownNow() {
+        return null;
+    }
+
+    @Override
+    public <T> Future<T> submit(Callable<T> task) {
+        try {
+            switch (mode) {
+                case NOP:
+                case FAIL:
+                    break;
+                default:
+                    task.call();
+            }
+        } catch (Exception e) {
+            logger.error("{}", new ExceptionMessage(e));
+        }
+        return new FutureTask<T>(task);
+    }
+
+    @Override
+    public <T> Future<T> submit(Runnable task, T result) {
+        try {
+            execute(task);
+        } catch (Exception e) {
+            logger.error("{}", new ExceptionMessage(e));
+        }
+        return new FutureTask(task, task);
+    }
+
+    @Override
+    public Future<?> submit(Runnable task) {
+        try {
+            execute(task);
+        } catch (Exception e) {
+            logger.error("{}", new ExceptionMessage(e));
+        }
+        return new FutureTask(task, task);
+    }
+}
diff --git a/modules/dcache-qos/src/test/java/org/dcache/qos/remote/receivers/QoSRequirementsReceiverTest.java b/modules/dcache-qos/src/test/java/org/dcache/qos/remote/receivers/QoSRequirementsReceiverTest.java
new file mode 100644
index 0000000000..6e9df386d4
--- /dev/null
+++ b/modules/dcache-qos/src/test/java/org/dcache/qos/remote/receivers/QoSRequirementsReceiverTest.java
@@ -0,0 +1,238 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos.remote.receivers;
+
+import diskCacheV111.util.CacheException;
+import diskCacheV111.util.PnfsId;
+import diskCacheV111.vehicles.PnfsAddCacheLocationMessage;
+import diskCacheV111.vehicles.PnfsClearCacheLocationMessage;
+import org.dcache.qos.TestBase;
+import org.dcache.qos.TestStub;
+import org.dcache.qos.TestSynchronousExecutor.Mode;
+import org.dcache.qos.data.FileQoSRequirements;
+import org.dcache.qos.data.QoSAction;
+import org.dcache.qos.data.QoSMessageType;
+import org.dcache.qos.services.engine.handler.FileQoSStatusHandler;
+import org.dcache.qos.services.engine.util.QoSEngineCounters;
+import org.dcache.qos.util.MessageGuard;
+import org.dcache.qos.util.MessageGuard.Status;
+import org.dcache.vehicles.CorruptFileMessage;
+import org.dcache.vehicles.FileAttributes;
+import org.dcache.vehicles.qos.QoSActionCompleteMessage;
+import org.dcache.vehicles.qos.QoSRequirementsModifiedMessage;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.dcache.qos.services.engine.util.QoSEngineCounters.QOS_ACTION_COMPLETED;
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+/**
+ * <p>This test merely verifies that message handling calls are made.</p>
+ */
+public final class QoSRequirementsReceiverTest extends TestBase {
+    QoSRequirementsReceiver receiver;
+    QoSEngineCounters engineCounters;
+    MessageGuard messageGuard;
+    FileQoSStatusHandler fileStatusHandler;
+
+    @Before
+    public void setUp() throws CacheException {
+        setUpBase();
+        setShortExecutionMode(Mode.NOP);
+        receiver = new QoSRequirementsReceiver();
+        fileStatusHandler = new FileQoSStatusHandler();
+        fileStatusHandler.setExecutor(shortJobExecutor);
+        fileStatusHandler.setQosTransitionTopic(new TestStub());
+        engineCounters = new QoSEngineCounters();
+        engineCounters.initialize();
+        fileStatusHandler.setQoSEngineCounters(engineCounters);
+        receiver.setFileStatusHandler(fileStatusHandler);
+        messageGuard = mock(MessageGuard.class);
+        receiver.setMessageGuard(messageGuard);
+    }
+
+    @Test
+    public void verifyCorruptFileMessage() throws CacheException {
+        PnfsId pnfsId = new PnfsId("0000000000000000BCD");
+        CorruptFileMessage message
+            = new CorruptFileMessage("test-pool", pnfsId);
+        when(messageGuard.getStatus("CorruptFileMessage",
+            message)).thenReturn(Status.EXTERNAL);
+        receiver.processBackloggedMessage(message);
+        /*
+         *  Without artificially altering the call structure of the
+         *  handler, verification of the actual FileOperationHandler method
+         * call is not possible here as the message handler creates an
+         * anonymous struct-type object on the fly to pass as parameter.
+         */
+        assertEquals(1,
+            engineCounters.getCount(QoSMessageType.CORRUPT_FILE.name()));
+    }
+
+    @Test
+    public void verifyPnfsAddCacheLocationMessage() throws CacheException {
+        PnfsId pnfsId = new PnfsId("0000000000000000BCD");
+        PnfsAddCacheLocationMessage message
+            = new PnfsAddCacheLocationMessage(pnfsId,"test-pool");
+        when(messageGuard.getStatus("PnfsAddCacheLocationMessage",
+                                    message)).thenReturn(Status.EXTERNAL);
+        receiver.processBackloggedMessage(message);
+        /*
+         *  Without artificially altering the call structure of the
+         *  handler, verification of the actual FileOperationHandler method
+         * call is not possible here as the message handler creates an
+         * anonymous struct-type object on the fly to pass as parameter.
+         */
+        assertEquals(1,
+            engineCounters.getCount(QoSMessageType.ADD_CACHE_LOCATION.name()));
+    }
+
+    @Test
+    public void verifyQoSOriginatingPnfsAddCacheLocationMessage() throws CacheException {
+        PnfsId pnfsId = new PnfsId("0000000000000000BCD");
+        PnfsAddCacheLocationMessage message
+            = new PnfsAddCacheLocationMessage(pnfsId,"test-pool");
+        when(messageGuard.getStatus("PnfsAddCacheLocationMessage",
+            message)).thenReturn(Status.QOS);
+        receiver.processBackloggedMessage(message);
+        /*
+         *  Without artificially altering the call structure of the
+         *  handler, verification of the actual FileOperationHandler method
+         * call is not possible here as the message handler creates an
+         * anonymous struct-type object on the fly to pass as parameter.
+         */
+        assertEquals(0,
+            engineCounters.getCount(QoSMessageType.ADD_CACHE_LOCATION.name()));
+    }
+
+    @Test
+    public void verifyPnfsClearCacheLocationMessage() {
+        PnfsId pnfsId = new PnfsId("0000000000000000BCD");
+        PnfsClearCacheLocationMessage message
+            = new PnfsClearCacheLocationMessage(pnfsId, "test-pool");
+        when(messageGuard.getStatus("PnfsClearCacheLocationMessage",
+                                    message)).thenReturn(Status.EXTERNAL);
+        receiver.processBackloggedMessage(message);
+        /*
+         *  Without artificially altering the call structure of the
+         *  handler, verification of the actual FileOperationHandler method
+         * call is not possible here as the message handler creates an
+         * anonymous struct-type object on the fly to pass as parameter.
+         */
+        assertEquals(1,
+            engineCounters.getCount(QoSMessageType.CLEAR_CACHE_LOCATION.name()));
+    }
+
+    @Test
+    public void verifyQoSRequirementsModifiedMessage() {
+        QoSRequirementsModifiedMessage message
+            = new QoSRequirementsModifiedMessage(new FileQoSRequirements(new PnfsId("0000000000000000BCD"),
+                                                                         new FileAttributes()));
+        when(messageGuard.getStatus("QoSRequirementsModifiedMessage",
+            message)).thenReturn(Status.EXTERNAL);
+        receiver.processBackloggedMessage(message);
+        /*
+         *  Without artificially altering the call structure of the
+         *  handler, verification of the actual FileOperationHandler method
+         * call is not possible here as the message handler creates an
+         * anonymous struct-type object on the fly to pass as parameter.
+         */
+        assertEquals(1,
+            engineCounters.getCount(QoSMessageType.QOS_MODIFIED.name()));
+    }
+
+    @Test
+    public void verifyBlockedQoSRequirementsModifiedMessage() {
+        QoSRequirementsModifiedMessage message
+            = new QoSRequirementsModifiedMessage(new FileQoSRequirements(new PnfsId("0000000000000000BCD"),
+                                                                         new FileAttributes()));
+        when(messageGuard.getStatus("QoSRequirementsModifiedMessage",
+            message)).thenReturn(Status.DISABLED);
+        receiver.processBackloggedMessage(message);
+        /*
+         *  Without artificially altering the call structure of the
+         *  handler, verification of the actual FileOperationHandler method
+         * call is not possible here as the message handler creates an
+         * anonymous struct-type object on the fly to pass as parameter.
+         */
+        assertEquals(0,
+            engineCounters.getCount(QoSMessageType.QOS_MODIFIED.name()));
+    }
+
+    @Test
+    public void verifyCompletedActionMessage() {
+        QoSActionCompleteMessage message
+         =  new QoSActionCompleteMessage(new PnfsId("0000000000000000BCD"),
+                                         QoSAction.WAIT_FOR_STAGE, null);
+        when(messageGuard.getStatus("QoSActionCompleteMessage",
+            message)).thenReturn(Status.EXTERNAL);
+        receiver.processBackloggedMessage(message);
+        /*
+         *  Without artificially altering the call structure of the
+         *  handler, verification of the actual method
+         *  call is not possible here as the message handler creates an
+         *  anonymous struct-type object on the fly to pass as parameter.
+         */
+        assertEquals(1,
+            engineCounters.getCount(QOS_ACTION_COMPLETED));
+    }
+}
diff --git a/modules/dcache-qos/src/test/java/org/dcache/qos/services/scanner/data/PoolFilterTest.java b/modules/dcache-qos/src/test/java/org/dcache/qos/services/scanner/data/PoolFilterTest.java
new file mode 100644
index 0000000000..d46289f1cb
--- /dev/null
+++ b/modules/dcache-qos/src/test/java/org/dcache/qos/services/scanner/data/PoolFilterTest.java
@@ -0,0 +1,251 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos.services.scanner.data;
+
+import com.google.common.collect.ImmutableSet;
+import diskCacheV111.util.CacheException;
+import java.util.concurrent.TimeUnit;
+import org.dcache.qos.TestBase;
+import org.dcache.qos.data.PoolQoSStatus;
+import org.dcache.qos.services.scanner.data.PoolOperation.State;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+public final class PoolFilterTest extends TestBase {
+    PoolFilter    filter;
+    PoolOperation poolOperation;
+    String        pool;
+
+    @Before
+    public void setUp() throws CacheException {
+        setUpBase();
+        loadNewFilesOnPoolsWithNoTags();
+    }
+
+    @Test
+    public void shouldMatchPoolOperationWhenAfterScanMatches() {
+        givenFilterWith(null, null, null, false, false, false, null, null,
+                        System.currentTimeMillis(), null);
+        givenPoolOperationWith(System.currentTimeMillis() - TimeUnit.HOURS.toMillis(1),
+                               System.currentTimeMillis(), "DOWN", "WAITING");
+        assertTrue(filter.matches("qos_pool-0", poolOperation));
+    }
+
+    @Test
+    public void shouldMatchPoolOperationWhenAfterUpdateMatches() {
+        givenFilterWith(null, null, null, false, false, false,
+                        System.currentTimeMillis(), null, null, null);
+        givenPoolOperationWith(System.currentTimeMillis(),
+                               System.currentTimeMillis() - TimeUnit.HOURS.toMillis(1),
+                               "DOWN", "WAITING");
+        assertTrue(filter.matches("qos_pool-0", poolOperation));
+    }
+
+    @Test
+    public void shouldMatchPoolOperationWhenBeforeScanMatches() {
+        givenFilterWith(null, null, null, false, false, false, null, null,
+                        System.currentTimeMillis() - TimeUnit.HOURS.toMillis(1),
+                        null);
+        givenPoolOperationWith(System.currentTimeMillis() - TimeUnit.HOURS.toMillis(2),
+                               System.currentTimeMillis(), "DOWN", "WAITING");
+        assertTrue(filter.matches("qos_pool-0", poolOperation));
+    }
+
+    @Test
+    public void shouldMatchPoolOperationWhenBeforeUpdateMatches() {
+        givenFilterWith(null, null, null, false, false, false,
+                        System.currentTimeMillis() - TimeUnit.HOURS.toMillis(1), null,
+                        null, null);
+        givenPoolOperationWith(System.currentTimeMillis(),
+                               System.currentTimeMillis() - TimeUnit.HOURS.toMillis(2),
+                               "DOWN", "WAITING");
+        assertTrue(filter.matches("qos_pool-0", poolOperation));
+    }
+
+    @Test
+    public void shouldMatchPoolOperationWhenPoolMatches() {
+        givenFilterWith("qos_pool-0", null, null, false, false, false, null, null,
+                        null, null);
+        givenPoolOperationWith(System.currentTimeMillis(),
+                               System.currentTimeMillis(), "DOWN", "WAITING");
+        assertTrue(filter.matches("qos_pool-0", poolOperation));
+    }
+
+    @Test
+    public void shouldMatchPoolOperationWhenPoolStateMatches() {
+        givenFilterWith(null, "WAITING,RUNNING", null, false, false, false,
+                        null, null, null, null);
+        givenPoolOperationWith(System.currentTimeMillis(),
+                        System.currentTimeMillis(), "DOWN", "WAITING");
+        assertTrue(filter.matches("qos_pool-0", poolOperation));
+    }
+
+    @Test
+    public void shouldMatchPoolOperationWhenPoolStatusMatches() {
+        givenFilterWith(null, null, "DOWN", false, false, false, null, null,
+                        null, null);
+        givenPoolOperationWith(System.currentTimeMillis(),
+                        System.currentTimeMillis(), "DOWN", "WAITING");
+        assertTrue(filter.matches("qos_pool-0", poolOperation));
+    }
+
+    @Test
+    public void shouldNotMatchPoolOperationWhenAfterScanDoesNotMatch() {
+        givenFilterWith(null, null, "RESTART", false, false, false, null, null,
+                        System.currentTimeMillis() - TimeUnit.HOURS.toMillis(1),
+                        null);
+        givenPoolOperationWith(System.currentTimeMillis() - TimeUnit.HOURS.toMillis(2),
+                        System.currentTimeMillis(), "DOWN", "WAITING");
+        assertFalse(filter.matches("qos_pool-0", poolOperation));
+    }
+
+    @Test
+    public void shouldNotMatchPoolOperationWhenAfterUpdateDoesNotMatch() {
+        givenFilterWith(null, null, "RESTART", false, false, false,
+                        System.currentTimeMillis() - TimeUnit.HOURS.toMillis(1),
+                        null, null, null);
+        givenPoolOperationWith(System.currentTimeMillis(),
+                        System.currentTimeMillis() - TimeUnit.HOURS.toMillis(2),
+                        "DOWN", "WAITING");
+        assertFalse(filter.matches("qos_pool-0", poolOperation));
+    }
+
+    @Test
+    public void shouldNotMatchPoolOperationWhenBeforeScanDoesNotMatch() {
+        givenFilterWith(null, null, "RESTART", false, false, false, null, null,
+                        System.currentTimeMillis() - TimeUnit.HOURS.toMillis(2),
+                        null);
+        givenPoolOperationWith(System.currentTimeMillis() - TimeUnit.HOURS.toMillis(1),
+                        System.currentTimeMillis(), "DOWN", "WAITING");
+        assertFalse(filter.matches("qos_pool-0", poolOperation));
+    }
+
+    @Test
+    public void shouldNotMatchPoolOperationWhenBeforeUpdateDoesNotMatch() {
+        givenFilterWith(null, null, "RESTART", false, false, false,
+                        System.currentTimeMillis() - TimeUnit.HOURS.toMillis(2),
+                        null, null, null);
+        givenPoolOperationWith(System.currentTimeMillis(),
+                        System.currentTimeMillis() - TimeUnit.HOURS.toMillis(1),
+                        "DOWN", "WAITING");
+        assertFalse(filter.matches("qos_pool-0", poolOperation));
+    }
+
+    @Test
+    public void shouldNotMatchPoolOperationWhenPoolDoesNotMatch() {
+        givenFilterWith("pool2", null, null, false, false, false, null, null,
+                        null, null);
+        givenPoolOperationWith(System.currentTimeMillis(),
+                        System.currentTimeMillis(), "DOWN", "WAITING");
+        assertFalse(filter.matches("qos_pool-0", poolOperation));
+    }
+
+    @Test
+    public void shouldNotMatchPoolOperationWhenPoolStateDoesNotMatch() {
+        givenFilterWith(null, "WAITING,RUNNING", null, false, false, false,
+                        null, null, null, null);
+        givenPoolOperationWith(System.currentTimeMillis(),
+                        System.currentTimeMillis(), null, "IDLE");
+        assertFalse(filter.matches("qos_pool-0", poolOperation));
+    }
+
+    @Test
+    public void shouldNotMatchPoolOperationWhenPoolStatusDoesNotMatch() {
+        givenFilterWith(null, null, "RESTART", false, false, false, null, null,
+                        null, null);
+        givenPoolOperationWith(System.currentTimeMillis(),
+                        System.currentTimeMillis(), "DOWN", "WAITING");
+        assertFalse(filter.matches("qos_pool-0", poolOperation));
+    }
+
+    private void givenFilterWith(String pool, String states, String status,
+                    boolean parent, boolean source, boolean target,
+                    Long updateBefore, Long updateAfter, Long scanBefore,
+                    Long scanAfter) {
+        filter = new PoolFilter();
+        filter.setLastUpdateBefore(updateBefore);
+        filter.setLastUpdateAfter(updateAfter);
+        filter.setLastScanBefore(scanBefore);
+        filter.setLastScanAfter(scanAfter);
+        filter.setPools(pool);
+        filter.setPoolStatus(status);
+        if (states != null) {
+            filter.setState(ImmutableSet.copyOf(states.split("[,]")));
+        }
+    }
+
+    private void givenPoolOperationWith(Long lastScan, Long lastUpdate,
+                                        String status, String state) {
+        poolOperation = new PoolOperation(0L);
+        poolOperation.lastScan = lastScan;
+        poolOperation.lastUpdate = lastUpdate;
+
+        if (status != null) {
+            poolOperation.currStatus = PoolQoSStatus.valueOf(status);
+        }
+
+        if (state != null) {
+            poolOperation.state = State.valueOf(state);
+        }
+    }
+}
diff --git a/modules/dcache-qos/src/test/java/org/dcache/qos/services/scanner/data/PoolOpChangeHandlerTest.java b/modules/dcache-qos/src/test/java/org/dcache/qos/services/scanner/data/PoolOpChangeHandlerTest.java
new file mode 100644
index 0000000000..d6da3318d0
--- /dev/null
+++ b/modules/dcache-qos/src/test/java/org/dcache/qos/services/scanner/data/PoolOpChangeHandlerTest.java
@@ -0,0 +1,319 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos.services.scanner.data;
+
+import com.google.common.collect.ImmutableList;
+import diskCacheV111.poolManager.PoolSelectionUnit.SelectionPool;
+import diskCacheV111.util.CacheException;
+import org.dcache.qos.TestBase;
+import org.dcache.qos.TestSynchronousExecutor.Mode;
+import org.dcache.qos.data.PoolQoSStatus;
+import org.dcache.qos.listeners.QoSVerificationListener;
+import org.dcache.qos.services.scanner.data.PoolOperation.State;
+import org.dcache.qos.services.scanner.handlers.PoolOpDiff;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Mockito.mock;
+
+/**
+ * <p>Tests the application of the pool monitor diffs.  Note that
+ *      for the purposes of these tests, the transition from uninitialized pool
+ *      to initialized is ignored.</p>
+ */
+public class PoolOpChangeHandlerTest extends TestBase {
+    PoolOpDiff diff;
+    Integer    removedPoolIndex;
+
+    @Before
+    public void setUp() throws CacheException {
+        setUpBase();
+        setShortExecutionMode(Mode.RUN);
+        setLongExecutionMode(Mode.NOP);
+        createPoolOperationHandler();
+        createPoolOperationMap();
+        createChangeHandlers();
+        initializeCounters();
+        wirePoolOperationMap();
+        wirePoolOperationHandler();
+        wireChangeHandlers();
+        poolOperationHandler.setVerificationListener(mock(QoSVerificationListener.class));
+        poolOperationMap.loadPools();
+
+        setAllPoolsOperationsToEnabled();
+    }
+
+    @After
+    public void tearDown() {
+        clearInMemory();
+    }
+
+    @Test
+    public void shouldScanWhenPoolAddedToPrimaryGroup() {
+        givenPsuUpdate();
+        whenPsuUpdateContainsNewPool("new-pool");
+        whenPsuUpdateContainsNewPoolForPoolGroup("new-pool", "qos-group");
+        whenPsuChangeHelperIsCalled();
+        assertThatPoolIsBeingScanned("new-pool");
+    }
+
+    @Test
+    public void shouldNotScanWhenPoolAddedToOperationMap() {
+        givenPsuUpdate();
+        whenPsuUpdateContainsNewPool("new-pool");
+        whenPsuChangeHelperIsCalled();
+        assertThatPoolOperationHasBeenAddedFor("new-pool");
+        assertThatNoScanCalledFor("new-pool");
+    }
+
+    @Test
+    public void shouldScanWhenPoolAddedToNonPrimaryGroup() {
+        givenPsuUpdate();
+        whenPsuUpdateContainsNewPool("new-pool");
+        whenPsuUpdateContainsNewPoolForPoolGroup("new-pool", "standard-group");
+        whenPsuChangeHelperIsCalled();
+        assertThatPoolIsBeingScanned("new-pool");
+    }
+
+    @Test
+    public void shouldNotScanWhenGroupIsAddedWithNoPools() {
+        givenPsuUpdate();
+        whenPsuUpdateContainsNewNonQosPoolGroup("new-standard-group");
+        whenPsuChangeHelperIsCalled();
+        assertThatScanIsNotCalled();
+    }
+
+    @Test
+    public void shouldNotScanWhenStorageUnitAddedWithNoPoolsLinked() {
+        givenPsuUpdate();
+        whenPsuUpdateContainsNewStorageUnit("new-default-unit");
+        whenPsuChangeHelperIsCalled();
+        assertThatScanIsNotCalled();
+    }
+
+    @Test
+    public void shouldScanWhenNewPoolAndNewGroupIsAdded() {
+        givenPsuUpdate();
+        whenPsuUpdateContainsNewPool("new-pool");
+        whenPsuUpdateContainsNewQosPoolGroup("new-qos-group");
+        whenPsuUpdateContainsNewPoolForPoolGroup("new-pool", "new-qos-group");
+        whenPsuChangeHelperIsCalled();
+        assertThatPoolIsBeingScanned("new-pool");
+    }
+
+    @Test
+    public void shouldCancelAndRemovePoolFromPoolGroupAndScan() {
+        givenPsuUpdate();
+        whenPoolIsWaitingToBeScanned("qos_pool-1");
+        whenPsuUpdateNoLongerContainsPoolForPoolGroup("qos_pool-1",
+                                                      "qos-group");
+        whenPsuChangeHelperIsCalled();
+        assertThatPoolIsBeingScanned("qos_pool-1");
+    }
+
+    @Test
+    public void shouldRemovePoolFromMap() {
+        givenPsuUpdate();
+        whenPsuUpdateNoLongerContainsPool("qos_pool-2");
+        whenPsuChangeHelperIsCalled();
+        assertThatNoScanCalledFor("qos_pool-2");
+    }
+
+    @Test
+    public void shouldRemovePoolGroupFromMap() {
+        givenPsuUpdate();
+        whenPsuUpdateNoLongerContainsPoolGroup("qos-group");
+        whenPsuChangeHelperIsCalled();
+        /*
+         * This essentially 'orphans' the pools.  Should not be
+         * done without removing the pools first.
+         */
+        assertThatScanIsNotCalled();
+    }
+
+    @Test
+    public void shouldRemoveStorageUnitFromMap() {
+        givenPsuUpdate();
+        whenPsuUpdateNoLongerContainsStorageUnit("qos-0.dcache-devel-test@enstore");
+        whenPsuChangeHelperIsCalled();
+        /*
+         * This essentially 'orphans' files belonging to it.  Should not be
+         * done without removing the files first.
+         */
+        assertThatScanIsNotCalled();
+    }
+
+    @Test
+    public void shouldScanGroupWhenStorageConstraintsAreModified() {
+        givenPsuUpdate();
+        whenPsuUpdateContainsStorageUnitWithNewConstraints("qos-0.dcache-devel-test@enstore");
+        whenPsuChangeHelperIsCalled();
+        assertThatPoolsInPoolGroupAreBeingScanned("qos-group");
+    }
+
+    private void assertThatNoScanCalledFor(String pool) {
+        if (poolOperationMap.idle.containsKey(pool)) {
+            assertEquals("IDLE", poolOperationMap.getState(pool));
+        } else {
+            assertFalse(poolOperationMap.waiting.containsKey(pool));
+        }
+    }
+
+    private void assertThatPoolIsBeingScanned(String pool) {
+        assertTrue(poolOperationMap.waiting.containsKey(pool));
+        assertEquals("WAITING", poolOperationMap.getState(pool));
+    }
+
+    private void assertThatPoolOperationHasBeenAddedFor(String pool) {
+        assertTrue(poolOperationMap.idle.containsKey(pool));
+    }
+
+    private void assertThatPoolsInPoolGroupAreBeingScanned(String group) {
+        testPoolMonitor.getPoolSelectionUnit().getPoolsByPoolGroup(group)
+                       .stream().map(SelectionPool::getName)
+                                .forEach(this::assertThatPoolIsBeingScanned);
+    }
+
+    private void assertThatScanIsNotCalled() {
+        assertEquals(0, poolOperationMap.waiting.size());
+    }
+
+    private void assertThatScanIsCalled() {
+        assertTrue(0 < poolOperationMap.waiting.size());
+    }
+
+    private void givenPsuUpdate() {
+        createNewPoolMonitor();
+    }
+
+    private void whenPoolIsWaitingToBeScanned(String pool) {
+        PoolOperation operation = new PoolOperation(0L);
+        operation.state = State.WAITING;
+        operation.currStatus = PoolQoSStatus.ENABLED;
+        poolOperationMap.waiting.put(pool, operation);
+    }
+
+    private void whenPsuChangeHelperIsCalled() {
+        diff = poolOpChangeHandler.reloadAndScan(newPoolMonitor);
+    }
+
+    private void whenPsuUpdateContainsNewLinkToqosUnitGroup(String link) {
+        getUpdatedPsu().createLink(link, ImmutableList.of("qos-storage"));
+    }
+
+    private void whenPsuUpdateContainsNewNonQosPoolGroup(String group) {
+        getUpdatedPsu().createPoolGroup(group, false);
+    }
+
+    private void whenPsuUpdateContainsNewPool(String pool) {
+        createNewPool(pool);
+    }
+
+    private void whenPsuUpdateContainsNewPoolForPoolGroup(String pool, String group) {
+        getUpdatedPsu().addToPoolGroup(group, pool);
+    }
+
+    private void whenPsuUpdateContainsNewQosPoolGroup(String group) {
+        getUpdatedPsu().createPoolGroup(group, true);
+    }
+
+    private void whenPsuUpdateContainsNewStorageUnit(String unit) {
+        getUpdatedPsu().createUnit(unit, false, true, false, false);
+    }
+
+    private void whenPsuUpdateContainsPoolGroupAddedToNewLink(String group,
+                    String link) {
+        getUpdatedPsu().addLink(link, group);
+    }
+
+    private void whenPsuUpdateContainsStorageUnitWithNewConstraints(String unit) {
+        Integer required = getUpdatedPsu().getStorageUnit(unit).getRequiredCopies();
+        getUpdatedPsu().setStorageUnit(unit, required, new String[] { "subnet" });
+    }
+
+    private void whenPsuUpdateNoLongerContainsLink(String link) {
+        getUpdatedPsu().removeLink(link);
+    }
+
+    private void whenPsuUpdateNoLongerContainsPool(String pool) {
+        removedPoolIndex = poolInfoMap.getPoolIndex(pool);
+        getUpdatedPsu().removePool(pool);
+    }
+
+    private void whenPsuUpdateNoLongerContainsPoolForPoolGroup(String pool,
+                    String group) {
+        getUpdatedPsu().removeFromPoolGroup(group, pool);
+    }
+
+    private void whenPsuUpdateNoLongerContainsPoolGroup(String group) {
+        getUpdatedPsu().getPoolsByPoolGroup(group).stream().forEach(
+                        (p) -> getUpdatedPsu().removeFromPoolGroup(group,
+                                        p.getName()));
+        getUpdatedPsu().removePoolGroup(group);
+    }
+
+    private void whenPsuUpdateNoLongerContainsStorageUnit(String unit) {
+        getUpdatedPsu().removeUnit(unit, false);
+    }
+}
diff --git a/modules/dcache-qos/src/test/java/org/dcache/qos/services/scanner/data/PoolOperationMapTest.java b/modules/dcache-qos/src/test/java/org/dcache/qos/services/scanner/data/PoolOperationMapTest.java
new file mode 100644
index 0000000000..8b0f96c175
--- /dev/null
+++ b/modules/dcache-qos/src/test/java/org/dcache/qos/services/scanner/data/PoolOperationMapTest.java
@@ -0,0 +1,458 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos.services.scanner.data;
+
+import diskCacheV111.pools.PoolV2Mode;
+import diskCacheV111.util.CacheException;
+import java.util.Iterator;
+import org.dcache.qos.TestBase;
+import org.dcache.qos.TestSynchronousExecutor.Mode;
+import org.dcache.qos.data.PoolQoSStatus;
+import org.dcache.util.CacheExceptionFactory;
+import org.junit.Before;
+import org.junit.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+public class PoolOperationMapTest extends TestBase {
+    private static final Logger LOGGER = LoggerFactory.getLogger(
+                    PoolOperationMapTest.class);
+
+    String pool;
+    int numberOfPools;
+    int children;
+
+    @Before
+    public void setUp() throws CacheException, InterruptedException {
+        setUpBase();
+        setShortExecutionMode(Mode.NOP);
+        setLongExecutionMode(Mode.NOP);
+        createChangeHandlers();
+        createFileOperationHandler();
+        createFileOperationMap();
+        createPoolOperationHandler();
+        createPoolOperationMap();
+        createCellStubs();
+        createLocalClients();
+        wirePoolOperationMap();
+        wirePoolOperationHandler();
+        wireFileOperationHandler();
+        wireFileOperationMap();
+        wireLocalClients();
+        wireChangeHandlers();
+        initializeCounters();
+        poolOperationMap.setRestartGracePeriod(0);
+        poolOperationMap.loadPools();
+        numberOfPools = poolOperationMap.idle.size();
+
+        setAllPoolsOperationsToEnabled();
+    }
+
+    @Test
+    public void shouldContinueToRunMaxConcurrentWaitingOperationsUntilAllComplete() {
+        givenRescanWindowInHoursIs(0);
+
+        while (!poolOperationMap.waiting.isEmpty()) {
+            whenQueuesAreScanned();
+            assertTrue(poolOperationMap.getMaxConcurrentRunning()
+                            >= poolOperationMap.running.size());
+            assertEquals(numberOfPools
+                                            - poolOperationMap.getMaxConcurrentRunning(),
+                            poolOperationMap.waiting.size()
+                                            + poolOperationMap.idle.size());
+            whenNextOperationCompletes();
+        }
+
+        assertTrue(poolOperationMap.running.isEmpty());
+        assertTrue(poolOperationMap.waiting.isEmpty());
+        assertEquals(numberOfPools, poolOperationMap.idle.size());
+    }
+
+    @Test
+    public void shouldDemoteRunningToIdleWhenCancelled() {
+        givenDownGracePeriodInMinutesIs(0);
+        givenRescanWindowInHoursIs(10);
+        givenPoolIsDown("qos_pool-3");
+        whenQueuesAreScanned();
+        assertTrue(poolOperationMap.running.containsKey(pool));
+        assertFalse(poolOperationMap.idle.containsKey(pool));
+        whenOperationIsCancelled();
+        assertFalse(poolOperationMap.running.containsKey(pool));
+        assertTrue(poolOperationMap.idle.containsKey(pool));
+    }
+
+    @Test
+    public void shouldDemoteWaitingToIdleWhenCancelled() {
+        givenDownGracePeriodInMinutesIs(10);
+        givenRescanWindowInHoursIs(10);
+        givenPoolIsDown("qos_pool-3");
+        whenQueuesAreScanned();
+        assertTrue(poolOperationMap.waiting.containsKey(pool));
+        assertFalse(poolOperationMap.idle.containsKey(pool));
+        whenOperationIsCancelled();
+        assertFalse(poolOperationMap.waiting.containsKey(pool));
+        assertTrue(poolOperationMap.idle.containsKey(pool));
+    }
+
+    @Test
+    public void shouldContinueWaitingWhenDownUpdatedToUp() {
+        givenRestartsAreNotHandled();
+        givenPoolIsDown("qos_pool-3");
+        givenPoolIsUp(pool);
+        assertTrue(poolOperationMap.waiting.containsKey(pool));
+        assertEquals(PoolQoSStatus.READ_ONLY,
+                        poolOperationMap.waiting.get(pool).currStatus);
+    }
+
+    @Test
+    public void shouldNotDemoteWaitingToIdleWhenDownUpdatedToUpAndRestartsAreHandled() {
+        givenPoolIsDown("qos_pool-3");
+        givenPoolIsUp(pool);
+        assertTrue(poolOperationMap.waiting.containsKey(pool));
+        assertFalse(poolOperationMap.idle.containsKey(pool));
+        assertEquals(PoolQoSStatus.READ_ONLY,
+                     poolOperationMap.waiting.get(pool).currStatus);
+    }
+
+    @Test
+    public void shouldDoNothingWhenUpdatedToNOP() {
+        givenPoolIsDown("qos_pool-3");
+        givenPoolIsDown(pool);
+        assertTrue(poolOperationMap.waiting.containsKey(pool));
+        assertEquals(PoolQoSStatus.DOWN,
+                        poolOperationMap.waiting.get(pool).currStatus);
+        assertFalse(poolOperationMap.idle.containsKey(pool));
+    }
+
+    @Test
+    public void shouldDoNothingWhenUpdatedToUpFromUninitialized() {
+        givenPoolIsUp("qos_pool-3");
+        assertTrue(poolOperationMap.idle.containsKey(pool));
+        assertFalse(poolOperationMap.waiting.containsKey(pool));
+    }
+
+    @Test
+    public void shouldFailToScanBecauseAlreadyRunning() {
+        givenRescanWindowInHoursIs(10);
+        givenPoolIsDown("qos_pool-3");
+        givenPoolIsRestarted("qos_pool-3");
+        whenQueuesAreScanned();
+        assertFalse(givenForcedScanOf(pool));
+        assertTrue(poolOperationMap.running.containsKey(pool));
+    }
+
+    @Test
+    public void shouldFailBecauseAlreadyWaiting() {
+        givenRescanWindowInHoursIs(10);
+        givenPoolIsDown("qos_pool-3");
+        givenPoolIsRestarted("qos_pool-3");
+        assertFalse(givenForcedScanOf(pool));
+        assertTrue(poolOperationMap.waiting.containsKey(pool));
+    }
+
+    @Test
+    public void shouldForceOperationToWaitingState() {
+        assertTrue(givenForcedScanOf("qos_pool-1"));
+        assertTrue(givenForcedScanOf("qos_pool-2"));
+        assertTrue(givenForcedScanOf("qos_pool-3"));
+        assertTrue(givenForcedScanOf("qos_pool-4"));
+    }
+
+    @Test
+    public void shouldNotPromoteIdleToWaitingWhenScannedAndRescanWindowNotExpired() {
+        givenRestartsAreNotHandled();
+        givenRescanWindowInHoursIs(10);
+        whenQueuesAreScanned();
+        assertTrue(poolOperationMap.waiting.isEmpty());
+        assertEquals(numberOfPools, poolOperationMap.idle.size());
+    }
+
+    @Test
+    public void shouldNotPromoteWaitingToRunningWhenScannedAndGracePeriodNotExpired() {
+        givenDownGracePeriodInMinutesIs(10);
+        givenRescanWindowInHoursIs(1);
+        givenPoolIsDown("qos_pool-3");
+        whenQueuesAreScanned();
+        assertFalse(poolOperationMap.running.containsKey(pool));
+        assertTrue(poolOperationMap.waiting.containsKey(pool));
+    }
+
+    @Test
+    public void shouldPromoteIdleToWaitingWhenScannedAndRescanHandled() {
+        givenRestartsAreNotHandled();
+        givenRescanWindowInHoursIs(0);
+        whenQueuesAreScanned();
+        assertTrue(poolOperationMap.idle.isEmpty());
+        assertEquals(poolOperationMap.getMaxConcurrentRunning(),
+                     poolOperationMap.running.size());
+        assertEquals(numberOfPools - poolOperationMap.getMaxConcurrentRunning(),
+                     poolOperationMap.waiting.size());
+    }
+
+    @Test
+    public void shouldPromoteIdleToWaitingWhenUpdatedToDown() {
+        givenPoolIsDown("qos_pool-3");
+        assertTrue(poolOperationMap.waiting.containsKey(pool));
+        assertEquals(PoolQoSStatus.DOWN,
+                        poolOperationMap.waiting.get(pool).currStatus);
+        assertFalse(poolOperationMap.idle.containsKey(pool));
+    }
+
+    @Test
+    public void shouldPromoteIdleToWaitingWhenUpdatedToRestart() {
+        givenPoolIsDown("qos_pool-3");
+        givenPoolIsRestarted("qos_pool-3");
+        assertTrue(poolOperationMap.waiting.containsKey(pool));
+        assertEquals(PoolQoSStatus.ENABLED,
+                     poolOperationMap.waiting.get(pool).currStatus);
+        assertFalse(poolOperationMap.idle.containsKey(pool));
+    }
+
+    @Test
+    public void shouldPromoteWaitingToRunningWhenScannedAndGracePeriodExpired() {
+        givenDownGracePeriodInMinutesIs(0);
+        givenRescanWindowInHoursIs(1);
+        givenPoolIsDown("qos_pool-3");
+        whenQueuesAreScanned();
+        assertTrue(poolOperationMap.running.containsKey(pool));
+        assertFalse(poolOperationMap.waiting.containsKey(pool));
+    }
+
+    @Test
+    public void shouldRemainRunningWhenOperationCompletesButChildrenNotTerminated() {
+        givenRescanWindowInHoursIs(10);
+        givenPoolIsDown("qos_pool-3");
+        givenPoolIsRestarted("qos_pool-3");
+        givenFileCountOfPoolIs(4);
+        whenQueuesAreScanned();
+        assertTrue(poolOperationMap.running.containsKey(pool));
+        assertFalse(poolOperationMap.idle.containsKey(pool));
+        whenOperationCompletes();
+        assertTrue(poolOperationMap.running.containsKey(pool));
+        assertFalse(poolOperationMap.idle.containsKey(pool));
+    }
+
+    @Test
+    public void shouldRemainRunningWhenOperationFailsButChildrenNotTerminated() {
+        givenRescanWindowInHoursIs(10);
+        givenPoolIsDown("qos_pool-3");
+        givenPoolIsRestarted("qos_pool-3");
+        givenFileCountOfPoolIs(4);
+        whenQueuesAreScanned();
+        assertTrue(poolOperationMap.running.containsKey(pool));
+        assertFalse(poolOperationMap.idle.containsKey(pool));
+        whenOperationFails();
+        assertTrue(poolOperationMap.running.containsKey(pool));
+        assertFalse(poolOperationMap.idle.containsKey(pool));
+    }
+
+    @Test
+    public void shouldReturnToIdleWhenOperationFailsAndChildrenComplete() {
+        givenRescanWindowInHoursIs(10);
+        givenPoolIsDown("qos_pool-3");
+        givenPoolIsRestarted("qos_pool-3");
+        givenFileCountOfPoolIs(4);
+        whenQueuesAreScanned();
+        assertTrue(poolOperationMap.running.containsKey(pool));
+        assertFalse(poolOperationMap.idle.containsKey(pool));
+        whenOperationFails();
+        whenAllChildrenCompleteFor("qos_pool-3");
+        assertFalse(poolOperationMap.running.containsKey(pool));
+        assertTrue(poolOperationMap.idle.containsKey(pool));
+    }
+
+    @Test
+    public void shouldReturnToIdleWhenOperationFailsAndNoChildren() {
+        givenRescanWindowInHoursIs(10);
+        givenPoolIsDown("qos_pool-3");
+        givenPoolIsRestarted("qos_pool-3");
+        givenFileCountOfPoolIs(0);
+        whenQueuesAreScanned();
+        assertTrue(poolOperationMap.running.containsKey(pool));
+        assertFalse(poolOperationMap.idle.containsKey(pool));
+        whenOperationFails();
+        assertFalse(poolOperationMap.running.containsKey(pool));
+        assertTrue(poolOperationMap.idle.containsKey(pool));
+    }
+
+    @Test
+    public void shouldReturnToIdleWhenOperationSucceedsAndChildrenComplete() {
+        givenRescanWindowInHoursIs(10);
+        givenPoolIsDown("qos_pool-3");
+        givenPoolIsRestarted("qos_pool-3");
+        givenFileCountOfPoolIs(4);
+        whenQueuesAreScanned();
+        assertTrue(poolOperationMap.running.containsKey(pool));
+        assertFalse(poolOperationMap.idle.containsKey(pool));
+        whenOperationCompletes();
+        whenAllChildrenCompleteFor("qos_pool-3");
+        assertFalse(poolOperationMap.running.containsKey(pool));
+        assertTrue(poolOperationMap.idle.containsKey(pool));
+    }
+
+    @Test
+    public void shouldReturnToIdleWhenOperationSucceedsNoChildren() {
+        givenRescanWindowInHoursIs(10);
+        givenPoolIsDown("qos_pool-3");
+        givenPoolIsRestarted("qos_pool-3");
+        givenFileCountOfPoolIs(0);
+        whenQueuesAreScanned();
+        assertTrue(poolOperationMap.running.containsKey(pool));
+        assertFalse(poolOperationMap.idle.containsKey(pool));
+        whenOperationCompletes();
+        assertFalse(poolOperationMap.running.containsKey(pool));
+        assertTrue(poolOperationMap.idle.containsKey(pool));
+    }
+
+    @Test
+    public void shouldRunOnlyMaxConcurrentWaitingOperations() {
+        givenRescanWindowInHoursIs(0);
+        whenQueuesAreScanned();
+        assertEquals(poolOperationMap.getMaxConcurrentRunning(),
+                        poolOperationMap.running.size());
+        assertEquals(numberOfPools - poolOperationMap.getMaxConcurrentRunning(),
+                        poolOperationMap.waiting.size());
+        assertTrue(poolOperationMap.idle.isEmpty());
+    }
+
+    private void givenDownGracePeriodInMinutesIs(int minutes) {
+        poolOperationMap.setDownGracePeriod(minutes);
+    }
+
+    private boolean givenForcedScanOf(String pool) {
+        PoolV2Mode mode = new PoolV2Mode(PoolV2Mode.ENABLED);
+        return poolOperationMap.scan(pool,
+                            null,
+                         null,
+                           null,
+                                      mode,
+                     true);
+    }
+
+    private void givenFileCountOfPoolIs(int count) {
+        children = count;
+    }
+
+    private void givenPoolIsDown(String pool) {
+        this.pool = pool;
+        PoolQoSStatus status = PoolQoSStatus.getStatusFor(new PoolV2Mode(PoolV2Mode.DISABLED_DEAD));
+        poolOperationMap.updateStatus(pool, status);
+    }
+
+    private void givenPoolIsRestarted(String pool) {
+        this.pool = pool;
+        PoolQoSStatus status = PoolQoSStatus.getStatusFor(new PoolV2Mode(PoolV2Mode.ENABLED));
+        poolOperationMap.updateStatus(pool, status);
+    }
+
+    private void givenPoolIsUp(String pool) {
+        this.pool = pool;
+        PoolQoSStatus status = PoolQoSStatus.getStatusFor(new PoolV2Mode(PoolV2Mode.DISABLED_RDONLY));
+        poolOperationMap.updateStatus(pool, status);
+    }
+
+    private void givenRescanWindowInHoursIs(int hours) {
+        poolOperationMap.setRescanWindow(hours);
+    }
+
+    private void givenRestartsAreNotHandled() {
+        poolOperationMap.setRestartGracePeriod(Integer.MAX_VALUE);
+    }
+
+    private void whenAllChildrenCompleteFor(String pool) {
+        for (int c = 0; c < children; c++) {
+            poolOperationMap.update(pool, false);
+        }
+    }
+
+    private void whenNextOperationCompletes() {
+        Iterator<String> iterator = poolOperationMap.running.keySet().iterator();
+        if (iterator.hasNext()) {
+            String pool = iterator.next();
+            poolOperationMap.update(pool, children);
+        }
+    }
+
+    private void whenOperationCompletes() {
+        poolOperationMap.update(pool, children);
+    }
+
+    private void whenOperationFails() {
+        poolOperationMap.update(pool, children,
+                        CacheExceptionFactory.exceptionOf(
+                                        CacheException.NO_POOL_ONLINE,
+                                        "Cannot reach pool."));
+    }
+
+    private void whenOperationIsCancelled() {
+        PoolFilter filter = new PoolFilter();
+        filter.setPools(pool);
+        poolOperationMap.cancel(filter);
+    }
+
+    private void whenQueuesAreScanned() {
+        poolOperationMap.scan();
+    }
+
+}
diff --git a/modules/dcache-qos/src/test/java/org/dcache/qos/services/scanner/data/PoolStatusTransitionTest.java b/modules/dcache-qos/src/test/java/org/dcache/qos/services/scanner/data/PoolStatusTransitionTest.java
new file mode 100644
index 0000000000..002987fef0
--- /dev/null
+++ b/modules/dcache-qos/src/test/java/org/dcache/qos/services/scanner/data/PoolStatusTransitionTest.java
@@ -0,0 +1,316 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos.services.scanner.data;
+
+import diskCacheV111.pools.PoolV2Mode;
+import java.util.ArrayList;
+import java.util.List;
+import org.dcache.qos.data.PoolQoSStatus;
+import org.dcache.qos.services.scanner.data.PoolOperation.NextAction;
+import org.dcache.qos.services.scanner.data.PoolOperation.State;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.dcache.qos.data.PoolQoSStatus.DOWN;
+import static org.dcache.qos.data.PoolQoSStatus.ENABLED;
+import static org.dcache.qos.data.PoolQoSStatus.READ_ONLY;
+import static org.dcache.qos.data.PoolQoSStatus.UNINITIALIZED;
+import static org.dcache.qos.services.scanner.data.PoolOperation.NextAction.DOWN_TO_UP;
+import static org.dcache.qos.services.scanner.data.PoolOperation.NextAction.NOP;
+import static org.dcache.qos.services.scanner.data.PoolOperation.NextAction.UP_TO_DOWN;
+import static org.junit.Assert.assertEquals;
+
+/**
+ * <p>Tests the Cartesian product of mode changes for correct action transition.</p>
+ */
+public final class PoolStatusTransitionTest {
+
+    static final List<TestOracle> oracles = new ArrayList<>();
+
+    static {
+        generateOracles();
+    }
+
+    static class TestOracle {
+        final PoolQoSStatus last;
+        final PoolQoSStatus incoming;
+        final PoolQoSStatus curr;
+        final NextAction  action;
+
+        TestOracle(PoolQoSStatus last,
+                   PoolQoSStatus incoming,
+                   PoolQoSStatus curr,
+                               NextAction action) {
+            this.last = last;
+            this.incoming = incoming;
+            this.curr = curr;
+            this.action = action;
+        }
+    }
+
+    static void generateOracles() {
+        oracles.add(new TestOracle(DOWN, DOWN, DOWN, NOP));
+        oracles.add(new TestOracle(UNINITIALIZED, DOWN, DOWN, NOP));
+        oracles.add(new TestOracle(UNINITIALIZED, DOWN, ENABLED, NOP));
+        oracles.add(new TestOracle(DOWN, READ_ONLY, READ_ONLY, DOWN_TO_UP));
+        oracles.add(new TestOracle(DOWN, ENABLED, ENABLED, DOWN_TO_UP));
+        oracles.add(new TestOracle(READ_ONLY, DOWN, DOWN, UP_TO_DOWN));
+        oracles.add(new TestOracle(UNINITIALIZED, DOWN, DOWN, NOP));
+        oracles.add(new TestOracle(UNINITIALIZED, READ_ONLY, ENABLED, NOP));
+        oracles.add(new TestOracle(READ_ONLY, READ_ONLY, READ_ONLY, NOP));
+        oracles.add(new TestOracle(READ_ONLY, ENABLED, ENABLED, NOP));
+        oracles.add(new TestOracle(ENABLED, DOWN, DOWN, UP_TO_DOWN));
+        oracles.add(new TestOracle(UNINITIALIZED, DOWN, DOWN, NOP));
+        oracles.add(new TestOracle(UNINITIALIZED, ENABLED, ENABLED, NOP));
+        oracles.add(new TestOracle(ENABLED, READ_ONLY, READ_ONLY, NOP));
+        oracles.add(new TestOracle(ENABLED, ENABLED, ENABLED, NOP));
+        oracles.add(new TestOracle(UNINITIALIZED, DOWN, DOWN, UP_TO_DOWN));
+        oracles.add(new TestOracle(UNINITIALIZED, DOWN, DOWN, NOP));
+        oracles.add(new TestOracle(UNINITIALIZED, ENABLED, ENABLED, NOP));
+        oracles.add(new TestOracle(UNINITIALIZED, READ_ONLY, READ_ONLY, NOP));
+        oracles.add(new TestOracle(UNINITIALIZED, ENABLED, ENABLED, NOP));
+    }
+
+    PoolV2Mode    mode;
+    NextAction    action;
+    PoolOperation operation;
+
+    @Test
+    public void case00ActionShouldBeNOPForDownFollowedByDown() {
+        givenUpdateWithPoolModeEqualToDown();
+        givenUpdateWithPoolModeEqualToDown();
+        assertThatTestCaseObeysOracle(0);
+    }
+
+    @Test
+    public void case01ActionShouldBeNOPForDownFollowedByDownResilienceOff() {
+        givenUpdateWithPoolModeEqualToDown();
+        givenUpdateWithPoolModeEqualToDownButResilienceOff();
+        assertThatTestCaseObeysOracle(1);
+    }
+
+    @Test
+    public void case02ActionShouldBeNOPForDownFollowedByUpResilienceOff() {
+        givenUpdateWithPoolModeEqualToDown();
+        givenUpdateWithPoolModeEnabledButResilienceOff();
+        assertThatTestCaseObeysOracle(2);
+    }
+
+    @Test
+    public void case03ActionShouldBeDownToUpForDownFollowedByReadable() {
+        givenUpdateWithPoolModeEqualToDown();
+        givenUpdateWithPoolModeReadOnly();
+        assertThatTestCaseObeysOracle(3);
+    }
+
+    @Test
+    public void case04ActionShouldBeDownToUpForDownFollowedByWritable() {
+        givenUpdateWithPoolModeEqualToDown();
+        givenUpdateWithPoolModeEnabled();
+        assertThatTestCaseObeysOracle(4);
+    }
+
+    @Test
+    public void case05ActionShouldBeUpToDownForReadableFollowedByDown() {
+        givenUpdateWithPoolModeReadOnly();
+        givenUpdateWithPoolModeEqualToDown();
+        assertThatTestCaseObeysOracle(5);
+    }
+
+    @Test
+    public void case06ActionShouldBeNOPForReadableFollowedByDownResilienceOff() {
+        givenUpdateWithPoolModeReadOnly();
+        givenUpdateWithPoolModeEqualToDownButResilienceOff();
+        assertThatTestCaseObeysOracle(6);
+    }
+
+    @Test
+    public void case07ActionShouldBeNOPForReadableFollowedByUpResilienceOff() {
+        givenUpdateWithPoolModeReadOnly();
+        givenUpdateWithPoolModeEnabledButResilienceOff();
+        assertThatTestCaseObeysOracle(7);
+    }
+
+    @Test
+    public void case08ActionShouldBeNOPForReadableFollowedByReadable() {
+        givenUpdateWithPoolModeReadOnly();
+        givenUpdateWithPoolModeReadOnly();
+        assertThatTestCaseObeysOracle(8);
+    }
+
+    @Test
+    public void case09ActionShouldBeNOPForReadableFollowedByWritable() {
+        givenUpdateWithPoolModeReadOnly();
+        givenUpdateWithPoolModeEnabled();
+        assertThatTestCaseObeysOracle(9);
+    }
+
+    @Test
+    public void case10ActionShouldBeUpToDownForWritableFollowedByDown() {
+        givenUpdateWithPoolModeEnabled();
+        givenUpdateWithPoolModeEqualToDown();
+        assertThatTestCaseObeysOracle(10);
+    }
+
+    @Test
+    public void case11ActionShouldBeNOPForWritableFollowedByDownResilienceOff() {
+        givenUpdateWithPoolModeEnabled();
+        givenUpdateWithPoolModeEqualToDownButResilienceOff();
+        assertThatTestCaseObeysOracle(11);
+    }
+
+    @Test
+    public void case12ActionShouldBeNOPForWritableFollowedByUpResilienceOff() {
+        givenUpdateWithPoolModeEnabled();
+        givenUpdateWithPoolModeEnabledButResilienceOff();
+        assertThatTestCaseObeysOracle(12);
+    }
+
+    @Test
+    public void case13ActionShouldBeNOPForWritableFollowedByReadable() {
+        givenUpdateWithPoolModeEnabled();
+        givenUpdateWithPoolModeReadOnly();
+        assertThatTestCaseObeysOracle(13);
+    }
+
+    @Test
+    public void case14ActionShouldBeNOPForWritableFollowedByWritable() {
+        givenUpdateWithPoolModeEnabled();
+        givenUpdateWithPoolModeEnabled();
+        assertThatTestCaseObeysOracle(14);
+    }
+
+    @Test
+    public void case15ActionShouldBeUpToDownForUninitializedFollowedByDown() {
+        givenUpdateWithPoolModeEqualToDown();
+        assertThatTestCaseObeysOracle(15);
+    }
+
+    @Test
+    public void case16ActionShouldBeNOPForUninitializedFollowedByDownResilienceOff() {
+        givenUpdateWithPoolModeEqualToDownButResilienceOff();
+        assertThatTestCaseObeysOracle(16);
+    }
+
+    @Test
+    public void case17ActionShouldBeNOPForUninitializedFollowedByUpResilienceOff() {
+        givenUpdateWithPoolModeEnabledButResilienceOff();
+        assertThatTestCaseObeysOracle(17);
+    }
+
+    @Test
+    public void case18ActionShouldBeNOPForUninitializedFollowedByReadable() {
+        givenUpdateWithPoolModeReadOnly();
+        assertThatTestCaseObeysOracle(18);
+    }
+
+    @Test
+    public void case19ActionShouldBeNOPForUninitializedFollowedByWritable() {
+        givenUpdateWithPoolModeEnabled();
+        assertThatTestCaseObeysOracle(19);
+    }
+
+    @Before
+    public void setUp() {
+        operation = new PoolOperation(0L);
+    }
+
+    private void assertThatTestCaseObeysOracle(int i) {
+        TestOracle oracle = oracles.get(i);
+        assertEquals(oracle.last, operation.lastStatus);
+        assertEquals(oracle.curr, operation.currStatus);
+        assertEquals(oracle.action, action);
+    }
+
+    private void givenPoolModeOf(int mode, boolean enabled) {
+        this.mode = new PoolV2Mode(mode);
+        operation.state = enabled ? State.WAITING : State.EXCLUDED;
+    }
+
+    private void givenUpdateWithPoolModeEnabled() {
+        givenPoolModeOf(PoolV2Mode.ENABLED, true);
+        whenTransitionIsComputed();
+    }
+
+    private void givenUpdateWithPoolModeEnabledButResilienceOff() {
+        givenPoolModeOf(PoolV2Mode.ENABLED, false);
+        whenTransitionIsComputed();
+    }
+
+    private void givenUpdateWithPoolModeEqualToDown() {
+        givenPoolModeOf(PoolV2Mode.DISABLED_STRICT, true);
+        whenTransitionIsComputed();
+    }
+
+    private void givenUpdateWithPoolModeEqualToDownButResilienceOff() {
+        givenPoolModeOf(PoolV2Mode.DISABLED_STRICT, false);
+        whenTransitionIsComputed();
+    }
+
+    private void givenUpdateWithPoolModeReadOnly() {
+        givenPoolModeOf(PoolV2Mode.DISABLED_RDONLY, true);
+        whenTransitionIsComputed();
+    }
+
+    private void whenTransitionIsComputed() {
+        action = operation.getNextAction(
+                        PoolQoSStatus.getStatusFor(mode));
+    }
+}
diff --git a/modules/dcache-qos/src/test/java/org/dcache/qos/services/scanner/handlers/PoolOperationHandlerTest.java b/modules/dcache-qos/src/test/java/org/dcache/qos/services/scanner/handlers/PoolOperationHandlerTest.java
new file mode 100644
index 0000000000..9466dcf22c
--- /dev/null
+++ b/modules/dcache-qos/src/test/java/org/dcache/qos/services/scanner/handlers/PoolOperationHandlerTest.java
@@ -0,0 +1,419 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos.services.scanner.handlers;
+
+import com.google.common.collect.ImmutableSet;
+import diskCacheV111.pools.PoolV2Mode;
+import diskCacheV111.util.CacheException;
+import diskCacheV111.util.PnfsId;
+import diskCacheV111.vehicles.Message;
+import java.util.List;
+import java.util.Optional;
+import java.util.function.Predicate;
+import java.util.stream.Collectors;
+import org.dcache.qos.TestBase;
+import org.dcache.qos.TestMessageProcessor;
+import org.dcache.qos.TestSynchronousExecutor.Mode;
+import org.dcache.qos.data.PoolQoSStatus;
+import org.dcache.qos.services.adjuster.util.QoSAdjusterTask;
+import org.dcache.qos.services.verifier.data.FileQoSFilter;
+import org.dcache.vehicles.qos.ReplicaStatusMessage;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.dcache.qos.TestSynchronousExecutor.Mode.RUN;
+import static org.junit.Assert.assertEquals;
+
+public class PoolOperationHandlerTest extends TestBase implements TestMessageProcessor {
+    String pool;
+    List<PnfsId> taskPnfsids;
+
+    @Override
+    public void processMessage(Message message) {
+        if (message instanceof ReplicaStatusMessage) {
+            ReplicaStatusMessage reply = (ReplicaStatusMessage) message;
+            reply.setExists(true);
+            reply.setBroken(false);
+            reply.setReadable(true);
+            reply.setRemovable(true);
+            reply.setSystemSticky(true);
+        }
+    }
+
+    @Before
+    public void setUp() throws CacheException, InterruptedException {
+        setUpBase();
+        setPoolMessageProcessor(this);
+        setShortExecutionMode(Mode.NOP);
+        setLongExecutionMode(RUN);
+        setScheduledExecutionMode(RUN);
+        createChangeHandlers();
+        createFileOperationHandler();
+        createFileOperationMap();
+        createPoolOperationHandler();
+        createPoolOperationMap();
+        createAdjusterTaskHandler();
+        createAdjusterTaskMap();
+        createLocationSelector();
+        createRequirementsProvider();
+        createLocalClients();
+        createLocationSelector();
+        initializeCounters();
+        wireFileOperationHandler();
+        wireFileOperationMap();
+        wirePoolOperationHandler();
+        wirePoolOperationMap();
+        wireAdjusterTaskHandler();
+        wireAdjusterTaskMap();
+        wireChangeHandlers();
+        wireLocalClients();
+        wireLocationSelector();
+        fileOperationMap.initialize(() -> {});
+        fileOperationMap.reload();
+        poolOperationMap.setRescanWindow(Integer.MAX_VALUE);
+        poolOperationMap.setDownGracePeriod(0);
+        poolOperationMap.setRestartGracePeriod(0);
+        poolOperationMap.loadPools();
+        setAllPoolsToEnabled();
+        setAllPoolsOperationsToEnabled();
+    }
+
+    @Test
+    public void shouldSubmitUpdateWhenPoolIsNotInPrimaryGroup() {
+        givenADownStatusChangeFor("standard_pool-0");
+        assertEquals("WAITING", poolOperationMap.getState("standard_pool-0"));
+    }
+
+    @Test
+    public void shouldNotSubmitUpdateWhenReadOnlyIsReceivedOnResilientPool() {
+        givenAReadOnlyDownStatusChangeFor("qos_pool-0");
+        assertEquals("IDLE", poolOperationMap.getState(pool));
+    }
+
+    @Test
+    public void shouldSubmitUpdateWhenUpIsReceivedOnResilientPool() {
+        givenADownStatusChangeFor("qos_pool-0");
+        givenAnUpStatusChangeFor("qos_pool-0");
+        assertEquals("WAITING", poolOperationMap.getState(pool));
+    }
+
+    @Test
+    public void shouldProcess0FilesWhenPoolWithMinReplicasRestarts() {
+        givenMinimumReplicasOnPool();
+        givenARestartStatusChangeFor(pool);
+        whenPoolOpScanIsRun();
+        theResultingNumberOfFileOperationsSubmittedWas(0);
+    }
+
+    @Test
+    public void shouldProcess10FilesWhenPoolWithSingleReplicasGoesDown() {
+        givenSingleReplicasOnPool();
+        givenADownStatusChangeFor(pool);
+        whenPoolOpScanIsRun();
+
+        /*
+         * 5 REPLICA ONLINE, 5 CUSTODIAL
+         * (the inaccessible handler is invoked later, during
+         * the verification phase)
+         */
+        theResultingNumberOfFileOperationsSubmittedWas(10);
+    }
+
+    @Test
+    public void shouldProcess10FilesWhenPoolWithSingleReplicasRestarts() {
+        givenSingleReplicasOnPool();
+        givenADownStatusChangeFor(pool);
+        givenARestartStatusChangeFor(pool);
+        whenPoolOpScanIsRun();
+        /*
+         *  5 REPLICA ONLINE, 5 CUSTODIAL ONLINE
+         */
+        theResultingNumberOfFileOperationsSubmittedWas(10);
+    }
+
+    @Test
+    public void shouldProcess6FilesWhenPoolWithExcessReplicasDown() {
+        givenExcessReplicasOnPool();
+        givenADownStatusChangeFor(pool);
+        whenPoolOpScanIsRun();
+
+        /*
+         * 3 REPLICA ONLINE,  CUSTODIAL ONLINE
+         */
+        theResultingNumberOfFileOperationsSubmittedWas(6);
+    }
+
+    @Test
+    public void shouldProcess4FilesWhenPoolWithMinReplicasDown() {
+        givenMinimumReplicasOnPool();
+        givenADownStatusChangeFor(pool);
+        whenPoolOpScanIsRun();
+
+        /*
+         * 2 REPLICA ONLINE, 2 CUSTODIAL ONLINE
+         */
+        theResultingNumberOfFileOperationsSubmittedWas(4);
+    }
+
+    @Test
+    public void shouldProcess6FilesWhenPoolWithExcessReplicasRestarts() {
+        givenExcessReplicasOnPool();
+        givenADownStatusChangeFor(pool);
+        givenARestartStatusChangeFor(pool);
+        whenPoolOpScanIsRun();
+
+        /*
+         * 3 REPLICA ONLINE, 3 CUSTODIAL ONLINE
+         */
+        theResultingNumberOfFileOperationsSubmittedWas(6);
+    }
+
+    @Test
+    public void shouldSubmitUpdateWhenDownIsReceivedOnResilientPool() {
+        givenADownStatusChangeFor("qos_pool-0");
+        assertEquals(PoolQoSStatus.DOWN,
+                        poolOperationMap.getCurrentStatus(pool));
+        assertEquals("WAITING", poolOperationMap.getState(pool));
+    }
+
+    @Test
+    public void shouldSubmitUpdateWhenRestartIsReceivedOnResilientPool() {
+        givenADownStatusChangeFor("qos_pool-0");
+        givenARestartStatusChangeFor("qos_pool-0");
+        assertEquals(PoolQoSStatus.ENABLED,
+                        poolOperationMap.getCurrentStatus(pool));
+        assertEquals("WAITING", poolOperationMap.getState(pool));
+    }
+
+    @Test
+    public void shouldSubmitUpdateWhenWriteDisabled() {
+        givenADisabledStrictStatusChangeFor("qos_pool-0");
+        assertEquals(PoolQoSStatus.DOWN,
+                        poolOperationMap.getCurrentStatus(pool));
+        assertEquals("WAITING", poolOperationMap.getState(pool));
+    }
+
+    @Test
+    public void shouldSetOperationToIdleWhenAdjustmentTasksComplete() {
+        givenExcessReplicasOnPool();
+        givenADownStatusChangeFor(pool);
+        whenPoolOpScanIsRun();
+        whenVerifyScanIsRun();
+        /*
+         *  There are six files, max running = 2.
+         */
+        for (int i = 0; i < 5; ++i) {
+            whenAdjusterTasksForPoolSucceed();
+            whenVerifyTasksForPoolAreVoided();
+            whenVerifyScanIsRun();
+        }
+        assertEquals("IDLE", poolOperationMap.getState(pool));
+    }
+
+    @Test
+    public void shouldSetOperationToIdleWhenAdjustmentTasksFail() {
+        givenExcessReplicasOnPool();
+        givenADownStatusChangeFor(pool);
+        whenPoolOpScanIsRun();
+        whenVerifyScanIsRun();
+        /*
+         *  There are six files, max running = 2.
+         */
+        for (int i = 0; i < 5; ++i) {
+            whenAdjusterTasksForPoolFail();
+            whenVerifyTasksForPoolAreVoided();
+            whenVerifyScanIsRun();
+        }
+        assertEquals("IDLE", poolOperationMap.getState(pool));
+    }
+
+    @Test
+    public void shouldNotLaunchSecondOperationUntilFirstHasCompleted() {
+        givenExcessReplicasOnPool();
+        givenMaxConcurrentScanIs(1);
+        givenADownStatusChangeFor("qos_pool-5");
+        whenPoolOpScanIsRun();
+        assertEquals("RUNNING", poolOperationMap.getState(pool));
+        givenADownStatusChangeFor("qos_pool-7");
+        whenPoolOpScanIsRun();
+        assertEquals("WAITING", poolOperationMap.getState("qos_pool-7"));
+        whenVerifyScanIsRun();
+        /*
+         *  There are six files, max running = 2.  Since a second pool is down,
+         *  the excess copies are no longer excess, and these operations will
+         *  end up being VOID.
+         */
+        for (int i = 0; i < 5; ++i) {
+            whenAdjusterTasksForPoolFail();
+            whenVerifyTasksForPoolAreVoided();
+            whenVerifyScanIsRun();
+        }
+        assertEquals("IDLE", poolOperationMap.getState("qos_pool-5"));
+        whenPoolOpScanIsRun();
+        /*
+         *  There are four files, max running = 2.
+         */
+        for (int i = 0; i < 4; ++i) {
+            whenAdjusterTasksForPoolFail();
+            whenVerifyTasksForPoolAreVoided();
+            whenVerifyScanIsRun();
+        }
+        assertEquals("IDLE", poolOperationMap.getState("qos_pool-7"));
+    }
+
+    private void givenADownStatusChangeFor(String pool) {
+        this.pool = pool;
+        PoolV2Mode mode = new PoolV2Mode(PoolV2Mode.DISABLED_DEAD);
+        poolInfoMap.updatePoolMode(pool, mode);
+        poolOperationHandler.handlePoolStatusChange(pool, PoolQoSStatus.getStatusFor(mode));
+    }
+
+    private void givenAReadOnlyDownStatusChangeFor(String pool) {
+        this.pool = pool;
+        PoolV2Mode mode = new PoolV2Mode(PoolV2Mode.DISABLED_RDONLY);
+        poolInfoMap.updatePoolMode(pool, mode);
+        poolOperationHandler.handlePoolStatusChange(pool, PoolQoSStatus.getStatusFor(mode));
+    }
+
+    private void givenARestartStatusChangeFor(String pool) {
+        this.pool = pool;
+        PoolV2Mode mode = new PoolV2Mode(PoolV2Mode.ENABLED);
+        poolInfoMap.updatePoolMode(pool, mode);
+        poolOperationHandler.handlePoolStatusChange(pool, PoolQoSStatus.getStatusFor(mode));
+    }
+
+    private void givenADisabledStrictStatusChangeFor(String pool) {
+        this.pool = pool;
+        PoolV2Mode mode = new PoolV2Mode(PoolV2Mode.DISABLED_STRICT);
+        poolInfoMap.updatePoolMode(pool, mode);
+        poolOperationHandler.handlePoolStatusChange(pool, PoolQoSStatus.getStatusFor(mode));
+    }
+
+    private void givenAnUpStatusChangeFor(String pool) {
+        this.pool = pool;
+        PoolV2Mode mode = new PoolV2Mode(PoolV2Mode.DISABLED_RDONLY);
+        poolInfoMap.updatePoolMode(pool, mode);
+        poolOperationHandler.handlePoolStatusChange(pool, PoolQoSStatus.getStatusFor(mode));
+    }
+
+    private void givenExcessReplicasOnPool() {
+        loadFilesWithExcessLocations();
+        pool = "qos_pool-5";
+    }
+
+    private void givenMaxConcurrentScanIs(int max) {
+        poolOperationMap.setMaxConcurrentRunning(max);
+    }
+
+    private void givenMinimumReplicasOnPool() {
+        loadFilesWithRequiredLocations();
+        pool = "qos_pool-13";
+    }
+
+    private void givenSingleReplicasOnPool() {
+        loadNewFilesOnPoolsWithHostAndRackTags();
+        pool = "qos_pool-10";
+    }
+
+    private void theResultingNumberOfFileOperationsSubmittedWas(int submitted) {
+        FileQoSFilter filter = new FileQoSFilter();
+        /*
+         *  The operation map is not actually running, so the state is READY.
+         */
+        filter.setState(ImmutableSet.of("READY"));
+        assertEquals(submitted, fileOperationMap.count(filter, new StringBuilder()));
+    }
+
+    private void whenPoolOpScanIsRun() {
+        poolOperationMap.scan();
+        poolOperationMap.runNow();
+    }
+
+    private void whenAdjusterTasksForPoolSucceed() {
+        adjusterTaskMap.scan();
+        Predicate<QoSAdjusterTask> predicate = t->true;
+        taskPnfsids = adjusterTaskMap.getTasks(predicate, Integer.MAX_VALUE)
+                                     .stream()
+                                     .map(QoSAdjusterTask::getPnfsId)
+                                     .collect(Collectors.toList());
+        taskPnfsids.stream().forEach(id->adjusterTaskMap.updateTask(id, Optional.empty(), null));
+        adjusterTaskMap.scan();
+    }
+
+    private void whenAdjusterTasksForPoolFail() {
+        adjusterTaskMap.scan();
+        Predicate<QoSAdjusterTask> predicate = t->true;
+        taskPnfsids = adjusterTaskMap.getTasks(predicate, Integer.MAX_VALUE)
+            .stream()
+            .map(QoSAdjusterTask::getPnfsId)
+            .collect(Collectors.toList());
+        CacheException unexpected = new CacheException(CacheException.UNEXPECTED_SYSTEM_EXCEPTION, "Forced failure");
+        taskPnfsids.stream().forEach(id->adjusterTaskMap.updateTask(id, Optional.empty(), unexpected));
+        adjusterTaskMap.scan();
+    }
+
+    private void whenVerifyTasksForPoolAreVoided() {
+        taskPnfsids.stream().forEach(fileOperationMap::voidOperation);
+    }
+
+    private void whenVerifyScanIsRun() {
+        fileOperationMap.scan();
+    }
+}
diff --git a/modules/dcache-qos/src/test/java/org/dcache/qos/services/verifier/data/FileQoSFilterTest.java b/modules/dcache-qos/src/test/java/org/dcache/qos/services/verifier/data/FileQoSFilterTest.java
new file mode 100644
index 0000000000..9e769717ce
--- /dev/null
+++ b/modules/dcache-qos/src/test/java/org/dcache/qos/services/verifier/data/FileQoSFilterTest.java
@@ -0,0 +1,293 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos.services.verifier.data;
+
+import com.google.common.base.Joiner;
+import com.google.common.collect.ImmutableSet;
+import diskCacheV111.util.CacheException;
+import diskCacheV111.util.PnfsId;
+import java.util.concurrent.TimeUnit;
+import org.dcache.qos.TestBase;
+import org.dcache.qos.data.QoSAction;
+import org.dcache.qos.data.QoSMessageType;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+public final class FileQoSFilterTest extends TestBase {
+    FileQoSFilter    filter;
+    FileQoSOperation operation;
+
+    @Before
+    public void setUp() throws CacheException {
+        setUpBase();
+        loadNewFilesOnPoolsWithNoTags();
+        loadNonResilientFiles();
+    }
+
+    @Test
+    public void shouldIndicateSimplePnfsMatch() throws Exception {
+        String pnfsids = aReplicaOnlineFileWithNoTags().getPnfsId().toString();
+        givenFilterWith(pnfsids, null, null, null, null, null, false);
+        assertTrue(filter.isSimplePnfsMatch());
+    }
+
+    @Test
+    public void shouldIndicateSimplePnfsMatchNotwithstandingOtherAttributes()
+                    throws Exception {
+        String pnfsids = aReplicaOnlineFileWithNoTags().getPnfsId().toString();
+        givenFilterWith(pnfsids, "RUNNING", null, null, null, null, false);
+        assertTrue(filter.isSimplePnfsMatch());
+    }
+
+    @Test
+    public void shouldMatchWhenAfterMatches() throws Exception {
+        givenFilterWith(null, null, null, null, System.currentTimeMillis(),
+                        null, false);
+        givenOperationWith(aReplicaOnlineFileWithNoTags().getPnfsId(),
+                        QoSAction.VOID, "qos-2.dcache-devel-test@enstore",
+                        "RUNNING", System.currentTimeMillis()
+                                        + TimeUnit.HOURS.toMillis(1));
+        assertTrue(filter.matches(operation, poolInfoMap));
+    }
+
+    @Test
+    public void shouldMatchWhenBeforeMatches() throws Exception {
+        givenFilterWith(null, null, null, null, null,
+                        System.currentTimeMillis(), false);
+        givenOperationWith(aReplicaOnlineFileWithNoTags().getPnfsId(),
+                        QoSAction.VOID, "qos-2.dcache-devel-test@enstore",
+                        "RUNNING", System.currentTimeMillis()
+                                        - TimeUnit.HOURS.toMillis(1));
+        assertTrue(filter.matches(operation, poolInfoMap));
+    }
+
+    @Test
+    public void shouldMatchWhenMultipleAttributesMatch() throws Exception {
+        String pnfsids = Joiner.on(",").join(
+                        aReplicaOnlineFileWithNoTags().getPnfsId().toString(),
+                        aNonResilientFile().getPnfsId().toString());
+        givenFilterWith(pnfsids, "READY", null,
+                        "qos-2.dcache-devel-test@enstore", null, null,
+                        false);
+        givenOperationWith(aReplicaOnlineFileWithNoTags().getPnfsId(),
+                        QoSAction.VOID, "qos-2.dcache-devel-test@enstore",
+                        "READY", System.currentTimeMillis());
+        assertTrue(filter.matches(operation, poolInfoMap));
+    }
+
+    @Test
+    public void shouldMatchWhenPolicyMatches() throws Exception {
+        givenFilterWith(null, null, QoSAction.VOID, null, null, null, false);
+        givenOperationWith(aReplicaOnlineFileWithNoTags().getPnfsId(),
+                        QoSAction.VOID, "qos-2.dcache-devel-test@enstore",
+                        "RUNNING", System.currentTimeMillis());
+        assertTrue(filter.matches(operation, poolInfoMap));
+    }
+
+    @Test
+    public void shouldMatchWhenSpecifiedPnfsIdMatches() throws Exception {
+        String pnfsids = Joiner.on(",").join(
+                        aReplicaOnlineFileWithNoTags().getPnfsId().toString(),
+                        aNonResilientFile().getPnfsId().toString());
+        givenFilterWith(pnfsids, null, null, null, null, null, false);
+        givenOperationWith(aReplicaOnlineFileWithNoTags().getPnfsId(),
+                        QoSAction.VOID, "qos-2.dcache-devel-test@enstore",
+                        "RUNNING", System.currentTimeMillis());
+        assertTrue(filter.matches(operation, poolInfoMap));
+    }
+
+    @Test
+    public void shouldMatchWhenStatesMatch() throws Exception {
+        givenFilterWith(null, "RUNNING", null, null, null, null, false);
+        givenOperationWith(aReplicaOnlineFileWithNoTags().getPnfsId(),
+                        QoSAction.VOID, null, "RUNNING", System.currentTimeMillis());
+        assertTrue(filter.matches(operation, poolInfoMap));
+    }
+
+    @Test
+    public void shouldMatchWhenStorageUnitMatches() throws Exception {
+        givenFilterWith(null, null, null,
+                        "qos-2.dcache-devel-test@enstore", null, null,
+                        false);
+        givenOperationWith(aReplicaOnlineFileWithNoTags().getPnfsId(),
+                        QoSAction.VOID, "qos-2.dcache-devel-test@enstore",
+                        "RUNNING", System.currentTimeMillis());
+        assertTrue(filter.matches(operation, poolInfoMap));
+    }
+
+    @Test
+    public void shouldNotIndicateSimplePnfsMatchBecauseOfMultiplePnfsIds()
+                    throws Exception {
+        String pnfsids = Joiner.on(",").join(
+                        aReplicaOnlineFileWithNoTags().getPnfsId().toString(),
+                        aNonResilientFile().getPnfsId().toString());
+        givenFilterWith(pnfsids, null, null, null, null, null, false);
+        assertFalse(filter.isSimplePnfsMatch());
+    }
+
+    @Test
+    public void shouldNotMatchWhenActionDoesNotMatch() throws Exception {
+        givenFilterWith(null, null, QoSAction.COPY_REPLICA, null, null,
+            null, false);
+        givenOperationWith(aReplicaOnlineFileWithNoTags().getPnfsId(),
+            QoSAction.VOID, "qos-2.dcache-devel-test@enstore",
+            "RUNNING", System.currentTimeMillis()
+                - TimeUnit.HOURS.toMillis(1));
+        assertFalse(filter.matches(operation, poolInfoMap));
+    }
+
+    @Test
+    public void shouldNotMatchWhenAfterDoesNotMatch() throws Exception {
+        givenFilterWith(null, null, null, null, System.currentTimeMillis(),
+                        null, false);
+        givenOperationWith(aReplicaOnlineFileWithNoTags().getPnfsId(),
+                        QoSAction.VOID, "qos-2.dcache-devel-test@enstore",
+                        "RUNNING", System.currentTimeMillis()
+                                        - TimeUnit.HOURS.toMillis(1));
+        assertFalse(filter.matches(operation, poolInfoMap));
+    }
+
+    @Test
+    public void shouldNotMatchWhenBeforeDoesNotMatch() throws Exception {
+        givenFilterWith(null, null, null, null, null,
+                        System.currentTimeMillis(), false);
+        givenOperationWith(aReplicaOnlineFileWithNoTags().getPnfsId(),
+                        QoSAction.VOID, "qos-2.dcache-devel-test@enstore",
+                        "RUNNING", System.currentTimeMillis() +
+                                        TimeUnit.HOURS.toMillis(1));
+        assertFalse(filter.matches(operation, poolInfoMap));
+    }
+
+    @Test
+    public void shouldNotMatchWhenOneOfSeveralAttributesDoesNotMatch()
+                    throws Exception {
+        String pnfsids = Joiner.on(",").join(
+                        aReplicaOnlineFileWithNoTags().getPnfsId().toString(),
+                        aNonResilientFile().getPnfsId().toString());
+        givenFilterWith(pnfsids, "READY", null,
+                        "qos-3.dcache-devel-test@enstore", null, null,
+                        false);
+        givenOperationWith(aReplicaOnlineFileWithNoTags().getPnfsId(),
+                        QoSAction.VOID, "qos-2.dcache-devel-test@enstore",
+                        "READY", System.currentTimeMillis());
+        assertFalse(filter.matches(operation, poolInfoMap));
+    }
+
+    @Test
+    public void shouldNotMatchWhenSpecifiedPnfsIdDoesNotMatch()
+                    throws Exception {
+        givenFilterWith(aCustodialNearlineFile().getPnfsId().toString(), null,
+                        null, null, null, null, false);
+        givenOperationWith(aReplicaOnlineFileWithNoTags().getPnfsId(),
+                        QoSAction.VOID, "qos-2.dcache-devel-test@enstore",
+                        "RUNNING", System.currentTimeMillis());
+        assertFalse(filter.matches(operation, poolInfoMap));
+    }
+
+    @Test
+    public void shouldNotMatchWhenStatesDoNotMatch() throws Exception {
+        givenFilterWith(null, "WAITING", null, null, null, null, false);
+        givenOperationWith(aReplicaOnlineFileWithNoTags().getPnfsId(),
+                        QoSAction.VOID, null, "RUNNING", System.currentTimeMillis());
+        assertFalse(filter.matches(operation, poolInfoMap));
+    }
+
+    @Test
+    public void shouldNotMatchWhenStorageUnitDoesNotMatch() throws Exception {
+        givenFilterWith(null, null, null,
+                        "qos-3.dcache-devel-test@enstore", null, null,
+                        false);
+        givenOperationWith(aReplicaOnlineFileWithNoTags().getPnfsId(),
+                        QoSAction.VOID, "qos-2.dcache-devel-test@enstore",
+                        "RUNNING", System.currentTimeMillis());
+        assertFalse(filter.matches(operation, poolInfoMap));
+    }
+
+    private void givenFilterWith(String pnfsIds, String states,
+                    QoSAction action, String storageUnit, Long after,
+                    Long before, boolean force) {
+        filter = new FileQoSFilter();
+        filter.setForceRemoval(force);
+        filter.setLastUpdateAfter(after);
+        filter.setLastUpdateBefore(before);
+        filter.setPnfsIds(pnfsIds);
+        filter.setAction(action);
+        if (states != null) {
+            filter.setState(ImmutableSet.copyOf(states.split("[,]")));
+        }
+        filter.setStorageUnit(storageUnit);
+    }
+
+    private void givenOperationWith(PnfsId pnfsId, QoSAction action,
+                    String storageUnit, String state, Long update) {
+        Integer sunit = storageUnit != null ?
+                        poolInfoMap.getUnitIndex(storageUnit) : null;
+        operation = new FileQoSOperation(pnfsId, QoSMessageType.ADD_CACHE_LOCATION,-1, sunit, 2L);
+        operation.setLastUpdate(update);
+        operation.setAction(action);
+
+        if (state != null) {
+            operation.setState(state);
+        }
+    }
+}
diff --git a/modules/dcache-qos/src/test/java/org/dcache/qos/services/verifier/data/FileQoSOperationMapTest.java b/modules/dcache-qos/src/test/java/org/dcache/qos/services/verifier/data/FileQoSOperationMapTest.java
new file mode 100644
index 0000000000..a747cdd413
--- /dev/null
+++ b/modules/dcache-qos/src/test/java/org/dcache/qos/services/verifier/data/FileQoSOperationMapTest.java
@@ -0,0 +1,560 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos.services.verifier.data;
+
+import diskCacheV111.util.CacheException;
+import diskCacheV111.util.PnfsId;
+import java.io.File;
+import java.io.IOException;
+import org.dcache.qos.TestBase;
+import org.dcache.qos.TestSynchronousExecutor.Mode;
+import org.dcache.qos.data.FileQoSUpdate;
+import org.dcache.qos.data.QoSAction;
+import org.dcache.qos.data.QoSMessageType;
+import org.dcache.qos.services.verifier.handlers.CheckpointHandler;
+import org.dcache.vehicles.FileAttributes;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.dcache.qos.data.QoSAction.VOID;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+
+public final class FileQoSOperationMapTest extends TestBase {
+    PnfsId         pnfsId;
+    FileAttributes attributes;
+    FileQoSOperation  operation;
+    File checkpoint = new File("checkpoint");
+
+    @Before
+    public void setUp() throws CacheException, InterruptedException {
+        setUpBase();
+        setMocks();
+        createFileOperationHandler();
+        createFileOperationMap();
+        createAdjusterTaskHandler();
+        wireAdjusterTaskHandler();
+        createLocalClients();
+        wireFileOperationMap();
+        wireFileOperationHandler();
+        wireLocalClients();
+        initializeCounters();
+
+        CheckpointHandler handler = new CheckpointHandler();
+        handler.setPoolInfoMap(poolInfoMap);
+        handler.setFileQoSOperationMap(fileOperationMap);
+
+        fileOperationMap.setMaxRunning(1);
+        fileOperationMap.setCheckpointHandler(handler);
+        fileOperationMap.initialize(() -> {});
+    }
+
+    @Test
+    public void shouldMakeCopiesForFileWithUnmappedStorageUnit()
+                    throws CacheException, IOException {
+        givenANewPnfsIdWithUnmappedStorageUnit();
+        afterOperationAdded();
+        whenScanIsRun();
+        assertNotNull(fileOperationMap.getOperation(operation.getPnfsId()));
+    }
+
+    @Test
+    public void shouldMakeCopiesForFileWithStorageUnitMatchingPattern()
+                    throws CacheException, IOException {
+        givenANewPnfsIdWithStorageUnitMatchingPattern();
+        afterOperationAdded();
+        whenScanIsRun();
+        assertNotNull(fileOperationMap.getOperation(operation.getPnfsId()));
+    }
+
+    @Test
+    public void shouldBehaveLikeCancelAllWhenOperationIsVoided()
+                    throws CacheException, IOException {
+        givenANewPnfsId();
+        afterOperationAdded();
+        whenScanIsRun();
+        whenOperationIsVoided();
+        whenScanIsRun();
+        assertNull(fileOperationMap.getOperation(operation.getPnfsId()));
+    }
+
+    @Test
+    public void shouldNotRemoveEntryWhenUpdateFailsOnLastTryButOtherSourceExists()
+                    throws CacheException, IOException {
+        givenAPnfsIdUpdateFromScan();
+        afterOperationAdded();
+        afterSourceAndTargetAreUpdatedTo(attributes.getLocations().iterator().next(),
+                                 "qos_pool-12");
+        whenOperationFailsWithRetriableError();
+        whenScanIsRun();
+        whenOperationFailsWithRetriableError();
+        /*
+         * Another source exists.  Should not fail terminally.
+         */
+        whenScanIsRun();
+        assertNotNull(fileOperationMap.getOperation(operation.getPnfsId()));
+    }
+
+    @Test
+    public void shouldNotRemoveEntryWhenUpdateFailsWithRetriableError()
+                    throws CacheException, IOException {
+        givenANewPnfsId();
+        afterOperationAdded();
+        afterSourceAndTargetAreUpdatedTo(
+                        attributes.getLocations().iterator().next(),
+                        "qos_pool-12");
+        whenOperationFailsWithRetriableError();
+        whenScanIsRun();
+        assertNotNull(fileOperationMap.getOperation(operation.getPnfsId()));
+    }
+
+    @Test
+    public void shouldNotRemoveEntryWhenUpdateSuccessfulButMoreWork()
+                    throws CacheException, IOException {
+        givenANewPnfsId();
+        afterOperationAdded();
+        afterSourceAndTargetAreUpdatedTo(attributes.getLocations().iterator().next(),
+                                  "qos_pool-12");
+        whenOperationSucceedsFor(operation.getPnfsId());
+        whenScanIsRun();
+        assertNotNull(fileOperationMap.getOperation(operation.getPnfsId()));
+    }
+
+    @Test
+    public void shouldNotRemoveEntryWhenUpdateSuccessfulButNewRequestArrived()
+                    throws CacheException, IOException {
+        givenANewPnfsId();
+        afterOperationAdded();
+        afterSourceAndTargetAreUpdatedTo(attributes.getLocations().iterator().next(),
+                                  "qos_pool-12");
+        whenOperationSucceedsFor(operation.getPnfsId());
+        givenAnotherLocationForPnfsId();
+        whenScanIsRun();
+        assertNotNull(fileOperationMap.getOperation(operation.getPnfsId()));
+    }
+
+    @Test
+    public void shouldNotRemoveWhenCancelledOperationHasMoreWork()
+                    throws CacheException, IOException {
+        givenANewPnfsId();
+        afterOperationAdded();
+        afterSourceAndTargetAreUpdatedTo(attributes.getLocations().iterator().next(),
+                        "qos_pool-12");
+        whenScanIsRun();
+        whenRunningOperationIsCancelled();
+        whenScanIsRun();
+        assertNotNull(fileOperationMap.getOperation(operation.getPnfsId()));
+    }
+
+    @Test
+    public void shouldNotReorderOperationWhenFailsButMoreTries()
+                    throws CacheException, IOException {
+        givenANewPnfsId();
+        afterOperationAdded();
+        afterSourceAndTargetAreUpdatedTo(
+                        attributes.getLocations().iterator().next(),
+                        "qos_pool-12");
+        whenScanIsRun();
+        whenOperationFailsWithRetriableError();
+        givenASecondPnfsId();
+        afterOperationAdded();
+        whenScanIsRun();
+        assertThatOperationIsRunning(pnfsId);
+    }
+
+    @Test
+    public void shouldRemoveEntryWhenUpdateFailsOnLastTryOfRetriableError()
+                    throws CacheException, IOException {
+        givenANewPnfsId();
+        afterOperationAddedWithPoolGroup("standard-group");
+        afterSourceAndTargetAreUpdatedTo("standard_pool-0", "standard_pool-1");
+        whenScanIsRun();  // PROMOTES TO RUNNING
+        whenOperationFailsWithRetriableError();
+        whenScanIsRun();  // RETRY (1)
+        whenOperationFailsWithRetriableError();
+
+        /*
+         * This should set retry with new source and target, but
+         * there should be no other source when it retries, and a failure
+         * should result.
+         */
+        whenScanIsRun(); // RETRY (2)
+
+
+        assertNull(fileOperationMap.getOperation(operation.getPnfsId()));
+    }
+
+    @Test
+    public void shouldRemoveEntryWhenUpdateFailsWithFatalError()
+                    throws CacheException, IOException {
+        givenANewPnfsId();
+        afterOperationAdded();
+        afterSourceAndTargetAreUpdatedTo(
+                        attributes.getLocations().iterator().next(),
+                        "qos_pool-12");
+        whenScanIsRun();
+        whenOperationFailsWithFatalError();
+        whenScanIsRun();
+        assertNull(fileOperationMap.getOperation(operation.getPnfsId()));
+    }
+
+    @Test
+    public void shouldRemoveEntryWhenUpdateSuccessfulAndNoMoreWork()
+                    throws CacheException, IOException {
+        givenANewPnfsId();
+        afterOperationAdded();
+        afterSourceAndTargetAreUpdatedTo(
+                        attributes.getLocations().iterator().next(),
+                        "qos_pool-12");
+        whenScanIsRun();
+        whenOperationSucceedsFor(operation.getPnfsId());
+        whenScanIsRun();
+        whenNoMoreWorkFor(operation.getPnfsId());
+        whenScanIsRun();
+        assertNull(fileOperationMap.getOperation(operation.getPnfsId()));
+    }
+
+    @Test
+    public void shouldRemoveWhenEntireOperationIsCancelled()
+                    throws CacheException, IOException {
+        givenANewPnfsId();
+        afterOperationAdded();
+        afterSourceAndTargetAreUpdatedTo(
+                        attributes.getLocations().iterator().next(),
+                        "qos_pool-12");
+        whenScanIsRun();
+        whenEntireOperationIsCancelled();
+        whenScanIsRun();
+        assertNull(fileOperationMap.getOperation(operation.getPnfsId()));
+    }
+
+    @Test
+    public void shouldReorderOperationWhenCompletesButMoreWork()
+                    throws CacheException, IOException {
+        givenANewPnfsId();
+        afterOperationAdded();
+        afterSourceAndTargetAreUpdatedTo(attributes.getLocations().iterator().next(),
+                                    "qos_pool-12");
+        whenScanIsRun();
+        whenOperationSucceedsFor(attributes.getPnfsId());
+        givenASecondPnfsId();
+        afterOperationAdded();
+        afterSourceAndTargetAreUpdatedTo(pnfsId,
+                                         attributes.getLocations().iterator().next(),
+                                  "qos_pool-12");
+        whenScanIsRun();
+        assertThatOperationIsNotRunning(attributes.getPnfsId());
+        assertThatOperationIsRunning(pnfsId);
+    }
+
+    @Test
+    public void shouldResetEntryWhenUpdateFailsWithNewLocationError()
+                    throws CacheException, IOException {
+        givenANewPnfsId();
+        afterOperationAdded();
+        afterSourceAndTargetAreUpdatedTo(
+                        attributes.getLocations().iterator().next(),
+                        "qos_pool-12");
+        whenOperationFailsWithNewLocationError();
+        whenScanIsRun();
+        assertNotNull(fileOperationMap.getOperation(operation.getPnfsId()));
+        assertEquals(0, fileOperationMap.getOperation(
+                        operation.getPnfsId()).getRetried());
+    }
+
+    @Test
+    public void shouldSaveAndRestoreCheckpointedOperation()
+                    throws CacheException, IOException {
+        givenANewPnfsId();
+        afterOperationAdded();
+        whenSaveIsCalled();
+        whenLoadIsCalled();
+        assertNotNull(fileOperationMap.getOperation(operation.getPnfsId()));
+    }
+
+    @Test
+    public void shouldNotFailWhenPostProcessDiscoversRemovedPool() throws Exception {
+        givenANewPnfsId();
+        afterOperationAdded();
+        String source = attributes.getLocations().iterator().next();
+        afterSourceAndTargetAreUpdatedTo(source,"qos_pool-12");
+        afterPoolIsRemoved(source);
+        whenScanIsRun();
+        whenOperationSucceedsFor(operation.getPnfsId());
+        /*
+         *  Should not throw an exception.  Operation is still in queue for
+         *  final verification.
+         */
+        whenScanIsRun();
+        assertNotNull(fileOperationMap.getOperation(operation.getPnfsId()));
+    }
+
+    @Test
+    public void shouldNotFailWhenPostProcessDiscoversRemovedPoolGroup()
+        throws Exception {
+        givenANewPnfsId();
+        afterOperationAdded();
+        String source = attributes.getLocations().iterator().next();
+        afterSourceAndTargetAreUpdatedTo(source,"qos_pool-12");
+        afterOperationGroupIsRemoved();
+        whenScanIsRun();
+        whenOperationSucceedsFor(operation.getPnfsId());
+        /*
+         *  Should not throw an exception. Operation is still in queue for
+         *  final verification.
+         */
+        whenScanIsRun();
+        assertNotNull(fileOperationMap.getOperation(operation.getPnfsId()));
+    }
+
+    @Test
+    public void shouldNotFailWhenPostProcessDiscoversRemovedStorageUnit()
+        throws Exception {
+        givenANewPnfsId();
+        afterOperationAdded();
+        afterSourceAndTargetAreUpdatedTo(attributes.getLocations().iterator().next(),
+                                  "qos_pool-12");
+        afterOperationStorageUnitIsRemoved();
+        whenScanIsRun();
+        whenOperationSucceedsFor(operation.getPnfsId());
+        /*
+         *  Should not throw an exception. Operation is still in queue for
+         *  final verification.
+         */
+        whenScanIsRun();
+        assertNotNull(fileOperationMap.getOperation(operation.getPnfsId()));
+    }
+
+    @Test
+    public void shouldNotFailWhenOperationIsCancelledBecauseOfPoolRemoval()
+        throws Exception {
+        givenANewPnfsId();
+        afterOperationAdded();
+        String source = attributes.getLocations().iterator().next();
+        afterSourceAndTargetAreUpdatedTo(source,"qos_pool-12");
+        afterPoolIsRemoved(source);
+        whenScanIsRun();
+        whenRunningOperationIsCancelled();
+        /*
+         *  Should not throw an exception. Operation is still in queue for
+         *  final verification.
+         */
+        whenScanIsRun();
+        assertNotNull(fileOperationMap.getOperation(operation.getPnfsId()));
+    }
+
+    @After
+    public void tearDown() {
+        if (checkpoint.exists()) {
+            checkpoint.delete();
+        }
+    }
+
+    private void afterOperationAdded() throws CacheException {
+        afterOperationAddedWithPoolGroup(null);
+    }
+
+    private void afterOperationAddedWithPoolGroup(String poolGroup) throws CacheException {
+        PnfsId pnfsId = attributes.getPnfsId();
+        String pool = attributes.getLocations().iterator().next();
+        FileQoSUpdate update = new FileQoSUpdate(pnfsId, pool, QoSMessageType.ADD_CACHE_LOCATION);
+        if (poolGroup != null) {
+            update.setEffectivePoolGroup(poolGroup);
+        }
+        fileOperationMap.register(update);
+        operation = fileOperationMap.getOperation(attributes.getPnfsId());
+    }
+
+    private void afterPoolIsRemoved(String pool) throws Exception {
+        poolInfoMap.removePool(pool);
+    }
+
+    private void afterOperationGroupIsRemoved() throws Exception {
+        String group = poolInfoMap.getGroup(operation.getPoolGroup());
+        poolInfoMap.removeUnit(group);
+    }
+
+    private void afterOperationStorageUnitIsRemoved() throws Exception {
+        String unit = poolInfoMap.getUnit(operation.getStorageUnit());
+        poolInfoMap.removeUnit(unit);
+    }
+
+    private void afterSourceAndTargetAreUpdatedTo(String source, String target) {
+        FileQoSOperation operation = fileOperationMap.getOperation(attributes.getPnfsId());
+        operation.setSource(poolInfoMap.getPoolIndex(source));
+        operation.setTarget(poolInfoMap.getPoolIndex(target));
+        operation.setAction(QoSAction.COPY_REPLICA);
+        fileOperationMap.updateOperation(attributes.getPnfsId(), null);
+    }
+
+    private void afterSourceAndTargetAreUpdatedTo(PnfsId pnfsId, String source, String target) {
+        FileQoSOperation operation = fileOperationMap.getOperation(pnfsId);
+        operation.setSource(poolInfoMap.getPoolIndex(source));
+        operation.setTarget(poolInfoMap.getPoolIndex(target));
+        operation.setAction(QoSAction.COPY_REPLICA);
+        fileOperationMap.updateOperation(attributes.getPnfsId(), null);
+    }
+
+    private void assertThatOperationIsNotRunning(PnfsId pnfsId) {
+        assertNotEquals(pnfsId, fileOperationMap.running.peek().getPnfsId());
+    }
+
+    private void assertThatOperationIsRunning(PnfsId pnfsId) {
+        assertEquals(pnfsId, fileOperationMap.running.peek().getPnfsId());
+    }
+
+    private void givenANewPnfsId() throws CacheException {
+        loadNewFilesOnPoolsWithNoTags();
+        attributes = aReplicaOnlineFileWithNoTags();
+    }
+
+    private void givenANewPnfsIdWithUnmappedStorageUnit() throws CacheException {
+        loadNewFilesWithUnmappedStorageUnit();
+        attributes = aReplicaOnlineFileWithNoTags();
+    }
+
+    private void givenANewPnfsIdWithStorageUnitMatchingPattern() throws CacheException {
+        turnOnRegex();
+        loadNewFilesWithStorageUnitMatchingPattern();
+        attributes = aReplicaOnlineFileWithNoTags();
+    }
+
+    private void givenAPnfsIdUpdateFromScan() throws CacheException {
+        loadFilesWithRequiredLocations();
+        attributes = aReplicaOnlineFileWithNoTags();
+    }
+
+    private void givenASecondPnfsId() throws CacheException {
+        pnfsId = attributes.getPnfsId();
+        attributes = aReplicaOnlineFileWithHostTag();
+    }
+
+    private void givenAnotherLocationForPnfsId() {
+//        fileOperationMap.getOperation(operation.getPnfsId()).incrementCount();
+    }
+
+    private void setMocks() {
+        setShortExecutionMode(Mode.NOP);
+        setLongExecutionMode(Mode.NOP);
+        setScheduledExecutionMode(Mode.NOP);
+    }
+
+    private void whenEntireOperationIsCancelled() {
+        fileOperationMap.cancel(operation.getPnfsId(), true);
+    }
+
+    private void whenLoadIsCalled() throws IOException {
+        fileOperationMap.reload();
+    }
+
+    private void whenOperationFailsWithFatalError() {
+        fileOperationMap.updateOperation(operation.getPnfsId(),
+                                         new CacheException(CacheException.DEFAULT_ERROR_CODE,
+                                        FORCED_FAILURE.toString()));
+    }
+
+    private void whenOperationFailsWithNewLocationError() {
+        fileOperationMap.updateOperation(operation.getPnfsId(),
+                                         new CacheException(CacheException.FILE_NOT_FOUND,
+                                        FORCED_FAILURE.toString()));
+    }
+
+    private void whenOperationFailsWithRetriableError() {
+        fileOperationMap.updateOperation(operation.getPnfsId(),
+                                         new CacheException(CacheException.HSM_DELAY_ERROR,
+                                        FORCED_FAILURE.toString()));
+    }
+
+    private void whenOperationIsVoided() {
+        fileOperationMap.voidOperation(operation.getPnfsId());
+    }
+
+    private void whenOperationSucceedsFor(PnfsId pnfsId) {
+        /*
+         *  Simulate previous launch without doing a full scan.
+         */
+        fileOperationMap.updateOperation(pnfsId, null);
+    }
+
+    private void whenNoMoreWorkFor(PnfsId pnfsId) {
+        fileOperationMap.getOperation(pnfsId).setAction(VOID);
+        fileOperationMap.updateOperation(pnfsId, null);
+    }
+
+    private void whenRunningOperationIsCancelled() {
+        fileOperationMap.cancel(operation.getPnfsId(), false);
+    }
+
+    private void whenSaveIsCalled() throws IOException {
+        fileOperationMap.setCheckpointFilePath(checkpoint.getAbsolutePath());
+        fileOperationMap.checkpointer.save();
+    }
+
+    private void whenScanIsRun() throws IOException {
+        fileOperationMap.scan();
+    }
+
+    private void whenVerifyIsRun() throws IOException {
+        fileOperationMap.submit(fileOperationMap.getOperation(operation.getPnfsId()));
+    }
+}
diff --git a/modules/dcache-qos/src/test/java/org/dcache/qos/services/verifier/data/PoolInfoChangeHandlerTest.java b/modules/dcache-qos/src/test/java/org/dcache/qos/services/verifier/data/PoolInfoChangeHandlerTest.java
new file mode 100644
index 0000000000..b9a25fa20e
--- /dev/null
+++ b/modules/dcache-qos/src/test/java/org/dcache/qos/services/verifier/data/PoolInfoChangeHandlerTest.java
@@ -0,0 +1,364 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos.services.verifier.data;
+
+import com.google.common.collect.ImmutableList;
+import diskCacheV111.util.CacheException;
+import java.util.NoSuchElementException;
+import java.util.Set;
+import org.dcache.qos.TestBase;
+import org.dcache.qos.TestSynchronousExecutor.Mode;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+
+/**
+ * <p>Tests the application of the pool monitor diffs.  Note that
+ *      for the purposes of these tests, the transition from uninitialized pool
+ *      to initialized is ignored.</p>
+ */
+public class PoolInfoChangeHandlerTest extends TestBase {
+    PoolInfoDiff          diff;
+    Integer               removedPoolIndex;
+
+    @Before
+    public void setUp() throws CacheException {
+        setUpBase();
+        setShortExecutionMode(Mode.RUN);
+        setLongExecutionMode(Mode.NOP);
+        createChangeHandlers();
+        fileOperationMap = mock(FileQoSOperationMap.class);
+        initializeCounters();
+        wireChangeHandlers();
+        setAllPoolsToEnabled();
+    }
+
+    @After
+    public void tearDown() {
+        clearInMemory();
+    }
+
+    @Test
+    public void shouldAddStorageUnitToGroupOnLinkChange() {
+        givenPsuUpdate();
+        whenPsuUpdateContainsNewLinkToQosUnitGroup("new-link");
+        whenPsuUpdateContainsPoolGroupAddedToNewLink("standard-group","new-link");
+        whenPsuChangeHelperIsCalled();
+        assertThatPoolInfoContainsQosUnitsForPoolGroup("standard-group");
+    }
+
+    @Test
+    public void shouldRemoveStorageUnitsFromGroupOnLinkChange() {
+        givenPsuUpdate();
+        whenPsuUpdateNoLongerContainsLink("qos-link");
+        whenPsuChangeHelperIsCalled();
+        assertThatPoolInfoDoesNotContainQosUnitsForPoolGroup("qos-group");
+    }
+
+    @Test
+    public void shouldAddOrphanedPoolToOperationMapWhenAddedToQosGroup() {
+        shouldAddPoolToInfoAndOperationMap();
+        whenPsuUpdateContainsNewPoolForPoolGroup("new-pool", "qos-group");
+        whenPsuChangeHelperIsCalled();
+        assertThatPoolInfoContainsPoolForPoolGroup("new-pool", "qos-group");
+    }
+
+    @Test
+    public void shouldAddPoolToInfoAndOperationMap() {
+        givenPsuUpdate();
+        whenPsuUpdateContainsNewPool("new-pool");
+        whenPsuChangeHelperIsCalled();
+        assertThatPoolInfoContainsPool("new-pool");
+    }
+
+    @Test
+    public void shouldAddPoolToPoolGroupAndScan() {
+        givenPsuUpdate();
+        whenPsuUpdateContainsNewPool("new-pool");
+        whenPsuUpdateContainsNewPoolForPoolGroup("new-pool", "qos-group");
+        whenPsuChangeHelperIsCalled();
+        assertThatPoolInfoContainsPoolForPoolGroup("new-pool", "qos-group");
+    }
+
+    @Test
+    public void shouldAddNonPrimaryPoolToPoolGroupAndScan() {
+        givenPsuUpdate();
+        whenPsuUpdateContainsNewPool("new-pool");
+        whenPsuUpdateContainsNewPoolForPoolGroup("new-pool", "standard-group");
+        whenPsuChangeHelperIsCalled();
+        assertThatPoolInfoContainsPoolForPoolGroup("new-pool","standard-group");
+    }
+
+    @Test
+    public void shouldAddNonQosGroupToMap() {
+        givenPsuUpdate();
+        whenPsuUpdateContainsNewNonQosPoolGroup("new-standard-group");
+        whenPsuChangeHelperIsCalled();
+        assertThatPoolInfoContainsPoolGroup("new-standard-group");
+    }
+
+    @Test
+    public void shouldAddStorageUnitToMap() {
+        givenPsuUpdate();
+        whenPsuUpdateContainsNewStorageUnit("new-default-unit");
+        whenPsuChangeHelperIsCalled();
+        assertThatPoolInfoContainsStorageUnit("new-default-unit");
+    }
+
+    @Test
+    public void shouldAddQosGroupToMap() {
+        givenPsuUpdate();
+        whenPsuUpdateContainsNewQosPoolGroup("new-qos-group");
+        whenPsuChangeHelperIsCalled();
+        assertThatPoolInfoContainsPoolGroup("new-qos-group");
+    }
+
+    @Test
+    public void shouldRemovePoolFromMap() {
+        givenPsuUpdate();
+        whenPsuUpdateNoLongerContainsPool("qos_pool-2");
+        whenPsuChangeHelperIsCalled();
+        assertThatPoolInfoDoesNotContainPool("qos_pool-2");
+        assertThatPoolInfoDoesNotContainPoolForPoolGroup(removedPoolIndex,"qos-group");
+    }
+
+    @Test
+    public void shouldRemovePoolGroupFromMap() {
+        givenPsuUpdate();
+        whenPsuUpdateNoLongerContainsPoolGroup("qos-group");
+        whenPsuChangeHelperIsCalled();
+        /*
+         * This essentially 'orphans' the pools.  Would not be
+         * done without removing the pools first.
+         */
+        assertThatPoolInfoDoesNotContainPoolGroup("qos-group");
+    }
+
+    @Test
+    public void shouldRemoveStorageUnitFromMap() {
+        givenPsuUpdate();
+        whenPsuUpdateNoLongerContainsStorageUnit("qos-0.dcache-devel-test@enstore");
+        whenPsuChangeHelperIsCalled();
+        /*
+         * This essentially 'orphans' files belonging to it.  Would not be
+         * done without removing the files first.
+         */
+        assertThatPoolInfoDoesNotContainStorageUnit("qos-0.dcache-devel-test@enstore");
+    }
+
+    @Test
+    public void shouldCancelOperationsForRemovedPools() {
+        givenPsuUpdate();
+        whenPsuUpdateNoLongerContainsPool("qos_pool-2");
+        whenPsuUpdateNoLongerContainsPool("qos_pool-1");
+        whenPsuChangeHelperIsCalled();
+        verify(fileOperationMap, times(2))
+            .cancelFileOpForPool(any(String.class), eq(false));
+    }
+
+    @Test
+    public void shouldCancelOperationsForPoolRemovedFromGroup() {
+        givenPsuUpdate();
+        whenPsuUpdateNoLongerContainsPoolForPoolGroup("qos_pool-2", "qos-group");
+        whenPsuChangeHelperIsCalled();
+        verify(fileOperationMap, times(1))
+            .cancelFileOpForPool(any(String.class), eq(false));
+    }
+
+    private void assertThatPoolInfoContainsPool(String pool) {
+        assertNotNull(poolInfoMap.getPoolIndex(pool));
+    }
+
+    private void assertThatPoolInfoContainsPoolForPoolGroup(String pool,
+                    String group) {
+        assertTrue(poolInfoMap.getPoolsOfGroup(poolInfoMap.getGroupIndex(group))
+                                                          .contains(poolInfoMap.getPoolIndex(pool)));
+    }
+
+    private void assertThatPoolInfoContainsPoolGroup(String group) {
+        assertNotNull(poolInfoMap.getGroupIndex(group));
+    }
+
+    private void assertThatPoolInfoContainsQosUnitsForPoolGroup(String group) {
+        Set<String> units = poolInfoMap.getStorageUnitsForGroup(group);
+        assertTrue(units.contains("qos-0.dcache-devel-test@enstore"));
+        assertTrue(units.contains("qos-1.dcache-devel-test@enstore"));
+        assertTrue(units.contains("qos-2.dcache-devel-test@enstore"));
+        assertTrue(units.contains("qos-3.dcache-devel-test@enstore"));
+        assertTrue(units.contains("qos-4.dcache-devel-test@enstore"));
+    }
+
+    private void assertThatPoolInfoContainsStorageUnit(String unit) {
+        assertNotNull(poolInfoMap.getUnitIndex(unit));
+    }
+
+    private void assertThatPoolInfoDoesNotContainPool(String pool) {
+        Integer index = null;
+        try {
+            index = poolInfoMap.getPoolIndex(pool);
+        } catch (NoSuchElementException e) {
+            assertNull(index);
+        }
+    }
+
+    private void assertThatPoolInfoDoesNotContainPoolForPoolGroup(Integer pool,
+                    String group) {
+        assertFalse(poolInfoMap.getPoolsOfGroup(poolInfoMap.getGroupIndex(group)).contains(pool));
+    }
+
+    private void assertThatPoolInfoDoesNotContainPoolGroup(String group) {
+        Integer index = null;
+        try {
+            index = poolInfoMap.getGroupIndex(group);
+        } catch (NoSuchElementException e) {
+            assertNull(index);
+        }
+    }
+
+    private void assertThatPoolInfoDoesNotContainQosUnitsForPoolGroup(String group) {
+        Set<String> units = poolInfoMap.getStorageUnitsForGroup(group);
+        assertFalse(units.contains("qos-0.dcache-devel-test@enstore"));
+        assertFalse(units.contains("qos-1.dcache-devel-test@enstore"));
+        assertFalse(units.contains("qos-2.dcache-devel-test@enstore"));
+        assertFalse(units.contains("qos-3.dcache-devel-test@enstore"));
+        assertFalse(units.contains("qos-4.dcache-devel-test@enstore"));
+    }
+
+    private void assertThatPoolInfoDoesNotContainStorageUnit(String unit) {
+        Integer index = null;
+        try {
+            index = poolInfoMap.getUnitIndex(unit);
+        } catch (NoSuchElementException e) {
+            assertNull(index);
+        }
+    }
+
+    private void givenPsuUpdate() {
+        createNewPoolMonitor();
+    }
+
+    private void whenPsuChangeHelperIsCalled() {
+        diff = poolInfoChangeHandler.reloadAndScan(newPoolMonitor);
+    }
+
+    private void whenPsuUpdateContainsNewLinkToQosUnitGroup(String link) {
+        getUpdatedPsu().createLink(link, ImmutableList.of("qos-storage"));
+    }
+
+    private void whenPsuUpdateContainsNewNonQosPoolGroup(String group) {
+        getUpdatedPsu().createPoolGroup(group, false);
+    }
+
+    private void whenPsuUpdateContainsNewPool(String pool) {
+        createNewPool(pool);
+    }
+
+    private void whenPsuUpdateContainsNewPoolForPoolGroup(String pool,
+                    String group) {
+        getUpdatedPsu().addToPoolGroup(group, pool);
+    }
+
+    private void whenPsuUpdateContainsNewQosPoolGroup(String group) {
+        getUpdatedPsu().createPoolGroup(group, true);
+    }
+
+    private void whenPsuUpdateContainsNewStorageUnit(String unit) {
+        getUpdatedPsu().createUnit(unit, false, true, false, false);
+    }
+
+    private void whenPsuUpdateContainsPoolGroupAddedToNewLink(String group,
+                    String link) {
+        getUpdatedPsu().addLink(link, group);
+    }
+
+    private void whenPsuUpdateNoLongerContainsLink(String link) {
+        getUpdatedPsu().removeLink(link);
+    }
+
+    private void whenPsuUpdateNoLongerContainsPool(String pool) {
+        removedPoolIndex = poolInfoMap.getPoolIndex(pool);
+        getUpdatedPsu().removePool(pool);
+    }
+
+    private void whenPsuUpdateNoLongerContainsPoolForPoolGroup(String pool, String group) {
+        getUpdatedPsu().removeFromPoolGroup(group, pool);
+    }
+
+    private void whenPsuUpdateNoLongerContainsPoolGroup(String group) {
+        getUpdatedPsu().getPoolsByPoolGroup(group)
+                       .stream()
+                       .forEach(p->getUpdatedPsu().removeFromPoolGroup(group, p.getName()));
+        getUpdatedPsu().removePoolGroup(group);
+    }
+
+    private void whenPsuUpdateNoLongerContainsStorageUnit(String unit) {
+        getUpdatedPsu().removeUnit(unit, false);
+    }
+}
diff --git a/modules/dcache-qos/src/test/java/org/dcache/qos/services/verifier/data/PoolInfoMapTest.java b/modules/dcache-qos/src/test/java/org/dcache/qos/services/verifier/data/PoolInfoMapTest.java
new file mode 100644
index 0000000000..4f168b0081
--- /dev/null
+++ b/modules/dcache-qos/src/test/java/org/dcache/qos/services/verifier/data/PoolInfoMapTest.java
@@ -0,0 +1,151 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos.services.verifier.data;
+
+import com.google.common.collect.ImmutableList;
+import diskCacheV111.util.CacheException;
+import java.util.Collection;
+import org.dcache.qos.TestBase;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+
+public final class PoolInfoMapTest extends TestBase {
+    Integer group;
+    Collection<String> collection;
+    PoolInfoDiff diff;
+
+    @Before
+    public void setUp() throws CacheException {
+        setUpBase();
+    }
+
+    /*
+     *  Minimal test.  Full testing of the diff/apply routing
+     *  is in PoolMonitorChangeHelperTest.
+     */
+    @Test
+    public void shouldReplaceCurrentPsuWithNewPsu() {
+        givenNewPsuWith("new-pool",
+                        "qos-group");
+        whenCompareIsCalledWithNewPsu();
+        whenApplyIsCalled();
+        assertThatPoolInfoMapContainsPool("new-pool");
+        assertThatPoolBelongsToResilientGroup("new-pool", "qos-group");
+    }
+
+    private void assertThatPoolBelongsToResilientGroup(String pool, String group) {
+        assertEquals(poolInfoMap.getGroupIndex(group),
+                     poolInfoMap.getEffectivePoolGroup(poolInfoMap.getPoolIndex(pool)));
+    }
+
+    private void assertThatPoolInfoMapContainsPool(String pool) {
+        assertNotNull(poolInfoMap.getPoolIndex(pool));
+    }
+
+    private void givenNewPsuWith(String newPool, String poolGroup) {
+        createNewPoolMonitor();
+        createNewPool(newPool);
+        getUpdatedPsu().addToPoolGroup(poolGroup, newPool);
+    }
+
+    private void whenCompareIsCalledWithNewPsu() {
+         diff = poolInfoMap.compare(newPoolMonitor);
+    }
+
+    private void whenApplyIsCalled() {
+        poolInfoMap.apply(diff);
+    }
+
+    @Test
+    public void shouldNotVerifyConstraintsWhenTooManyLocationsAreRequired() {
+        givenResilientGroup();
+        givenAResilientStorageGroupWithRequirementsEqualTo(9, ImmutableList.of("hostname", "rack"));
+        assertThatContraintsSatisfiableIs(false);
+    }
+
+    @Test
+    public void shouldVerifyContraintsForCurrentSettings() {
+        givenResilientGroup();
+        assertThatContraintsSatisfiableIs(true);
+    }
+
+    private void assertThatContraintsSatisfiableIs(boolean satisfiable) {
+        IllegalStateException exception = null;
+        try {
+            poolInfoMap.verifyConstraints(group);
+        } catch (IllegalStateException e) {
+            exception = e;
+        }
+        assertEquals(satisfiable, exception == null);
+    }
+
+    private void givenAResilientStorageGroupWithRequirementsEqualTo(
+                    int required, Collection<String> tags) {
+        poolInfoMap.setUnitConstraints("qos-0.dcache-devel-test@enstore",
+                                       required, tags);
+    }
+
+    private void givenResilientGroup() {
+        group = poolInfoMap.getGroupIndex("qos-group");
+    }
+}
diff --git a/modules/dcache-qos/src/test/java/org/dcache/qos/services/verifier/data/PoolInformationTest.java b/modules/dcache-qos/src/test/java/org/dcache/qos/services/verifier/data/PoolInformationTest.java
new file mode 100644
index 0000000000..ed2929b34f
--- /dev/null
+++ b/modules/dcache-qos/src/test/java/org/dcache/qos/services/verifier/data/PoolInformationTest.java
@@ -0,0 +1,208 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos.services.verifier.data;
+
+import org.junit.Test;
+
+import diskCacheV111.pools.PoolV2Mode;
+
+import static org.junit.Assert.assertEquals;
+
+/**
+ * <p>Tests the mode changes for correct readable and writable classification.</p>
+ */
+public class PoolInformationTest {
+
+    PoolInformation poolInformation;
+    PoolV2Mode poolV2Mode;
+
+    @Test
+    public void shouldBeReadableWhenEnabled() {
+        whenPoolModeIs(PoolV2Mode.ENABLED);
+        assertThatReadableIs(true);
+    }
+
+    @Test
+    public void shouldBeWritableWhenEnabled() {
+        whenPoolModeIs(PoolV2Mode.ENABLED);
+        assertThatWritableIs(true);
+    }
+
+    @Test
+    public void shouldNotBeReadableWhenDisabled() {
+        whenPoolModeIs(PoolV2Mode.DISABLED);
+        assertThatReadableIs(false);
+    }
+
+    @Test
+    public void shouldNotBeWritableWhenDisabled() {
+        whenPoolModeIs(PoolV2Mode.DISABLED);
+        assertThatWritableIs(false);
+    }
+
+    @Test
+    public void shouldNotBeReadableWhenDisabledFetch() {
+        whenPoolModeIs(PoolV2Mode.DISABLED_FETCH);
+        assertThatReadableIs(false);
+    }
+
+    @Test
+    public void shouldBeWritableWhenDisabledFetch() {
+        whenPoolModeIs(PoolV2Mode.DISABLED_FETCH);
+        assertThatWritableIs(true);
+    }
+
+    @Test
+    public void shouldBeReadableWhenDisabledStore() {
+        whenPoolModeIs(PoolV2Mode.DISABLED_STORE);
+        assertThatReadableIs(true);
+    }
+
+    @Test
+    public void shouldBeWritableWhenDisabledStore() {
+        whenPoolModeIs(PoolV2Mode.DISABLED_STORE);
+        assertThatWritableIs(true);
+    }
+
+    @Test
+    public void shouldBeReadableWhenDisabledStage() {
+        whenPoolModeIs(PoolV2Mode.DISABLED_STAGE);
+        assertThatReadableIs(true);
+    }
+
+    @Test
+    public void shouldBeWritableWhenDisabledStage() {
+        whenPoolModeIs(PoolV2Mode.DISABLED_STAGE);
+        assertThatWritableIs(true);
+    }
+
+    @Test
+    public void shouldBeReadableWhenDisabledP2pClient() {
+        whenPoolModeIs(PoolV2Mode.DISABLED_P2P_CLIENT);
+        assertThatReadableIs(true);
+    }
+
+    @Test
+    public void shouldNotBeWritableWhenDisabledP2pClient() {
+        whenPoolModeIs(PoolV2Mode.DISABLED_P2P_CLIENT);
+        assertThatWritableIs(false);
+    }
+
+    @Test
+    public void shouldNotBeReadableWhenDisabledP2pServer() {
+        whenPoolModeIs(PoolV2Mode.DISABLED_P2P_SERVER);
+        assertThatReadableIs(false);
+    }
+
+    @Test
+    public void shouldBeWritableWhenDisabledP2pServer() {
+        whenPoolModeIs(PoolV2Mode.DISABLED_P2P_SERVER);
+        assertThatWritableIs(true);
+    }
+
+    @Test
+    public void shouldNotBeReadableWhenDisabledDead() {
+        whenPoolModeIs(PoolV2Mode.DISABLED_DEAD);
+        assertThatReadableIs(false);
+    }
+
+    @Test
+    public void shouldNotBeWritableWhenDisabledDead() {
+        whenPoolModeIs(PoolV2Mode.DISABLED_DEAD);
+        assertThatWritableIs(false);
+    }
+
+    @Test
+    public void shouldNotBeReadableWhenDisabledStrict() {
+        whenPoolModeIs(PoolV2Mode.DISABLED_STRICT);
+        assertThatReadableIs(false);
+    }
+
+    @Test
+    public void shouldNotBeWritableWhenDisabledStrict() {
+        whenPoolModeIs(PoolV2Mode.DISABLED_STRICT);
+        assertThatWritableIs(false);
+    }
+
+    @Test
+    public void shouldBeReadableWhenDisabledRdOnly() {
+        whenPoolModeIs(PoolV2Mode.DISABLED_RDONLY);
+        assertThatReadableIs(true);
+    }
+
+    @Test
+    public void shouldNotBeWritableWhenDisabledRdOnly() {
+        whenPoolModeIs(PoolV2Mode.DISABLED_RDONLY);
+        assertThatWritableIs(false);
+    }
+
+    private void whenPoolModeIs(int mode) {
+        poolV2Mode = new PoolV2Mode(mode);
+        poolInformation = new PoolInformation("test", -1, poolV2Mode);
+    }
+
+    private void assertThatReadableIs(boolean b) {
+        assertEquals(b, poolInformation.canRead());
+    }
+
+    private void assertThatWritableIs(boolean b) {
+        assertEquals(b, poolInformation.canWrite());
+    }
+}
diff --git a/modules/dcache-qos/src/test/java/org/dcache/qos/services/verifier/util/CacheableLocationExtractorTest.java b/modules/dcache-qos/src/test/java/org/dcache/qos/services/verifier/util/CacheableLocationExtractorTest.java
new file mode 100644
index 0000000000..0dc04fdb3f
--- /dev/null
+++ b/modules/dcache-qos/src/test/java/org/dcache/qos/services/verifier/util/CacheableLocationExtractorTest.java
@@ -0,0 +1,171 @@
+package org.dcache.qos.services.verifier.util;
+
+import com.google.common.collect.ImmutableList;
+import diskCacheV111.util.CacheException;
+import java.util.Collection;
+import java.util.Map;
+import java.util.stream.Collectors;
+import org.dcache.qos.TestBase;
+import org.dcache.vehicles.FileAttributes;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.junit.Assert.assertTrue;
+
+public final class CacheableLocationExtractorTest extends TestBase {
+    private String pool;
+    private Collection<String> onlyOneCopyPer;
+    private FileAttributes attributes;
+    private PoolTagBasedLocationExtractor extractor;
+    private Collection<String> selected;
+    private int currentWeight = Integer.MAX_VALUE;
+
+    @Before
+    public void setUp() throws CacheException {
+        setUpBase();
+    }
+
+    @Test
+    public void selectedPoolsShouldMonotonicallyDescreaseInWeightWhenContinuouslyRemoved()
+                    throws CacheException {
+        givenAFileWithAReplicaOnAllResilientPools();
+        givenTagConstraintsOn("hostname", "rack");
+        givenThePoolInfoForThisFile();
+
+        do {
+            whenTheExtractorIsCalledForTheSetOfLocationsToRemove();
+            andThenAPoolIsRandomlySelectedAndRemoved();
+            assertTrue(theWeightsAreMonotonicallyDecreasing());
+        } while (selected != null && !selected.isEmpty());
+    }
+
+    @Test
+    public void shouldSelectAllPoolsWhenThereAreNoConstraints() throws CacheException {
+        givenAFileWithAReplicaOnAllResilientPools();
+        givenNoTagConstraints();
+        givenThePoolInfoForThisFile();
+
+        whenTheExtractorIsCalledForTheSetOfLocationsToRemove();
+
+        assertTrue(theSelectedPoolsWere(allAvailablePools()));
+    }
+
+    @Test
+    public void shouldSelectPools10And11WhenContraintsIncludeBoth() throws CacheException {
+        givenAFileWithAReplicaOnAllResilientPools();
+        givenTagConstraintsOn("hostname", "rack");
+        givenThePoolInfoForThisFile();
+
+        whenTheExtractorIsCalledForTheSetOfLocationsToRemove();
+
+        assertTrue(theSelectedPoolsWere(pools10And11()));
+    }
+
+    @Test
+    public void shouldSelectPoolsWithValueR0WhenContraintIsRack() throws CacheException {
+        givenAFileWithAReplicaOnAllResilientPools();
+        givenTagConstraintsOn("rack");
+        givenThePoolInfoForThisFile();
+
+        whenTheExtractorIsCalledForTheSetOfLocationsToRemove();
+
+        assertTrue(theSelectedPoolsWere(poolsWithRackValueR0()));
+    }
+
+    @Test
+    public void shouldSelectPoolsWithValuesH0H1WhenContraintIsHost() throws CacheException {
+        givenAFileWithAReplicaOnAllResilientPools();
+        givenTagConstraintsOn("hostname");
+        givenThePoolInfoForThisFile();
+
+        whenTheExtractorIsCalledForTheSetOfLocationsToRemove();
+
+        assertTrue(theSelectedPoolsWere(poolsWithHostValuesH0AndH1()));
+    }
+
+    private Collection<String> allAvailablePools() {
+        return memberPools().stream().map((i) -> poolInfoMap.getPool(i)).collect(
+                        Collectors.toSet());
+    }
+
+    private Collection<Integer> memberPools() {
+        return poolInfoMap.getPoolsOfGroup(poolInfoMap.getEffectivePoolGroup(poolInfoMap.getPoolIndex(pool)));
+    }
+
+    private void andThenAPoolIsRandomlySelectedAndRemoved() {
+        pool = RandomSelectionStrategy.SELECTOR.apply(selected);
+        attributes.getLocations().remove(pool);
+    }
+
+    private void givenAFileWithAReplicaOnAllResilientPools()
+                    throws CacheException {
+        loadFilesWithExcessLocations();
+        attributes = aFileWithAReplicaOnAllResilientPools();
+    }
+
+    private void givenNoTagConstraints() {
+    }
+
+    private void givenTagConstraintsOn(String ... keys) {
+        onlyOneCopyPer = ImmutableList.copyOf(keys);
+    }
+
+    private void givenThePoolInfoForThisFile() {
+        pool = attributes.getLocations().iterator().next();
+        extractor = new PoolTagBasedLocationExtractor(onlyOneCopyPer, poolInfoMap);
+    }
+
+    private Collection<String> pools10And11() {
+        return ImmutableList.of("qos_pool-10", "qos_pool-11");
+    }
+
+    private Collection<String> poolsWithHostValuesH0AndH1() {
+        return getPoolsWithTag("hostname", "h0", "h1");
+    }
+
+    private Collection<String> poolsWithRackValueR0() {
+        return getPoolsWithTag("rack", "r0");
+    }
+
+    private Collection<String> getPoolsWithTag(final String tag, final String ... values) {
+        return memberPools().stream().filter((p) -> {
+            Map<String, String> tagMap = poolInfoMap.getTags(p);
+            if (tagMap.isEmpty()) {
+                return false;
+            }
+            String tagValue = tagMap.get(tag);
+            for (String v : values) {
+                if (v.equals(tagValue)) {
+                    return true;
+                }
+            }
+            return false;
+        }).map((i) -> poolInfoMap.getPool(i)).collect(Collectors.toSet());
+    }
+
+    private boolean theSelectedPoolsWere(Collection<String> pools) {
+        for (String pool : pools) {
+            if (!selected.contains(pool)) {
+                return false;
+            }
+        }
+
+        for (String pool : selected) {
+            if (!pools.contains(pool)) {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    private boolean theWeightsAreMonotonicallyDecreasing() {
+        int last = currentWeight;
+        currentWeight = extractor.getLastComputedMaximum();
+        return currentWeight <= last;
+    }
+
+    private void whenTheExtractorIsCalledForTheSetOfLocationsToRemove() {
+        selected = extractor.getCandidateLocations(attributes.getLocations());
+    }
+}
diff --git a/modules/dcache-qos/src/test/java/org/dcache/qos/services/verifier/util/CopyLocationExtractorTest.java b/modules/dcache-qos/src/test/java/org/dcache/qos/services/verifier/util/CopyLocationExtractorTest.java
new file mode 100644
index 0000000000..a5ae89d1a5
--- /dev/null
+++ b/modules/dcache-qos/src/test/java/org/dcache/qos/services/verifier/util/CopyLocationExtractorTest.java
@@ -0,0 +1,363 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos.services.verifier.util;
+
+import diskCacheV111.poolManager.StorageUnit;
+import diskCacheV111.util.CacheException;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Map;
+import java.util.stream.Collectors;
+import org.dcache.qos.TestBase;
+import org.dcache.qos.services.verifier.data.StorageUnitConstraints;
+import org.dcache.vehicles.FileAttributes;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.junit.Assert.assertTrue;
+
+public final class CopyLocationExtractorTest extends TestBase {
+    private String pool;
+    private FileAttributes attributes;
+    private StorageUnit unit;
+    private Collection<String> selected;
+    private AbstractLocationExtractor extractor;
+
+    @Before
+    public void setUp() throws CacheException {
+        setUpBase();
+    }
+
+    @Test
+    public void shouldChooseAnyPoolWhenSourceWithBothConstraintsOnPoolWithNoTags()
+                    throws CacheException {
+        givenNewFilesOnPoolsWithNoTags();
+        givenAReplicaOnlineFileWithBothTags();
+        givenTheSourceAndConstraintsOfThisFile();
+
+        whenTheExtractorIsCalledForTheNextSetOfLocations();
+
+        assertTrue(theSelectedPoolsWere(allAvailablePools()));
+    }
+
+    @Test
+    public void shouldChooseAnyPoolWhenSourceWithHostConstraintOnPoolWithNoTags()
+                    throws CacheException {
+        givenNewFilesOnPoolsWithNoTags();
+        givenAReplicaOnlineFileWithHostTag();
+        givenTheSourceAndConstraintsOfThisFile();
+
+        whenTheExtractorIsCalledForTheNextSetOfLocations();
+
+        assertTrue(theSelectedPoolsWere(allAvailablePools()));
+    }
+
+    @Test
+    public void shouldChooseAnyPoolWhenSourceWithNoConstraintsOnPoolWithBothTags()
+                    throws CacheException {
+        givenNewFilesOnPoolsWithHostAndRackTags();
+        givenAReplicaOnlineFileWithNoTags();
+        givenTheSourceAndConstraintsOfThisFile();
+
+        whenTheExtractorIsCalledForTheNextSetOfLocations();
+
+        assertTrue(theSelectedPoolsWere(allAvailablePools()));
+    }
+
+    @Test
+    public void shouldChooseAnyPoolWhenSourceWithNoConstraintsOnPoolWithHostTag()
+                    throws CacheException {
+        givenNewFilesOnPoolsWithHostTags();
+        givenAReplicaOnlineFileWithNoTags();
+        givenTheSourceAndConstraintsOfThisFile();
+
+        whenTheExtractorIsCalledForTheNextSetOfLocations();
+
+        assertTrue(theSelectedPoolsWere(allAvailablePools()));
+    }
+
+    @Test
+    public void shouldChooseAnyPoolWhenSourceWithNoConstraintsOnPoolWithNoTags()
+                    throws CacheException {
+        givenNewFilesOnPoolsWithNoTags();
+        givenAReplicaOnlineFileWithNoTags();
+        givenTheSourceAndConstraintsOfThisFile();
+
+        whenTheExtractorIsCalledForTheNextSetOfLocations();
+
+        assertTrue(theSelectedPoolsWere(allAvailablePools()));
+    }
+
+    @Test
+    public void shouldChooseAnyPoolWhenSourceWithRackConstraintOnPoolWithHostTag()
+                    throws CacheException {
+        givenNewFilesOnPoolsWithHostTags();
+        givenAReplicaOnlineFileWithRackTag();
+        givenTheSourceAndConstraintsOfThisFile();
+
+        whenTheExtractorIsCalledForTheNextSetOfLocations();
+
+        assertTrue(theSelectedPoolsWere(allAvailablePools()));
+    }
+
+    @Test
+    public void shouldChooseAnyPoolWhenSourceWithRackConstraintOnPoolWithNoTags()
+                    throws CacheException {
+        givenNewFilesOnPoolsWithNoTags();
+        givenAReplicaOnlineFileWithRackTag();
+        givenTheSourceAndConstraintsOfThisFile();
+
+        whenTheExtractorIsCalledForTheNextSetOfLocations();
+
+        assertTrue(theSelectedPoolsWere(allAvailablePools()));
+    }
+
+    @Test
+    public void shouldChoosePoolOnDifferentHostAndRackWhenSourceWithBothConstraintsOnPoolWithBothTags()
+                    throws CacheException {
+        givenNewFilesOnPoolsWithHostAndRackTags();
+        givenAReplicaOnlineFileWithBothTags();
+        givenTheSourceAndConstraintsOfThisFile();
+
+        whenTheExtractorIsCalledForTheNextSetOfLocations();
+
+        assertTrue(theSelectedPoolsWere(
+                        allPoolsNotOnSameHostAndRackAsSource()));
+    }
+
+    @Test
+    public void shouldChoosePoolOnDifferentHostWhenSourceWithBothConstraintsOnPoolWithHostTag()
+                    throws CacheException {
+        givenNewFilesOnPoolsWithHostTags();
+        givenAReplicaOnlineFileWithBothTags();
+        givenTheSourceAndConstraintsOfThisFile();
+
+        whenTheExtractorIsCalledForTheNextSetOfLocations();
+
+        assertTrue(theSelectedPoolsWere(allPoolsNotOnSameHostAsSource()));
+    }
+
+    @Test
+    public void shouldChoosePoolOnDifferentHostWhenSourceWithHostConstraintOnPoolWithBothTags()
+                    throws CacheException {
+        givenNewFilesOnPoolsWithHostAndRackTags();
+        givenAReplicaOnlineFileWithHostTag();
+        givenTheSourceAndConstraintsOfThisFile();
+
+        whenTheExtractorIsCalledForTheNextSetOfLocations();
+
+        assertTrue(theSelectedPoolsWere(allPoolsNotOnSameHostAsSource()));
+    }
+
+    @Test
+    public void shouldChoosePoolOnDifferentHostWhenSourceWithHostConstraintOnPoolWithHostTag()
+                    throws CacheException {
+        givenNewFilesOnPoolsWithHostTags();
+        givenAReplicaOnlineFileWithHostTag();
+        givenTheSourceAndConstraintsOfThisFile();
+
+        whenTheExtractorIsCalledForTheNextSetOfLocations();
+
+        assertTrue(theSelectedPoolsWere(allPoolsNotOnSameHostAsSource()));
+    }
+
+    @Test
+    public void shouldChoosePoolOnDifferentRackWhenSourceWithRackConstraintOnPoolWithBothTags()
+                    throws CacheException {
+        givenNewFilesOnPoolsWithHostAndRackTags();
+        givenAReplicaOnlineFileWithRackTag();
+        givenTheSourceAndConstraintsOfThisFile();
+
+        whenTheExtractorIsCalledForTheNextSetOfLocations();
+
+        assertTrue(theSelectedPoolsWere(allPoolsNotOnSameRackAsSource()));
+    }
+
+    @Test
+    public void shouldNotFindAnyAvailablePoolIfFileIsOverconstrained()
+                    throws CacheException {
+        givenFilesWithExcessLocations();
+        givenAReplicaOnlineFileWithBothTags();
+        givenTheSourceAndConstraintsOfThisFile();
+        givenAllTaglessPoolsAreOffline();
+        offlinePools("qos_pool-9");
+
+        whenTheExtractorIsCalledForTheNextSetOfLocations();
+
+        assertTrue(theSelectedPoolsWere(noneAvailable()));
+    }
+
+    private Collection<String> allAvailablePools() {
+        return memberPools().stream()
+                            .map(poolInfoMap::getPool)
+                            .filter(poolInfoMap::isEnabled)
+                            .collect(Collectors.toSet());
+    }
+
+    private Collection<String> allPoolsNotOnSameHostAndRackAsSource() {
+        return filterPools("hostname", "rack");
+    }
+
+    private Collection<String> allPoolsNotOnSameHostAsSource() {
+        return filterPools("hostname");
+    }
+
+    private Collection<String> allPoolsNotOnSameRackAsSource() {
+        return filterPools("rack");
+    }
+
+    private Collection<String> filterPools(String... constraints) {
+        Map<String, String> sourceTags = poolInfoMap.getTags(
+                        poolInfoMap.getPoolIndex(pool));
+        return memberPools().stream().filter((p) -> {
+            Map<String, String> tags = poolInfoMap.getTags(p);
+
+            if (tags.isEmpty()) {
+                return true;
+            }
+
+            for (String key : constraints) {
+                if (tags.containsKey(key) && sourceTags.containsKey(key)
+                                && tags.get(key).equals(sourceTags.get(key))) {
+                    return false;
+                }
+            }
+
+            return true;
+        }).map((i) -> poolInfoMap.getPool(i)).collect(Collectors.toSet());
+    }
+
+    private void givenAReplicaOnlineFileWithBothTags() throws CacheException {
+        attributes = aReplicaOnlineFileWithBothTags();
+    }
+
+    private void givenAReplicaOnlineFileWithHostTag() throws CacheException {
+        attributes = aReplicaOnlineFileWithHostTag();
+    }
+
+    private void givenAReplicaOnlineFileWithNoTags() throws CacheException {
+        attributes = aReplicaOnlineFileWithNoTags();
+    }
+
+    private void givenAReplicaOnlineFileWithRackTag() throws CacheException {
+        attributes = aReplicaOnlineFileWithRackTag();
+    }
+
+    private void givenAllTaglessPoolsAreOffline() {
+        Collection<String> offline = memberPools().stream().filter(
+                        (pool) -> poolInfoMap.getTags(pool).isEmpty()).map(
+                        (i) -> poolInfoMap.getPool(i)).collect(
+                        Collectors.toList());
+        offlinePools(offline.toArray(String[]::new));
+    }
+
+    private void givenFilesWithExcessLocations() {
+        loadFilesWithExcessLocations();
+    }
+
+    private void givenNewFilesOnPoolsWithHostAndRackTags() {
+        loadNewFilesOnPoolsWithHostAndRackTags();
+    }
+
+    private void givenNewFilesOnPoolsWithHostTags() {
+        loadNewFilesOnPoolsWithHostTags();
+    }
+
+    private void givenNewFilesOnPoolsWithNoTags() {
+        loadNewFilesOnPoolsWithNoTags();
+    }
+
+    private void givenTheSourceAndConstraintsOfThisFile() {
+        pool = attributes.getLocations().iterator().next();
+        String storageGroupName = attributes.getStorageClass() + "@" + attributes.getHsm();
+        StorageUnitConstraints constraints = poolInfoMap.getConstraints(storageGroupName);
+        extractor = poolInfoMap.getLocationExtractor(constraints.getOneCopyPer());
+    }
+
+    private Collection<Integer> memberPools() {
+        return poolInfoMap.getPoolsOfGroup(poolInfoMap.getEffectivePoolGroup(poolInfoMap.getPoolIndex(pool)));
+    }
+
+    private Collection<String> noneAvailable() {
+        return Collections.EMPTY_SET;
+    }
+
+    private boolean theSelectedPoolsWere(Collection<String> pools) {
+        for (String pool : pools) {
+            if (!selected.contains(pool)) {
+                return false;
+            }
+        }
+
+        for (String pool : selected) {
+            if (!pools.contains(pool)) {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    private void whenTheExtractorIsCalledForTheNextSetOfLocations() {
+        attributes.getLocations().stream().forEach(
+                        (p) -> extractor.addSeenTagsFor(p));
+        selected = extractor.getCandidateLocations(allAvailablePools());
+    }
+}
diff --git a/modules/dcache-qos/src/test/java/org/dcache/qos/services/verifier/util/LocationSelectorTest.java b/modules/dcache-qos/src/test/java/org/dcache/qos/services/verifier/util/LocationSelectorTest.java
new file mode 100644
index 0000000000..dddd29fd3c
--- /dev/null
+++ b/modules/dcache-qos/src/test/java/org/dcache/qos/services/verifier/util/LocationSelectorTest.java
@@ -0,0 +1,257 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos.services.verifier.util;
+
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Sets;
+import diskCacheV111.pools.PoolV2Mode;
+import diskCacheV111.util.CacheException;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Set;
+import java.util.stream.Collectors;
+import org.dcache.qos.TestBase;
+import org.dcache.qos.util.ExceptionMessage;
+import org.dcache.vehicles.FileAttributes;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+
+public final class LocationSelectorTest extends TestBase {
+    String pool;
+    String selected;
+    Integer group;
+    FileAttributes attributes;
+    Collection<String> collection;
+    Set<String> readable;
+    Set<String> available;
+    Set<Integer> tried;
+
+    @Before
+    public void setUp() throws CacheException {
+        setUpBase();
+    }
+
+    @Test
+    public void shouldFailToSelectAWritableCopyLocation() throws Exception {
+        givenAFileWithSeveralLocations();
+        givenTheSetOfOnlinePoolsForTheGroup();
+        givenThisManyOtherPoolsInTheGroupAreDown(12);
+        whenCopyTargetIsSelected();
+        assertNull(selected);
+    }
+
+    @Test
+    public void shouldFailToSelectAWritableRemoveLocation() throws Exception {
+        givenAFileWithSeveralLocations();
+        givenThisManyLocationsAreOffline(attributes.getLocations().size());
+        whenRemoveTargetIsSelected();
+        assertNull(selected);
+    }
+
+    @Test
+    public void shouldReturnMultipleLocations() throws CacheException {
+        givenAFileWithSeveralLocations();
+        whenReadableMemberLocationsAreRequested();
+        assertTrue(1 < collection.size());
+        assertTrue(collection.contains(pool));
+    }
+
+    @Test
+    public void shouldReturnNoLocation() throws CacheException {
+        givenAFileOnlyOnOnePool();
+        givenLocationGoesOffline(pool);
+        whenReadableMemberLocationsAreRequested();
+        assertEquals(0, collection.size());
+    }
+
+    @Test
+    public void shouldReturnOnlyCurrentLocation() throws CacheException {
+        givenAFileOnlyOnOnePool();
+        whenReadableMemberLocationsAreRequested();
+        assertEquals(1, collection.size());
+        assertEquals(pool, collection.iterator().next());
+    }
+
+    @Test
+    public void shouldSelectARandomGroupMemberWhichHasNotBeenTried()
+                    throws Exception {
+        givenAFileOnlyOnOnePool();
+        givenTheSetOfOnlinePoolsForTheGroup();
+        givenTheCurrentLocationHasBeenTried();
+        whenSourceIsSelected();
+        assertNotNull(selected);
+        assertFalse(pool.equals(selected));
+    }
+
+    @Test
+    public void shouldSelectAWritableCopyLocation() throws Exception {
+        givenAFileWithSeveralLocations();
+        givenTheSetOfOnlinePoolsForTheGroup();
+        givenThisManyOtherPoolsInTheGroupAreDown(11);
+        whenCopyTargetIsSelected();
+        assertNotNull(selected);
+        assertFalse(attributes.getLocations().contains(selected));
+        assertTrue(available.contains(selected));
+    }
+
+    @Test
+    public void shouldSelectAWritableRemoveLocation() throws Exception {
+        givenAFileWithSeveralLocations();
+        givenThisManyLocationsAreOffline(attributes.getLocations().size() - 1);
+        whenRemoveTargetIsSelected();
+        assertNotNull(selected);
+        assertTrue(attributes.getLocations().contains(selected));
+        assertTrue(poolInfoMap.isEnabled(selected));
+    }
+
+    private void givenAFileOnlyOnOnePool() throws CacheException {
+        loadNewFilesOnPoolsWithNoTags();
+        attributes = aReplicaOnlineFileWithNoTags();
+        setInfoFromAttributes();
+    }
+
+    private void givenAFileWithSeveralLocations() throws CacheException {
+        loadFilesWithRequiredLocations();
+        attributes = aReplicaOnlineFileWithNoTags();
+        setInfoFromAttributes();
+    }
+
+    private void givenLocationGoesOffline(String location)
+                    throws CacheException {
+        poolInfoMap.updatePoolMode(location, new PoolV2Mode(PoolV2Mode.DISABLED_STRICT));
+    }
+
+    private void givenTheCurrentLocationHasBeenTried() {
+        tried = ImmutableSet.of(poolInfoMap.getPoolIndex(pool));
+    }
+
+    private void givenTheSetOfOnlinePoolsForTheGroup() {
+        readable = poolInfoMap.getPoolsOfGroup(group).stream()
+                        .map((i) -> poolInfoMap.getPool(i))
+                        .filter((p) -> poolInfoMap.isEnabled(p))
+                        .collect(Collectors.toSet());
+    }
+
+    private void givenThisManyLocationsAreOffline(int offline)
+                    throws CacheException {
+        collection = attributes.getLocations();
+        int count = 0;
+
+        for (String location : collection) {
+            givenLocationGoesOffline(location);
+            if (++count >= offline) {
+                break;
+            }
+        }
+    }
+
+    private void givenThisManyOtherPoolsInTheGroupAreDown(int down)
+                    throws CacheException {
+        available = Sets.difference(readable,
+                        ImmutableSet.copyOf(attributes.getLocations()));
+        down = Math.min(available.size(), down);
+        int count = 0;
+        for (String pool : available) {
+            givenLocationGoesOffline(pool);
+            if (++count >= down) {
+                break;
+            }
+        }
+    }
+
+    private void setInfoFromAttributes() {
+        pool = attributes.getLocations().iterator().next();
+        group = poolInfoMap.getEffectivePoolGroup(poolInfoMap.getPoolIndex(pool));
+    }
+
+    private void whenCopyTargetIsSelected() {
+        try {
+            selected = locationSelector.selectCopyTarget(group,
+                                                         attributes.getLocations(),
+                                                         Collections.EMPTY_SET,
+                                                         Collections.EMPTY_SET);
+        } catch (Exception e) {
+            LOGGER.error("{}", new ExceptionMessage(e));
+        }
+    }
+
+    private void whenReadableMemberLocationsAreRequested() {
+        collection = poolInfoMap.getMemberLocations(group, attributes.getLocations());
+        collection = poolInfoMap.getReadableLocations(collection);
+    }
+
+    private void whenRemoveTargetIsSelected() {
+        try {
+            selected = locationSelector.selectTargetToCache(collection, null);
+        } catch (Exception e) {
+            LOGGER.error("{}", new ExceptionMessage(e));
+        }
+    }
+
+    private void whenSourceIsSelected() throws Exception {
+        selected = locationSelector.selectSource(readable, tried);
+    }
+}
diff --git a/modules/dcache-qos/src/test/java/org/dcache/qos/services/verifier/util/PoolManagerInfoExtractorTest.java b/modules/dcache-qos/src/test/java/org/dcache/qos/services/verifier/util/PoolManagerInfoExtractorTest.java
new file mode 100644
index 0000000000..9cbe8ef27e
--- /dev/null
+++ b/modules/dcache-qos/src/test/java/org/dcache/qos/services/verifier/util/PoolManagerInfoExtractorTest.java
@@ -0,0 +1,116 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos.services.verifier.util;
+
+import diskCacheV111.poolManager.StorageUnitInfoExtractor;
+import diskCacheV111.util.CacheException;
+import org.dcache.qos.TestBase;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+public final class PoolManagerInfoExtractorTest extends TestBase {
+
+    @Before
+    public void setUp() throws CacheException {
+        setUpBase();
+    }
+
+    @Test
+    public void shouldAssertThatPoolGroupHasResilientStorageUnit() {
+        assertTrue(StorageUnitInfoExtractor.hasResilientStorageUnit(
+                        "qos-group", testSelectionUnit));
+    }
+
+    @Test
+    public void shouldNotAssertThatPoolGroupHasResilientStorageUnit() {
+        assertFalse(StorageUnitInfoExtractor.hasResilientStorageUnit(
+                        "standard-group", testSelectionUnit));
+    }
+
+    @Test
+    public void shouldReturnResilientPoolGroupForStorageUnit() {
+        assertEquals("qos-group",
+                        StorageUnitInfoExtractor.getResilientGroupsFor(
+                                        "qos-1.dcache-devel-test@enstore",
+                                        testSelectionUnit).iterator().next());
+    }
+
+    @Test
+    public void shouldReturnNoResilientPoolGroupForStorageUnit() {
+        assertEquals(0, StorageUnitInfoExtractor.getResilientGroupsFor(
+                        "standard.dcache-devel-test@enstore", testSelectionUnit).size());
+    }
+
+    @Test
+    public void shouldReturnSixStorageUnitsForResilientPoolGroup() {
+        assertEquals(6, StorageUnitInfoExtractor.getStorageUnitsInGroup(
+                        "qos-group", testSelectionUnit).size());
+    }
+
+    @Test
+    public void shouldReturnOneStorageUnitForNonResilientPoolGroup() {
+        assertEquals(1, StorageUnitInfoExtractor.getStorageUnitsInGroup(
+                        "standard-group", testSelectionUnit).size());
+    }
+}
diff --git a/modules/dcache-qos/src/test/java/org/dcache/qos/util/MessageGuardTest.java b/modules/dcache-qos/src/test/java/org/dcache/qos/util/MessageGuardTest.java
new file mode 100644
index 0000000000..a404544ad6
--- /dev/null
+++ b/modules/dcache-qos/src/test/java/org/dcache/qos/util/MessageGuardTest.java
@@ -0,0 +1,161 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos.util;
+
+import diskCacheV111.vehicles.Message;
+import dmg.cells.nucleus.CDC;
+import dmg.cells.nucleus.CellMessage;
+import dmg.cells.nucleus.CellMessageReceiver;
+import dmg.cells.nucleus.CellPath;
+import java.util.UUID;
+import org.dcache.qos.util.MessageGuard.Status;
+import org.junit.Before;
+import org.junit.Test;
+
+import static junit.framework.TestCase.assertTrue;
+import static org.junit.Assert.assertFalse;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+
+public final class MessageGuardTest {
+    class MessageReceiver implements CellMessageReceiver {
+        void messageArrived(CellMessage msg) {
+            CDC.setMessageContext(msg);
+        }
+    }
+
+    BackloggedMessageHandler backlogHandler;
+    MessageReceiver handler;
+    MessageGuard guard;
+    CellMessage msg;
+    Message internal;
+
+    @Before
+    public void setUp() {
+        guard = new MessageGuard();
+        backlogHandler = mock(BackloggedMessageHandler.class);
+        guard.setBacklogHandler(backlogHandler);
+        handler = new MessageReceiver();
+        msg = new CellMessage();
+        internal = new Message();
+        msg.setMessageObject(internal);
+    }
+
+    @Test
+    public void shouldAcceptMessage() throws Exception {
+        msg.setSession(UUID.randomUUID().toString());
+        msg.getSourcePath().add(new CellPath("Foo", "bar"));
+        givenGuardIsEnabled();
+        handler.messageArrived(msg);
+
+        assertTrue(Status.EXTERNAL == guard.getStatus("test", msg));
+    }
+
+    @Test
+    public void shouldRejectMessage() throws Exception {
+        msg.setSession(MessageGuard.QOS_ID);
+        msg.getSourcePath().add(new CellPath("Foo", "bar"));
+        givenGuardIsEnabled();
+        handler.messageArrived(msg);
+
+        assertFalse(Status.EXTERNAL == guard.getStatus("test", msg));
+    }
+
+    @Test
+    public void shouldSaveMessage() throws Exception {
+        msg.setSession(UUID.randomUUID().toString());
+        msg.getSourcePath().add(new CellPath("Foo", "bar"));
+        handler.messageArrived(msg);
+
+        assertTrue(Status.DISABLED == guard.getStatus("test", msg));
+        verify(backlogHandler).saveToBacklog(internal);
+    }
+
+    @Test
+    public void shouldDropMessage() throws Exception {
+        msg.setSession(UUID.randomUUID().toString());
+        msg.getSourcePath().add(new CellPath("Foo", "bar"));
+        givenGuardIsDisabledWithDropTrue();
+        handler.messageArrived(msg);
+
+        assertTrue(Status.DISABLED == guard.getStatus("test", msg));
+        verify(backlogHandler, never()).saveToBacklog(internal);
+    }
+
+    @Test
+    public void shouldRedeliverMessages() throws Exception {
+        givenGuardIsDisabled();
+        givenGuardIsEnabled();
+        verify(backlogHandler).handleBacklog();
+    }
+
+    private void givenGuardIsDisabled() {
+        guard.disable(false);
+    }
+
+    private void givenGuardIsDisabledWithDropTrue() {
+        guard.disable(true);
+    }
+
+    private void givenGuardIsEnabled() {
+        guard.enable();
+    }
+}
diff --git a/modules/dcache-qos/src/test/java/org/dcache/qos/util/NonReindexableListTest.java b/modules/dcache-qos/src/test/java/org/dcache/qos/util/NonReindexableListTest.java
new file mode 100644
index 0000000000..4dd31c0687
--- /dev/null
+++ b/modules/dcache-qos/src/test/java/org/dcache/qos/util/NonReindexableListTest.java
@@ -0,0 +1,182 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos.util;
+
+import org.junit.Test;
+
+import java.util.List;
+import java.util.NoSuchElementException;
+
+import org.dcache.util.NonReindexableList;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotEquals;
+import static org.junit.Assert.assertNull;
+
+public final class NonReindexableListTest {
+    private List<String> testList;
+
+    @Test
+    public void shouldFailToInsert() {
+        givenListWithNulls();
+        whenListContains("A", "B", "C", "D", "E");
+        assertThatInsertFails(2, "CC");
+    }
+
+    @Test
+    public void shouldFailToModify() {
+        givenListWithNulls();
+        whenListContains("A", "B", "C", "D", "E");
+        assertThatModifyFails(2, "CC");
+    }
+
+    @Test
+    public void shouldReAssignANewIndexToRemovedAndReaddedElement() {
+        givenListWithNulls();
+        whenListContains("A", "B", "C", "D", "E");
+        Integer before = testList.indexOf("B");
+        whenRemoved("B");
+        whenAdded("B");
+        Integer after = testList.indexOf("B");
+        assertNotEquals(before, after);
+    }
+
+    @Test
+    public void shouldMaintainIndicesForRemainingElementsAfterRemoval() {
+        givenListWithNulls();
+        whenListContains("A", "B", "C", "D", "E");
+        Integer before = testList.indexOf("E");
+        whenRemoved("B", "D");
+        Integer after = testList.indexOf("E");
+        assertEquals(before, after);
+    }
+
+    @Test
+    public void shouldReturnNullForRemovedElementWhenListContainsNulls() {
+        givenListWithNulls();
+        whenListContains("A", "B", "C", "D", "E");
+        Integer before = testList.indexOf("B");
+        whenRemoved("B");
+        assertNull(testList.get(before));
+    }
+
+    @Test
+    public void shouldThrowExceptionForRemovedElementWhenListContainsNoNulls() {
+        givenListWithNoNulls();
+        whenListContains("A", "B", "C", "D", "E");
+        Integer before = testList.indexOf("B");
+        whenRemoved("B");
+        assertNoSuchElementExceptionIsThrownOnGet(before);
+    }
+
+    private void assertNoSuchElementExceptionIsThrownOnGet(Integer index) {
+        try {
+            testList.get(index);
+        } catch (Exception e) {
+            assertEquals(e.getClass(), NoSuchElementException.class);
+        }
+    }
+
+    private void assertThatInsertFails(int i, String cc) {
+        try {
+            testList.add(i, cc);
+        } catch (Exception e) {
+            assertEquals(e.getClass(), UnsupportedOperationException.class);
+        }
+    }
+
+    private void assertThatModifyFails(int i, String cc) {
+        try {
+            testList.set(i, cc);
+        } catch (Exception e) {
+            assertEquals(e.getClass(), UnsupportedOperationException.class);
+        }
+    }
+
+    private void givenListWithNoNulls() {
+        NonReindexableList list = new NonReindexableList<>();
+        list.setIncludeNulls(false);
+        testList = list;
+    }
+
+    private void givenListWithNulls() {
+        NonReindexableList list = new NonReindexableList<>();
+        list.setIncludeNulls(true);
+        testList = list;
+    }
+
+    private void whenAdded(String... values) {
+        for (String value : values) {
+            testList.add(value);
+        }
+    }
+
+    private void whenListContains(String... values) {
+        for (String value : values) {
+            testList.add(value);
+        }
+    }
+
+    private void whenRemoved(String... values) {
+        for (String value : values) {
+            testList.remove(value);
+        }
+    }
+}
