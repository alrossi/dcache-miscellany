diff --git a/modules/dcache-qos/src/main/java/org/dcache/qos/local/clients/LocalQoSScannerClient.java b/modules/dcache-qos/src/main/java/org/dcache/qos/local/clients/LocalQoSScannerClient.java
new file mode 100644
index 0000000000..48537661b2
--- /dev/null
+++ b/modules/dcache-qos/src/main/java/org/dcache/qos/local/clients/LocalQoSScannerClient.java
@@ -0,0 +1,86 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos.local.clients;
+
+import org.dcache.qos.listeners.QoSPoolScanResponseListener;
+import org.dcache.qos.services.scanner.handlers.PoolTaskCompletionHandler;
+
+/**
+ *  A pass-through to the pool task completion handler. Use this listener when plugging
+ *  in directly to the scanner service.
+ */
+public final class LocalQoSScannerClient implements QoSPoolScanResponseListener {
+  private PoolTaskCompletionHandler completionHandler;
+
+  @Override
+  public void scanRequestUpdated(String pool, int succeeded, int failed) {
+    for (int p = 0; p < succeeded; ++p) {
+      completionHandler.childTerminated(pool);
+    }
+
+    for (int p = 0; p < failed; ++p) {
+      completionHandler.childTerminatedWithFailure(pool);
+    }
+  }
+
+  public void setCompletionHandler(PoolTaskCompletionHandler completionHandler) {
+    this.completionHandler = completionHandler;
+  }
+}
diff --git a/modules/dcache-qos/src/main/java/org/dcache/qos/remote/receivers/QoSScannerReceiver.java b/modules/dcache-qos/src/main/java/org/dcache/qos/remote/receivers/QoSScannerReceiver.java
new file mode 100644
index 0000000000..9ec722e010
--- /dev/null
+++ b/modules/dcache-qos/src/main/java/org/dcache/qos/remote/receivers/QoSScannerReceiver.java
@@ -0,0 +1,102 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos.remote.receivers;
+
+import dmg.cells.nucleus.CellMessageReceiver;
+import org.dcache.qos.services.scanner.handlers.PoolOperationHandler;
+import org.dcache.qos.util.MessageGuard;
+import org.dcache.qos.util.MessageGuard.Status;
+import org.dcache.qos.vehicles.QoSBatchedVerificationResponseMessage;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ *  Implements message reception for remote scanner service.
+ *  <p/>
+ *  If disabled manually, messages will be dropped.
+ */
+public final class QoSScannerReceiver implements CellMessageReceiver {
+  private static final Logger ACTIVITY_LOGGER = LoggerFactory.getLogger("org.dcache.qos-log");
+
+  private MessageGuard messageGuard;
+  private PoolOperationHandler handler;
+
+  public void messageArrived(QoSBatchedVerificationResponseMessage message) {
+    ACTIVITY_LOGGER.info("Received QoSBatchedVerificationResponseMessage for {}",
+        message.getLocation());
+    if (messageGuard.getStatus("QoSBatchedVerificationResponseMessage", message)
+        == Status.DISABLED) {
+      return;
+    }
+
+    handler.handleBatchedVerificationResponse(message.getLocation(),
+                                              message.getSucceeded(),
+                                              message.getFailed());
+  }
+
+  public void setHandler(PoolOperationHandler handler) {
+    this.handler = handler;
+  }
+
+  public void setMessageGuard(MessageGuard messageGuard) {
+    this.messageGuard = messageGuard;
+  }
+
+}
diff --git a/modules/dcache-qos/src/main/java/org/dcache/qos/services/scanner/admin/QoSScannerAdmin.java b/modules/dcache-qos/src/main/java/org/dcache/qos/services/scanner/admin/QoSScannerAdmin.java
new file mode 100644
index 0000000000..f6395d463c
--- /dev/null
+++ b/modules/dcache-qos/src/main/java/org/dcache/qos/services/scanner/admin/QoSScannerAdmin.java
@@ -0,0 +1,891 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos.services.scanner.admin;
+
+import com.google.common.collect.ImmutableSet;
+import diskCacheV111.util.CacheException;
+import dmg.cells.nucleus.CellCommandListener;
+import dmg.util.command.Argument;
+import dmg.util.command.Command;
+import dmg.util.command.Option;
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileReader;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
+import java.util.UUID;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import java.util.function.Function;
+import java.util.regex.Pattern;
+import java.util.stream.Collectors;
+import org.dcache.qos.services.scanner.data.PoolFilter;
+import org.dcache.qos.services.scanner.data.PoolOperationMap;
+import org.dcache.qos.services.scanner.namespace.NamespaceAccess;
+import org.dcache.qos.services.scanner.util.QoSScannerCounters;
+import org.dcache.qos.util.ExceptionMessage;
+import org.dcache.qos.util.InitializerAwareCommand;
+import org.dcache.qos.util.MapInitializer;
+import org.dcache.qos.util.MessageGuard;
+
+public final class QoSScannerAdmin implements CellCommandListener {
+  static final String CONTAINED_IN        = "contained-in-";
+
+  abstract class PoolOpActivateCommand extends InitializerAwareCommand {
+    @Option(name = "status",
+        valueSpec = "DOWN|READ_ONLY|ENABLED|UNINITIALIZED",
+        usage = "Apply only on operations matching this pool status.")
+    String status;
+
+    @Argument(required = false,
+        usage = "Apply only to pools matching this regular expression.")
+    String pools;
+
+    private final boolean activate;
+
+    PoolOpActivateCommand(MapInitializer initialzer, boolean activate) {
+      super(initializer);
+      this.activate = activate;
+    }
+
+    @Override
+    protected String doCall() {
+      PoolFilter filter = new PoolFilter();
+      filter.setPools(pools);
+      filter.setPoolStatus(status);
+      return String.format("Issued command to %s pool operations.",
+                            poolOperationMap.setIncluded(filter, activate));
+    }
+  }
+
+  class FutureWrapper {
+    final Date timestamp;
+    final UUID key;
+    final String    type;
+    final String    fileName;
+    final Future<?> future;
+
+    FutureWrapper(String type, String fileName, Future<?> future) {
+      timestamp = new Date(System.currentTimeMillis());
+      key = UUID.randomUUID();
+      this.type = type;
+      this.fileName = fileName;
+      this.future = future;
+    }
+
+    boolean isRunning() {
+      return !future.isCancelled() && !future.isDone();
+    }
+
+    public String toString() {
+      String state = future.isCancelled() ? "CANCELLED" :
+          future.isDone() ? "DONE": "RUNNING";
+      return String.format("%-36s %32s %20s, file name: %20s (%s)",
+                            timestamp, key, type, fileName, state);
+    }
+  }
+
+  @Command(name = "async cmd cancel",
+      hint = "cancel running scans/queries",
+      description = "Interrupts the execution of scans or queries launched asynchronously "
+          + "(see async cmd ls).")
+
+  class AsyncCmdCancelCommand extends InitializerAwareCommand {
+    @Argument(usage = "Comma-delimited list of UUIDs for the jobs to cancel, or '*' for all jobs.")
+    String ids;
+
+    AsyncCmdCancelCommand() {
+      super(initializer);
+    }
+
+    @Override
+    protected String doCall() throws Exception {
+      StringBuilder builder = new StringBuilder();
+
+      Set<String> toMatch;
+
+      if (ids.equals("*")) {
+        toMatch = futureMap.keySet();
+      } else {
+        toMatch = Arrays.stream(ids.split(","))
+            .collect(Collectors.toSet());
+      }
+
+      toMatch.forEach(id -> {
+        FutureWrapper wrapper = futureMap.get(id);
+        if (wrapper != null) {
+          if (wrapper.isRunning()) {
+            wrapper.future.cancel(true);
+            builder.append("Cancelled job for ")
+                .append(id).append("\n");
+          } else {
+            builder.append("Job for ")
+                .append(id).append(" already finished")
+                .append("\n");
+          }
+        } else {
+          builder.append("No job for ")
+              .append(id).append("\n");
+        }
+      });
+
+      return builder.toString();
+    }
+  }
+
+  @Command(name = "async cmd cleanup",
+      hint = "remove future entries and/or file",
+      description = "If the job has completed, removes the map entry for the future and/or file.")
+
+  class AsyncCmdCleanupCommand extends InitializerAwareCommand {
+    @Option(name = "entry", usage = "remove entry from map.")
+    boolean entry = true;
+
+    @Option(name = "file", usage = "delete file.")
+    boolean file = false;
+
+    @Argument(usage = "Comma-delimited list of UUIDs for the jobs to clean up, or '*' "
+                      + "for all finished jobs.")
+    String ids;
+
+    AsyncCmdCleanupCommand() { super(initializer); }
+
+    @Override
+    protected String doCall() throws Exception {
+      StringBuilder builder = new StringBuilder();
+
+      Set<String> toMatch;
+
+      if (ids.equals("*")) {
+        // new set to avoid ConcurrentModificationException
+        toMatch = new HashSet<>(futureMap.keySet());
+      } else {
+        toMatch = Arrays.stream(ids.split(",")).collect(Collectors.toSet());
+      }
+
+      toMatch.stream().forEach(id -> {
+        FutureWrapper wrapper = futureMap.get(id);
+        if (wrapper != null) {
+          if (wrapper.isRunning()) {
+            builder.append("job for ").append(id).append(" is still running\n");
+
+          } else {
+            if (entry) {
+              futureMap.remove(id);
+              builder.append("entry for ").append(id).append(" removed\n");
+            }
+
+            if (file) {
+              File file = new File(dataDir, wrapper.fileName);
+              if (!file.exists()) {
+                builder.append("file for ").append(id).append(": ")
+                    .append(wrapper.fileName).append(" NOT FOUND\n");
+              } else {
+                file.delete();
+                builder.append("file for ").append(id).append(": ")
+                    .append(wrapper.fileName).append(" deleted\n");
+              }
+            }
+          }
+        }
+      });
+
+      return builder.toString();
+    }
+  }
+
+  @Command(name = "async cmd ls",
+      hint = "print out a list of running scans/queries",
+      description = "When executing asynchronously either the inaccessible file "
+          + "scan or the contained-in query, a future is stored along with identifying "
+          + "information and path of the file to which the results will be printed; "
+          + "this command lists them all.")
+  class AsyncCmdListCommand extends InitializerAwareCommand {
+
+    AsyncCmdListCommand() { super(initializer); }
+
+    @Override
+    protected String doCall() throws Exception {
+      return String.join("\n",
+          futureMap.values()
+              .stream()
+              .map(FutureWrapper::toString)
+              .sorted()
+              .collect(Collectors.toList()));
+    }
+  }
+
+  @Command(name = "async cmd results",
+      hint = "print to screen asynchronous query/scan results",
+      description = "Reads the file to which the results have been written.  Only 10,000 lines max "
+          + "can be read at one time; if the count exceeds 10,000, use the 'from' option "
+          + "to read the following 10,000.")
+  class AsyncCmdResultsCommand extends InitializerAwareCommand {
+
+    AsyncCmdResultsCommand() { super(initializer); }
+
+    @Option(name = "count",
+        usage = "Print only the number of lines in the file.")
+    Boolean count = false;
+
+    @Option(name = "from",
+        usage = "Starting line index.")
+    Integer from = 0;
+
+    @Argument(usage = "Name of file to read and print.")
+    String fileName;
+
+    @Override
+    protected String doCall() throws Exception {
+      File file = new File(dataDir, fileName);
+      if (!file.exists()) {
+        return fileName + " NOT FOUND.";
+      }
+
+      int i = 0;
+
+      try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
+        if (count) {
+          while (reader.readLine() != null) {
+            ++i;
+          }
+          return "" + i + "\n";
+        } else {
+          for ( ; i < from; ++i) {
+            // skip the first 'from' lines
+            if (null == reader.readLine()) {
+              return "No more lines after " + i;
+            }
+          }
+
+          String line = reader.readLine();
+          if (line == null) {
+            if (from == 0) {
+              return "";
+            }
+            return "No more lines after " + i;
+          }
+
+          StringBuilder builder = new StringBuilder();
+          builder.append(line).append("\n");
+          ++i;
+
+          int end = from + 10000;
+          for ( ; i < end; ++i) {
+            line = reader.readLine();
+            if (line == null) {
+              break;
+            }
+
+            builder.append(line).append("\n");
+          }
+
+          return builder.toString();
+        }
+      } catch (IOException e) {
+        return "Error reading file " + fileName + ": " + e.getMessage();
+      }
+    }
+  }
+
+  @Command(name = "contained in",
+      hint = "count or list pnfsids which have replicas only on the pools in the list",
+      description = "Issues a query to the namespace to determine which files on the "
+          + "indicated pools have all their replicas only on those pools. "
+          + "Results are written to a file in resilience home named '" + CONTAINED_IN
+          + "' + timestamp.  Executed asynchronously. Use 'async cmd ls' to see all running jobs, "
+          + "'async cmd cancel' to cancel, 'async cmd results' to read the results "
+          + "back from the file, and 'async cmd cleanup' to delete the entry and/or file.")
+  class ContainedInCommand extends InitializerAwareCommand {
+    @Argument(usage = "A regular expression for pools to be included in the group.")
+    String poolExpression;
+
+    ContainedInCommand() { super(initializer); }
+
+    @Override
+    protected String doCall() throws Exception {
+      try {
+        StringBuilder builder = new StringBuilder();
+        Pattern pattern = Pattern.compile(poolExpression);
+        List<String> locations
+            = initializer.getAllPools().stream()
+                                       .filter((pool) -> pattern.matcher(pool).find())
+                                       .collect(Collectors.toList());
+        execAsync(locations, builder);
+        return builder.toString();
+      } catch (Exception e) {
+        return new ExceptionMessage(e).toString();
+      }
+    }
+
+    private void execAsync(List<String>locations, StringBuilder builder) {
+      String fileName = CONTAINED_IN + System.currentTimeMillis();
+
+      Function<PrintWriter, Void> function = printWriter -> {
+        try {
+          namespaceAccess.printContainedInFiles(locations, printWriter);
+        } catch (CacheException e) {
+          printWriter.println("error during printContainedInFiles: "
+              + e.toString());
+        } catch (InterruptedException e) {
+          printWriter.println("printContainedInFiles was interrupted.");
+        }
+        return null;
+      };
+
+      handleAsync(fileName, "contained-in scan", function, builder);
+    }
+  }
+
+  @Command(name = "pool ctrl",
+      hint= "control the periodic check of active pools or processing of pool state changes",
+      description = "Activates, deactivates, or resets the periodic checking of active pools; "
+          + "turns all pool operation handling on or off (start/shutdown).")
+  class PoolControlCommand extends InitializerAwareCommand {
+    @Argument(valueSpec = "ON|OFF|START|SHUTDOWN|RESET|RUN|INFO",
+        required = false,
+        usage = "off = turn scanning off; on = turn scanning on; shutdown = turn off all handling; "
+            + "start = turn on all handling; info = show status of watchdog and scan window (default); "
+            + "reset = reset properties; run = interrupt current wait and do a sweep." )
+    String arg = "INFO";
+
+    @Option(name = "window",
+        usage = "With reset mode (one of window|sweep|down|restart). Amount of time which must "
+            + "pass since the last scan of a pool for it to be scanned again.")
+    Integer window;
+
+    @Option(name = "sweep",
+        usage = "With reset mode (one of window|sweep|down|restart). How often a sweep of the pool "
+            + "operations is made.")
+    Integer sweep;
+
+    @Option(name = "down",
+        usage = "With reset mode (one of window|sweep|down|restart). Minimum grace period between "
+            + "reception of a pool down update and scan of  the given pool.")
+    Integer down;
+
+    @Option(name = "restart",
+        usage = "With reset mode (one of window|sweep|down|restart). Minimum grace period between "
+            + "reception of a pool restart update and scan of the given pool.")
+    Integer restart;
+
+    @Option(name = "unit",
+        valueSpec = "SECONDS|MINUTES|HOURS|DAYS",
+        usage = "For the sweep/window/down/restart options.")
+    TimeUnit unit;
+
+    PoolControlCommand() {
+      super(initializer);
+    }
+
+    private ControlMode mode;
+
+    @Override
+    public String call() {
+      mode = ControlMode.valueOf(arg.toUpperCase());
+      if (mode == ControlMode.START) {
+        new Thread(() -> startAll()).start();
+        return "Consumer initialization started.";
+      }
+      return super.call();
+    }
+
+    @Override
+    protected String doCall() {
+      switch (mode) {
+        case SHUTDOWN:
+          shutdownAll();
+          return "Consumer has been shutdown.";
+        case OFF:
+          if (poolOperationMap.isWatchdogOn()) {
+            poolOperationMap.setWatchdog(false);
+            return "Shut down watchdog.";
+          }
+          return "Watchdog already off.";
+        case ON:
+          if (!poolOperationMap.isWatchdogOn()) {
+            poolOperationMap.setWatchdog(true);
+            return poolOperationMap.configSettings();
+          }
+          return "Watchdog already on.";
+        case RUN:
+          if (!poolOperationMap.isWatchdogOn()) {
+            return "Watchdog is off; please turn it on first.";
+          }
+          poolOperationMap.runNow();
+          return "Forced watchdog scan.";
+        case RESET:
+          if (!poolOperationMap.isWatchdogOn()) {
+            return "Watchdog is off; please turn it on first.";
+          }
+
+          if (window != null) {
+            poolOperationMap.setRescanWindow(window);
+            if (unit != null) {
+              poolOperationMap.setRescanWindowUnit(unit);
+            }
+          } else if (sweep != null) {
+            poolOperationMap.setTimeout(sweep);
+            if (unit != null) {
+              poolOperationMap.setTimeoutUnit(unit);
+            }
+          } else if (down != null) {
+            poolOperationMap.setDownGracePeriod(down);
+            if (unit != null) {
+              poolOperationMap.setDownGracePeriodUnit(unit);
+            }
+          } else if (restart != null) {
+            poolOperationMap.setRestartGracePeriod(restart);
+            if (unit != null) {
+              poolOperationMap.setRestartGracePeriodUnit(unit);
+            }
+          }
+
+          poolOperationMap.reset();
+
+          // fall through to return info message
+        case INFO:
+        default:
+          return poolOperationMap.configSettings();
+      }
+    }
+  }
+
+  @Command(name = "pool cancel",
+      hint = "cancel pool operations",
+      description = "Scans the pool table and cancels operations matching the filter parameters; "
+          + "notifies the verifier.")
+  class PoolOpCancelCommand extends InitializerAwareCommand {
+    @Option(name = "status",
+        valueSpec = "DOWN|READ_ONLY|ENABLED",
+        usage = "Cancel only operations on pools matching this pool status.")
+    String status;
+
+    @Option(name = "state",
+        valueSpec = "WAITING|RUNNING",
+        separator = ",",
+        usage = "Cancel only operations on pools matching this comma-delimited set of states.")
+    String[] state;
+
+    @Option(name = "lastUpdateBefore",
+        valueSpec = FORMAT_STRING,
+        usage = "Cancel only operations on pools whose last update was before this date-time.")
+    String lastUpdateBefore;
+
+    @Option(name = "lastUpdateAfter",
+        valueSpec = FORMAT_STRING,
+        usage = "Cancel only operations on pools whose last update was after this date-time.")
+    String lastUpdateAfter;
+
+    @Option(name = "lastScanBefore",
+        valueSpec = FORMAT_STRING,
+        usage = "Cancel only operations on pools whose scan update was before this date-time.")
+    String lastScanBefore;
+
+    @Option(name = "lastScanAfter",
+        valueSpec = FORMAT_STRING,
+        usage = "Cancel only operations on pools whose scan update was after this date-time.")
+    String lastScanAfter;
+
+    @Argument(required = false,
+        valueSpec = "regular expression",
+        usage = "Cancel only operations on pools matching this expression.")
+    String pools;
+
+    PoolOpCancelCommand() {
+      super(initializer);
+    }
+
+    @Override
+    protected String doCall() throws Exception {
+      if (state != null && state.length == 0) {
+        return "Please provide a non-empty string value for state.";
+      }
+
+      PoolFilter filter = new PoolFilter();
+      filter.setPools(pools);
+      filter.setLastScanAfter(getTimestamp(lastScanAfter));
+      filter.setLastScanBefore(getTimestamp(lastScanBefore));
+      filter.setLastUpdateBefore(getTimestamp(lastUpdateBefore));
+      filter.setLastUpdateAfter(getTimestamp(lastUpdateAfter));
+      filter.setPoolStatus(status);
+
+      if (filter.isUndefined() && state == null) {
+        return "Please set at least one option or argument other than 'includeChildren'.";
+      }
+
+      if (state == null) {
+        state = new String[]{"WAITING", "RUNNING"};
+      }
+
+      filter.setState(ImmutableSet.copyOf(state));
+
+      StringBuilder sb = new StringBuilder();
+
+      sb.append("Issued cancel command to ")
+        .append(poolOperationMap.cancel(filter))
+        .append(" pool operations.");
+
+      return sb.toString();
+    }
+  }
+
+  @Command(name = "pool exclude",
+      hint = "exclude pool operations",
+      description = "Scans the pool table and excludes operations for the matching pools; "
+          + "exclusion will cancel any running operations.  The pool will not be included "
+          + "in periodic, forced, or status-change scans; locations on it are still considered "
+          + "valid regarding replica count, but cannot be used as copy sources.")
+  class PoolOpExcludeCommand extends PoolOpActivateCommand {
+    PoolOpExcludeCommand() {
+      super( initializer,false);
+    }
+  }
+
+  @Command(name = "pool include",
+      hint = "include pool operations",
+      description = "Scans the pool table and includes operations for the matching pools; "
+          + "include will only affect pool operations that are currently excluded.")
+  class PoolOpIncludeCommand extends PoolOpActivateCommand {
+    PoolOpIncludeCommand() {
+      super(initializer,true);
+    }
+  }
+
+  @Command(name = "pool ls", hint = "list entries in the pool operation table",
+      description = "Scans the table and returns operations matching the filter parameters.")
+  class PoolOpLsCommand extends InitializerAwareCommand {
+    @Option(name = "status",
+        valueSpec = "DOWN|READ_ONLY|ENABLED|UNINITIALIZED",
+        usage = "List only operations on pools matching this pool status.")
+    String status;
+
+    @Option(name = "state",
+        valueSpec = "IDLE|WAITING|RUNNING|FAILED|CANCELED|EXCLUDED|INACTIVE",
+        separator = ",",
+        usage = "List only operations on pools matching this comma-delimited set of states "
+            + "(default is everything).")
+    String[] state = {"IDLE", "WAITING", "RUNNING", "FAILED", "CANCELED", "EXCLUDED", "INACTIVE"};
+
+    @Option(name = "lastUpdateBefore",
+        valueSpec = FORMAT_STRING,
+        usage = "List only operations on pools whose last update was before this date-time.")
+    String lastUpdateBefore;
+
+    @Option(name = "lastUpdateAfter",
+        valueSpec = FORMAT_STRING,
+        usage = "List only operations on pools whose last update was after this date-time.")
+    String lastUpdateAfter;
+
+    @Option(name = "lastScanBefore",
+        valueSpec = FORMAT_STRING,
+        usage = "List only operations on pools whose scan update was before this date-time.")
+    String lastScanBefore;
+
+    @Option(name = "lastScanAfter",
+        valueSpec = FORMAT_STRING,
+        usage = "List only operations on pools whose scan update was after this date-time.")
+    String lastScanAfter;
+
+    @Argument(required = false,
+        usage = "List only operations on pools matching this regular expression.")
+    String pools;
+
+    PoolOpLsCommand() {
+      super(initializer);
+    }
+
+    @Override
+    protected String doCall() throws Exception {
+      PoolFilter filter = new PoolFilter();
+      filter.setPools(pools);
+      filter.setLastScanAfter(getTimestamp(lastScanAfter));
+      filter.setLastScanBefore(getTimestamp(lastScanBefore));
+      filter.setLastUpdateBefore(getTimestamp(lastUpdateBefore));
+      filter.setLastUpdateAfter(getTimestamp(lastUpdateAfter));
+      filter.setPoolStatus(status);
+      filter.setState(ImmutableSet.copyOf(state));
+
+      return poolOperationMap.list(filter);
+    }
+  }
+
+  @Command(name = "pool details",
+      hint = "list diagnostic information concerning scan activity by pool",
+      description = "Gives statistics on the number of scans, state, files and period.")
+  class PoolDetailsCommand extends InitializerAwareCommand {
+    PoolDetailsCommand() { super(initializer); }
+
+    @Override
+    protected String doCall() throws Exception {
+      StringBuilder builder = new StringBuilder();
+      counters.appendDetails(builder);
+      return builder.toString();
+    }
+  }
+
+  @Command(name = "pool scan",
+      hint = "launch a scan of one or more pools",
+      description = "A check will be initiated to see that the number of replicas on the pool is "
+          + "properly constrained, creating new copies or removing redundant ones "
+          + "as necessary. Note: will not override a currently running operation; matching "
+          + "operations in the waiting state will be guaranteed to run at the next  "
+          + "available slot opening.")
+  class PoolScanCommand extends InitializerAwareCommand {
+    @Option(name = "status",
+        valueSpec = "DOWN|READ_ONLY|ENABLED",
+        usage = "Scan only pools matching this pool status.")
+    String status;
+
+    @Option(name = "lastUpdateBefore",
+        valueSpec = FORMAT_STRING,
+        usage = "Scan only pools whose last update was before this date-time.")
+    String lastUpdateBefore;
+
+    @Option(name = "lastUpdateAfter",
+        valueSpec = FORMAT_STRING,
+        usage = "Scan only pools whose last update was after this date-time.")
+    String lastUpdateAfter;
+
+    @Option(name = "lastScanBefore",
+        valueSpec = FORMAT_STRING,
+        usage = "Scan only pools whose scan update was before this date-time.")
+    String lastScanBefore;
+
+    @Option(name = "lastScanAfter",
+        valueSpec = FORMAT_STRING,
+        usage = "Scan only pools whose scan update was after this date-time.")
+    String lastScanAfter;
+
+    @Argument(usage = "Regular expression for pool(s) on which to conduct the adjustment "
+        + "of all files.")
+    String pools;
+
+    PoolScanCommand() {
+      super(initializer);
+    }
+
+    @Override
+    protected String doCall() throws Exception {
+      PoolFilter filter = new PoolFilter();
+      filter.setPools(pools);
+      filter.setLastScanAfter(getTimestamp(lastScanAfter));
+      filter.setLastScanBefore(getTimestamp(lastScanBefore));
+      filter.setLastUpdateBefore(getTimestamp(lastUpdateBefore));
+      filter.setLastUpdateAfter(getTimestamp(lastUpdateAfter));
+      filter.setPoolStatus(status);
+
+      StringBuilder builder = new StringBuilder("Scans have been issued for:\n");
+      StringBuilder errors = new StringBuilder("ERRORS:\n");
+
+      poolOperationMap.scan(filter, builder, errors);
+
+      if (errors.length() > 8) {
+        builder.append(errors);
+      }
+
+      return builder.toString();
+    }
+  }
+
+  @Command(name = "pool stats", hint = "print diagnostic statistics",
+      description = "Reads in the contents of the file recording periodic statistics.")
+  class PoolStatsCommand extends InitializerAwareCommand {
+    @Option(name = "limit", usage = "Display up to this number of lines (default is 24 * 60).")
+    Integer limit = 24 * 60;
+
+    @Option(name = "order", valueSpec = "asc|desc",
+        usage = "Display lines in ascending (default) or descending order by timestamp.")
+    String order = "asc";
+
+    @Option(name = "enable",
+        usage = "Turn the recording of statistics to file on or off. Recording to file is "
+            + "off by default.")
+    Boolean enable = null;
+
+    PoolStatsCommand() { super(initializer); }
+
+    protected String doCall() throws Exception {
+      if (enable != null) {
+        counters.setToFile(enable);
+        return "Recording to file is now " + (enable ? "on." : "off.");
+      }
+
+      SortOrder order = SortOrder.valueOf(this.order.toUpperCase());
+      StringBuilder builder = new StringBuilder();
+      counters.readStatistics(builder, 0, limit, order == SortOrder.DESC);
+      return builder.toString();
+    }
+  }
+
+  /**
+   * Used for potentially long database queries.  Executing them
+   * synchronously can bind the command interpreter.  We store
+   * the future in case of cancellation or listing.
+   */
+  private final Map<String, FutureWrapper> futureMap = Collections.synchronizedMap(new HashMap<>());
+
+  private MessageGuard messageGuard;
+  private MapInitializer initializer;
+  private PoolOperationMap poolOperationMap;
+  private QoSScannerCounters counters;
+  private NamespaceAccess namespaceAccess;
+  private String dataDir;
+  private ExecutorService executor;
+
+  public void setCounters(QoSScannerCounters counters) {
+    this.counters = counters;
+  }
+
+  public void setDataDir(String dataDir) {
+    this.dataDir = dataDir;
+  }
+
+  public void setExecutor(ExecutorService executor) {
+    this.executor = executor;
+  }
+
+  public void setInitializer(MapInitializer initializer) {
+    this.initializer = initializer;
+  }
+
+  public void setMessageGuard(MessageGuard messageGuard) {
+    this.messageGuard = messageGuard;
+  }
+
+  public void setNamespaceAccess(NamespaceAccess namespaceAccess) {
+    this.namespaceAccess = namespaceAccess;
+  }
+
+  public void setPoolOperationMap(PoolOperationMap poolOperationMap) {
+    this.poolOperationMap = poolOperationMap;
+  }
+
+  private void handleAsync(String fileName,
+      String type,
+      Function<PrintWriter, Void> function,
+      StringBuilder builder) {
+    File file = new File(dataDir, fileName);
+
+    Future<?> future = executor.submit(() -> {
+      try (PrintWriter pw = new PrintWriter(
+          new FileWriter(file, false))) {
+        try {
+          function.apply(pw);
+        } catch (RuntimeException e) {
+          // write out the error to the file
+          e.printStackTrace(pw);
+        }
+      } catch (IOException e) {
+        // let it go ...
+      }
+    });
+
+    FutureWrapper wrapper = new FutureWrapper(type,
+        fileName,
+        future);
+
+    futureMap.put(wrapper.key.toString(), wrapper);
+    builder.append(wrapper).append("\n");
+  }
+
+  private void startAll() {
+    clearAllFutures();
+    initializer.initialize();
+    if (poolOperationMap.isRunning()) {
+      poolOperationMap.shutdown();
+    }
+    poolOperationMap.loadPools();
+    poolOperationMap.initialize();
+    messageGuard.enable();
+  }
+
+  private void shutdownAll() {
+    if (poolOperationMap.isRunning()) {
+      poolOperationMap.shutdown();
+    }
+    clearAllFutures();
+    messageGuard.disable(true);
+    initializer.shutDown();
+  }
+
+  private void clearAllFutures() {
+    synchronized(futureMap) {
+      for (Iterator<Entry<String, FutureWrapper>> it
+          = futureMap.entrySet().iterator(); it.hasNext(); ) {
+        Entry<String, FutureWrapper> entry = it.next();
+        entry.getValue().future.cancel(true);
+        it.remove();
+      }
+    }
+  }
+}
diff --git a/modules/dcache-qos/src/main/java/org/dcache/qos/services/scanner/data/PoolFilter.java b/modules/dcache-qos/src/main/java/org/dcache/qos/services/scanner/data/PoolFilter.java
new file mode 100644
index 0000000000..7515d2e8bc
--- /dev/null
+++ b/modules/dcache-qos/src/main/java/org/dcache/qos/services/scanner/data/PoolFilter.java
@@ -0,0 +1,170 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos.services.scanner.data;
+
+import java.util.Set;
+import java.util.regex.Pattern;
+
+/**
+ *  Simple implementation of PoolMatcher.
+ */
+public final class PoolFilter implements PoolMatcher {
+    private Set<String> state;
+    private Pattern     pools;
+
+    private String poolStatus;
+    private Long   lastUpdateBefore;
+    private Long   lastUpdateAfter;
+    private Long   lastScanBefore;
+    private Long   lastScanAfter;
+
+    public boolean isUndefined() {
+        return          null == state &&
+                        null == pools &&
+                        null == poolStatus &&
+                        null == lastUpdateBefore &&
+                        null == lastUpdateAfter &&
+                        null == lastScanBefore &&
+                        null == lastScanAfter;
+    }
+
+    public boolean matches(String pool, PoolOperation operation) {
+        if (state != null && !state.contains(operation.state.name())) {
+            return false;
+        }
+
+        if (pools != null && !pools.matcher(pool).find()) {
+            return false;
+        }
+
+        if (poolStatus != null &&
+                        !poolStatus.equals(operation.currStatus.name())) {
+            return false;
+        }
+
+        if (lastUpdateBefore != null
+                        && lastUpdateBefore <= operation.lastUpdate) {
+            return false;
+        }
+
+        if (lastUpdateAfter != null
+                        && lastUpdateAfter >= operation.lastUpdate) {
+            return false;
+        }
+
+        if (lastScanBefore != null && lastScanBefore <= operation.lastScan) {
+            return false;
+        }
+
+        if (lastScanAfter != null && lastScanAfter >= operation.lastScan) {
+            return false;
+        }
+
+        return true;
+    }
+
+    public boolean matchesIdle() {
+        return state == null
+                        || state.isEmpty()
+                        || state.contains("IDLE")
+                        || state.contains("FAILED")
+                        || state.contains("CANCELED")
+                        || state.contains("EXCLUDED")
+                        || state.contains("INACTIVE");
+    }
+
+    public boolean matchesRunning() {
+        return state == null || state.isEmpty() || state.contains("RUNNING");
+    }
+
+    public boolean matchesWaiting() {
+        return state == null || state.isEmpty() || state.contains("WAITING");
+    }
+
+    public void setLastScanAfter(Long lastScanAfter) {
+        this.lastScanAfter = lastScanAfter;
+    }
+
+    public void setLastScanBefore(Long lastScanBefore) {
+        this.lastScanBefore = lastScanBefore;
+    }
+
+    public void setLastUpdateAfter(Long lastUpdateAfter) {
+        this.lastUpdateAfter = lastUpdateAfter;
+    }
+
+    public void setLastUpdateBefore(Long lastUpdateBefore) {
+        this.lastUpdateBefore = lastUpdateBefore;
+    }
+
+    public void setPools(String expression) {
+        if (expression != null) {
+            pools = Pattern.compile(expression);
+        }
+    }
+
+    public void setPoolStatus(String poolStatus) {
+        this.poolStatus = poolStatus;
+    }
+
+    public void setState(Set<String> states) {
+        this.state = states;
+    }
+}
diff --git a/modules/dcache-qos/src/main/java/org/dcache/qos/services/scanner/data/PoolMatcher.java b/modules/dcache-qos/src/main/java/org/dcache/qos/services/scanner/data/PoolMatcher.java
new file mode 100644
index 0000000000..cca3bd2617
--- /dev/null
+++ b/modules/dcache-qos/src/main/java/org/dcache/qos/services/scanner/data/PoolMatcher.java
@@ -0,0 +1,87 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos.services.scanner.data;
+
+/**
+ *  Used by admin commands to select operations for cancellation or listing.
+ */
+public interface PoolMatcher {
+    /**
+     *  @param pool associated with the operation
+     *  @param operation containing status and state information
+     *  @return whether the pool, status and state match
+     */
+    boolean matches(String pool, PoolOperation operation);
+
+    /**
+     *  @return true if the matcher should match running operations.
+     */
+    boolean matchesRunning();
+
+    /**
+     *  @return true if the matcher should match waiting operations.
+     */
+    boolean matchesWaiting();
+
+    /**
+     *  @return true if the matcher should match idle operations.
+     */
+    boolean matchesIdle();
+}
diff --git a/modules/dcache-qos/src/main/java/org/dcache/qos/services/scanner/data/PoolOperation.java b/modules/dcache-qos/src/main/java/org/dcache/qos/services/scanner/data/PoolOperation.java
new file mode 100644
index 0000000000..68931ece22
--- /dev/null
+++ b/modules/dcache-qos/src/main/java/org/dcache/qos/services/scanner/data/PoolOperation.java
@@ -0,0 +1,268 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos.services.scanner.data;
+
+import diskCacheV111.util.CacheException;
+import org.dcache.qos.data.FileQoSUpdate;
+import org.dcache.qos.data.PoolQoSStatus;
+import org.dcache.qos.services.scanner.util.PoolScanTask;
+import org.dcache.qos.util.ExceptionMessage;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ *  Object stored in the {@link PoolOperationMap}.
+ */
+public final class PoolOperation {
+    private static final Logger LOGGER    = LoggerFactory.getLogger(PoolOperation.class);
+
+    private static final String TO_STRING = "(completed: %s / %s : %s%%) – "
+                    + "(updated: %s)(scanned: %s)(prev %s)(curr %s)(%s) %s";
+
+    enum State {
+        IDLE,       // NEXT OPERATION READY TO RUN
+        WAITING,    // OPERATION SUBMITTED, AWAITING EXECUTION
+        RUNNING,    // OPERATION IS ACTIVE
+        CANCELED,   // OPERATION WAS TERMINATED BY USER
+        FAILED,     // OPERATION FAILED WITH EXCEPTION
+        EXCLUDED    // POOL EXCLUDED FROM OPERATIONS
+    }
+
+    enum NextAction {
+        NOP,            // REMAIN IN CURRENT QUEUE
+        UP_TO_DOWN,     // PROMOTE TO WAITING
+        DOWN_TO_UP      // CANCEL ANY CURRENT DOWN AND PROMOTE TO WAITING
+    }
+
+    final long initializationGracePeriod;
+
+    boolean                 forceScan;     // Overrides non-handling of restarts
+    long                    lastUpdate;
+    long                    lastScan;
+    String                  group;         // Only set when the psuAction != NONE
+    String                  unit;          // Set when unit has changed, or scan
+                                           // is periodic or initiated by command
+    State                   state;
+    PoolQoSStatus           lastStatus;
+    PoolQoSStatus           currStatus;
+    PoolScanTask            task;
+    CacheException          exception;
+
+    private int children;
+    private int completed;
+    private int failed;
+
+    PoolOperation(long initializationGracePeriod) {
+        this.initializationGracePeriod = initializationGracePeriod;
+        forceScan = false;
+        group = null;
+        unit = null;
+        state = State.IDLE;
+        lastUpdate = System.currentTimeMillis();
+        lastScan = lastUpdate;
+        lastStatus = PoolQoSStatus.UNINITIALIZED;
+        currStatus = PoolQoSStatus.UNINITIALIZED;
+        children = 0;
+        completed = 0;
+        failed = 0;
+    }
+
+    public String toString() {
+        return String.format(TO_STRING,
+                             completed,
+                             children == 0 && completed > 0 ? "?" : children,
+                             getFormattedPercentDone(),
+                             FileQoSUpdate.getFormattedDateFromMillis(lastUpdate),
+                             FileQoSUpdate.getFormattedDateFromMillis(lastScan),
+                             lastStatus, currStatus, state,
+                             exception == null ? getFailedMessage() :
+                                             new ExceptionMessage(exception));
+    }
+
+    public synchronized boolean isExcluded() {
+        return state == State.EXCLUDED;
+    }
+
+    /**
+     *  Provides a transition table for determining what to do when
+     *  a successive status change notification is received.
+     */
+    synchronized NextAction getNextAction(PoolQoSStatus incoming) {
+        if (state == State.EXCLUDED) {
+            currStatus = incoming;
+            return NextAction.NOP;
+        }
+
+        lastStatus = currStatus;
+        currStatus = incoming;
+
+        switch(lastStatus) {
+            case DOWN:
+                switch (currStatus) {
+                    case READ_ONLY:
+                    case ENABLED:
+                        return NextAction.DOWN_TO_UP;
+                    case DOWN:
+                        return NextAction.NOP;
+                }
+            case READ_ONLY:
+            case ENABLED:
+                switch (currStatus) {
+                    case DOWN:
+                        return NextAction.UP_TO_DOWN;
+                    case READ_ONLY:
+                    case ENABLED:
+                        return NextAction.NOP;
+                }
+            case UNINITIALIZED:
+                /*
+                 *  The transition from UNINITIALIZED to another
+                 *  state occurs when the scanner comes on line,
+                 *  whether simultaneously with pool initialization or
+                 *  not.  The probability of pools going down at initialization
+                 *  is low, but it is possible that the scanner could go down
+                 *  and then restart to find a number of pools down.  We
+                 *  therefore have to consider the uninitialized-to-down
+                 *  transition as actionable.  We do so after initialized has not
+                 *  gone to another state for more than the grace period.
+                 *
+                 *  On the other hand, it is less crucial to handle restarts
+                 *  from this initial state, and preferable not to, since the
+                 *  majority of pools will most of the time initialize to a
+                 *  viable readable status, and handling this transition will
+                 *  unnecessarily provoke an immediate system-wide scan.
+                 */
+                if (currStatus == PoolQoSStatus.DOWN) {
+                    if (exceedsGracePeriod()) {
+                        return NextAction.UP_TO_DOWN;
+                    }
+                    currStatus = lastStatus;
+                }
+                /*
+                 *  Fall through to default
+                 */
+            default:
+                return NextAction.NOP;
+        }
+    }
+
+    synchronized void incrementCompleted(boolean failed) {
+        LOGGER.trace("entering incrementCompleted, state {}, failed {}, "
+                                     + "children {}, completed = {}.",
+                     state, failed, children, completed );
+        if (state == State.RUNNING) {
+            ++completed;
+            if (failed) {
+                ++this.failed;
+            }
+        }
+        LOGGER.trace("leaving incrementCompleted, state {}, failed {}, "
+                                     + "children {}, completed = {}.",
+                     state, children, completed );
+    }
+
+    synchronized boolean isComplete() {
+        boolean isComplete = children > 0 && children == completed;
+        LOGGER.trace("isComplete {}, children {}, completed = {}.",
+                     isComplete, children, completed );
+        return isComplete;
+    }
+
+    synchronized int failedChildren() {
+        return failed;
+    }
+
+    synchronized int getCompleted() { return completed; }
+
+    synchronized void resetChildren() {
+        children = 0;
+        completed = 0;
+    }
+
+    synchronized void resetFailed() {
+        failed = 0;
+    }
+
+    synchronized void setChildren(int children) {
+        if (state == State.RUNNING) {
+            this.children = children;
+        }
+    }
+
+    private boolean exceedsGracePeriod() {
+        return System.currentTimeMillis() - lastUpdate >= initializationGracePeriod;
+    }
+
+    private String getFailedMessage() {
+        return failed == 0 ? "" : failed + " file operations failed";
+    }
+
+    private String getFormattedPercentDone() {
+        String percent = children == 0 ?
+                        "?" :
+                        (children == completed ? "100" :
+                        String.format("%.1f", 100 * (double) completed
+                                        / (double) children));
+        if ("100.0".equals(percent)) {
+            return "99.9";
+        }
+        return percent;
+    }
+}
\ No newline at end of file
diff --git a/modules/dcache-qos/src/main/java/org/dcache/qos/services/scanner/data/PoolOperationMap.java b/modules/dcache-qos/src/main/java/org/dcache/qos/services/scanner/data/PoolOperationMap.java
new file mode 100644
index 0000000000..a36f211abc
--- /dev/null
+++ b/modules/dcache-qos/src/main/java/org/dcache/qos/services/scanner/data/PoolOperationMap.java
@@ -0,0 +1,1166 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos.services.scanner.data;
+
+import com.google.common.annotations.VisibleForTesting;
+import com.google.common.collect.ImmutableSet;
+import diskCacheV111.poolManager.PoolSelectionUnit.SelectionPool;
+import diskCacheV111.pools.PoolV2Mode;
+import diskCacheV111.util.CacheException;
+import dmg.cells.nucleus.CellInfoProvider;
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.FileReader;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
+import java.util.TreeMap;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.locks.Condition;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
+import java.util.stream.Collectors;
+import org.dcache.alarms.AlarmMarkerFactory;
+import org.dcache.alarms.PredefinedAlarm;
+import org.dcache.qos.data.PoolQoSStatus;
+import org.dcache.qos.data.QoSMessageType;
+import org.dcache.qos.services.scanner.data.PoolOperation.NextAction;
+import org.dcache.qos.services.scanner.data.PoolOperation.State;
+import org.dcache.qos.services.scanner.handlers.PoolOpChangeHandler;
+import org.dcache.qos.services.scanner.handlers.PoolOperationHandler;
+import org.dcache.qos.services.scanner.util.PoolScanTask;
+import org.dcache.qos.services.scanner.util.QoSScannerCounters;
+import org.dcache.qos.util.ExceptionMessage;
+import org.dcache.util.RunnableModule;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ *  Maintains three queues corresponding to the IDLE, WAITING, and RUNNING
+ *  pool operation states.  The runnable method periodically scans the queues, promoting tasks as
+ *  slots become available, and returning pool operation placeholders to IDLE when the related
+ *  scan completes.
+ *  <p/>
+ *  When a pool status DOWN update is received, a certain grace period
+ *  is observed before actually launching the associated task.
+ *  <p/>
+ *  Subsequent duplicate messages are handled according to a transition
+ *  table (see {@link PoolOperation#getNextAction(PoolQoSStatus)}) which defines whether
+ *  the current operation should be kept, replaced or cancelled (see {@link #update}).
+ *  <p/>
+ *  The map is swept every period.  Idle pools are first checked for expired
+ *  "last scan" timestamps; those eligible are promoted to the waiting queue
+ *  (this is the "watchdog" component of the map). Next, the waiting queue is scanned
+ *  for grace interval expiration; the eligible operations are then promoted to running,
+ *  with a scan task being launched.
+ *  <p/>
+ *  When a scan terminates, the update of the task records whether it
+ *  completed successfully, was cancelled or failed, and the task is
+ *  returned to the idle queue.
+ *  <p/>
+ *  Map provides methods for cancellation of running pool scans, and for
+ *  ad hoc submission of a scan.
+ *  <p/>
+ *  If pools are added or removed from the Pool Selection Unit (via the
+ *  arrival of a PoolMonitor message), the corresponding pool operation
+ *  will be added or removed here.
+ *  <p/>
+ *  Class is not marked final for stubbing/mocking purposes.
+ */
+public class PoolOperationMap extends RunnableModule implements CellInfoProvider {
+  private static final long INITIALIZATION_GRACE_PERIOD = TimeUnit.MINUTES.toMillis(5);
+  private static final Logger LOGGER = LoggerFactory.getLogger(PoolOperationMap.class);
+
+  @VisibleForTesting
+  protected final Map<String, PoolOperation> idle = new LinkedHashMap<>();
+  protected final Map<String, PoolOperation> waiting = new LinkedHashMap<>();
+  protected final Map<String, PoolOperation> running = new HashMap<>();
+
+  private final Lock lock = new ReentrantLock();
+  private final Condition condition = lock.newCondition();
+
+  private final Watchdog watchdog = new Watchdog();
+
+  private long initializationGracePeriod = INITIALIZATION_GRACE_PERIOD;
+  private TimeUnit initializationGracePeriodUnit = TimeUnit.MINUTES;
+
+  private PoolOpChangeHandler changeHandler;
+
+  /*
+   *  A callback.  Note, this creates a cyclical dependency in the spring context.
+   *  The rationale here is that the map controls the terminal logic for scan
+   *  operations on a single thread, and thus needs to notify other components (such
+   *  as the verifier) of termination.  It makes sense that only the
+   *  handler would communicate with the "outside", and that the map should
+   *  be internal to this service.
+   */
+  private PoolOperationHandler handler;
+  private QoSScannerCounters counters;
+
+  private String excludedPoolsFile;
+  private int downGracePeriod;
+  private TimeUnit downGracePeriodUnit;
+  private int restartGracePeriod;
+  private TimeUnit restartGracePeriodUnit;
+  private int maxConcurrentRunning;
+
+  /**
+   *  Read back in from the excluded pools file pool names.
+   *  <p/>
+   *  Deletes the file when done; NOP if there is no file.
+   */
+  private static Collection<String> load(String excludedPoolsFile) {
+    File current = new File(excludedPoolsFile);
+    if (!current.exists()) {
+      return Collections.EMPTY_LIST;
+    }
+
+    Collection<String> excluded = new ArrayList<>();
+
+    try (BufferedReader fr = new BufferedReader(new FileReader(current))) {
+      while (true) {
+        String line = fr.readLine();
+        if (line == null) {
+          break;
+        }
+        excluded.add(line);
+      }
+      current.delete();
+    } catch (FileNotFoundException e) {
+      LOGGER.error("Unable to reload excluded pools file: {}", e.getMessage());
+    } catch (IOException e) {
+      LOGGER.error("Unrecoverable error during reload excluded pools file: {}",
+          e.getMessage());
+    }
+
+    return excluded;
+  }
+
+  /**
+   *  Save the excluded pool names to a file.
+   *  <p/>
+   *  If there already is such a file, it is deleted.
+   *
+   * @param excludedPoolsFile to read
+   * @param operations        the pools which could potentially be in the excluded state.
+   */
+  private static void save(String excludedPoolsFile,
+      Map<String, PoolOperation> operations) {
+    File current = new File(excludedPoolsFile);
+    if (current.exists()) {
+      current.delete();
+    }
+
+    try (PrintWriter fw = new PrintWriter(new FileWriter(excludedPoolsFile, false))) {
+      operations.entrySet().stream().filter((e) -> e.getValue().isExcluded())
+          .forEach((e) -> fw.println(e.getKey()));
+    } catch (FileNotFoundException e) {
+      LOGGER.error("Unable to save excluded pools file: {}", e.getMessage());
+    } catch (IOException e) {
+      LOGGER.error("Unrecoverable error during save of excluded pools file: {}",
+          e.getMessage());
+    }
+  }
+
+  public void saveExcluded() {
+    lock.lock();
+    try {
+      save(excludedPoolsFile, idle);
+    } finally {
+      lock.unlock();
+    }
+  }
+
+  /**
+   *  Called by the admin interface.
+   *  <p/>
+   *  Sets pool operation state to either included or excluded.  If the latter,
+   *  it will not be susceptible to pool scans or status change messages,
+   *  though it will continue to be checked for status when other pools are scanned.
+   *  The arrival of a new mode update will change the state but trigger nothing.
+   *
+   *  @param filter   used only with regular expression for pools.
+   *  @param included whether to include or not.
+   *  @return the number of pool operations which have been included or excluded.
+   */
+  public long setIncluded(PoolMatcher filter, boolean included) {
+    lock.lock();
+
+    Set<String> visited = new HashSet<>();
+
+    try {
+      update(filter, running, included, visited);
+      update(filter, waiting, included, visited);
+      update(filter, idle, included, visited);
+      condition.signalAll();
+    } finally {
+      lock.unlock();
+    }
+
+    return visited.size();
+  }
+
+  public void add(String pool) {
+    lock.lock();
+    try {
+      addPool(pool);
+    } finally {
+      lock.unlock();
+    }
+  }
+
+  /**
+   * Called by the admin interface.
+   *
+   * @return the number of pool operations which have been cancelled.
+   */
+  public long cancel(PoolMatcher filter) {
+    lock.lock();
+
+    long cancelled = 0;
+    try {
+      if (filter.matchesRunning()) {
+        cancelled += cancel(running, filter);
+      }
+
+      if (filter.matchesWaiting()) {
+        cancelled += cancel(waiting, filter);
+      }
+
+      condition.signalAll();
+    } finally {
+      lock.unlock();
+    }
+
+    return cancelled;
+  }
+
+  @VisibleForTesting
+  public PoolQoSStatus getCurrentStatus(String pool) {
+    /*
+     *  Used only in testing, will not return null.
+     */
+    return get(pool).currStatus;
+  }
+
+  @Override
+  public void getInfo(PrintWriter pw) {
+    StringBuilder builder = new StringBuilder();
+    builder.append(configSettings());
+    counters.appendRunning(builder);
+    counters.appendSweep(builder);
+    counters.appendCounts(builder);
+    pw.print(builder.toString());
+  }
+
+  public String configSettings() {
+    return String.format("down grace period %s %s\n"
+            + "restart grace period %s %s\n"
+            + "maximum concurrent operations %s\n"
+            + "scan window set to %s %s\n"
+            + "period set to %s %s\n\n",
+        downGracePeriod,
+        downGracePeriodUnit,
+        restartGracePeriod,
+        restartGracePeriodUnit,
+        maxConcurrentRunning,
+        watchdog.rescanWindow,
+        watchdog.rescanWindowUnit,
+        timeout,
+        timeoutUnit);
+  }
+
+  public int getDownGracePeriod() {
+    return downGracePeriod;
+  }
+
+  public void setDownGracePeriod(int downGracePeriod) {
+    this.downGracePeriod = downGracePeriod;
+  }
+
+  public TimeUnit getDownGracePeriodUnit() {
+    return downGracePeriodUnit;
+  }
+
+  public void setDownGracePeriodUnit(TimeUnit downGracePeriodUnit) {
+    this.downGracePeriodUnit = downGracePeriodUnit;
+  }
+
+  public int getMaxConcurrentRunning() {
+    return maxConcurrentRunning;
+  }
+
+  public void setMaxConcurrentRunning(int maxConcurrentRunning) {
+    this.maxConcurrentRunning = maxConcurrentRunning;
+  }
+
+  public int getRestartGracePeriod() {
+    return restartGracePeriod;
+  }
+
+  public void setRestartGracePeriod(int restartGracePeriod) {
+    this.restartGracePeriod = restartGracePeriod;
+  }
+
+  public TimeUnit getRestartGracePeriodUnit() {
+    return restartGracePeriodUnit;
+  }
+
+  public void setRestartGracePeriodUnit(TimeUnit restartGracePeriodUnit) {
+    this.restartGracePeriodUnit = restartGracePeriodUnit;
+  }
+
+  public int getScanWindow() {
+    return watchdog.rescanWindow;
+  }
+
+  public TimeUnit getScanWindowUnit() {
+    return watchdog.rescanWindowUnit;
+  }
+
+  public String getState(String pool) {
+    PoolOperation operation = get(pool);
+    if (operation == null) {
+      return null;
+    }
+    return operation.state.name();
+  }
+
+  public boolean isWatchdogOn() {
+    return watchdog.running;
+  }
+
+  /**
+   *  Called from admin interface.
+   */
+  public String list(PoolMatcher filter) {
+    StringBuilder builder = new StringBuilder();
+    TreeMap<String, PoolOperation>[] tmp = new TreeMap[]{new TreeMap(),
+        new TreeMap<>(),
+        new TreeMap<>()};
+    lock.lock();
+
+    try {
+      if (filter.matchesRunning()) {
+        tmp[0].putAll(running);
+      }
+
+      if (filter.matchesWaiting()) {
+        tmp[1].putAll(waiting);
+      }
+
+      if (filter.matchesIdle()) {
+        tmp[2].putAll(idle);
+      }
+    } finally {
+      lock.unlock();
+    }
+
+    int total = 0;
+
+    for (TreeMap<String, PoolOperation> map : tmp) {
+      for (Entry<String, PoolOperation> entry : map.entrySet()) {
+        String key = entry.getKey();
+        PoolOperation op = entry.getValue();
+        if (filter.matches(key, op)) {
+          builder.append(key).append("\t").append(op).append("\n");
+          ++total;
+        }
+      }
+    }
+
+    if (total == 0) {
+      builder.setLength(0);
+      builder.append("NO (MATCHING) OPERATIONS.\n");
+    } else {
+      builder.append("TOTAL OPERATIONS:\t\t").append(total).append("\n");
+    }
+
+    return builder.toString();
+  }
+
+  private Set<String> getMappedPools() {
+      Set<String> allPools = new HashSet<>();
+      allPools.addAll(idle.keySet());
+      allPools.addAll(waiting.keySet());
+      allPools.addAll(running.keySet());
+      return allPools;
+  }
+
+  /**
+   *  @return list of pools that have been removed.
+   */
+  public List<String> loadPools() {
+    List<String> removed = new ArrayList<>();
+    lock.lock();
+    try {
+      LOGGER.info("Getting mapped pools.");
+      Set<String> pools;
+      try {
+        pools = changeHandler.getCurrentPsu().getAllDefinedPools(false)
+                             .stream()
+                             .map(SelectionPool::getName)
+                             .collect(Collectors.toSet());
+      } catch (Throwable t) {
+        t.printStackTrace();
+        return Collections.EMPTY_LIST;
+      }
+
+      LOGGER.info("Eliminating old pools from running.");
+      for (String pool : running.keySet()) {
+        if (!pools.contains(pool)) {
+          removed.add(pool);
+        }
+      }
+
+      LOGGER.info("Eliminating old pools from waiting.");
+      for (String pool : waiting.keySet()) {
+        if (!pools.contains(pool)) {
+          removed.add(pool);
+        }
+      }
+
+      LOGGER.info("Eliminating old pools from idle.");
+      for (String pool : idle.keySet()) {
+        if (!pools.contains(pool)) {
+          removed.add(pool);
+        }
+      }
+
+      /*
+       *  Will not overwrite existing placeholder.
+       */
+      LOGGER.info("Adding pools.");
+      pools.stream().forEach(this::addPool);
+
+      /*
+       *  Placeholder for pool-less scan for online custodial files that have
+       *  lost all their replicas.
+       */
+      addPool(QoSMessageType.CHECK_CUSTODIAL_ONLINE.name());
+      PoolOperation operation = get(QoSMessageType.CHECK_CUSTODIAL_ONLINE.name());
+      operation.currStatus = PoolQoSStatus.ENABLED;
+      operation.lastStatus = PoolQoSStatus.ENABLED;
+    } finally {
+      lock.unlock();
+    }
+
+    LOGGER.info("loading excluded pools.");
+    load(excludedPoolsFile).stream().forEach((p) -> {
+      PoolFilter filter = new PoolFilter();
+      filter.setPools(p);
+      setIncluded(filter, false);
+    });
+
+    return removed;
+  }
+
+  public void remove(String pool) {
+    lock.lock();
+    try {
+      if (running.containsKey(pool)) {
+        /*
+         *  NB:  we cannot do anything about child pnfsid tasks here.
+         *  This must be handled by the caller.
+         */
+        running.remove(pool).task.cancel("pool no longer valid");
+      } else if (waiting.remove(pool) == null) {
+        idle.remove(pool);
+      }
+      condition.signalAll();
+    } finally {
+      lock.unlock();
+    }
+  }
+
+  public void reset() {
+    watchdog.resetInterrupt = true;
+    threadInterrupt();
+  }
+
+  @Override
+  public void run() {
+    while (!Thread.interrupted()) {
+      long start = System.currentTimeMillis();
+      lock.lock();
+      try {
+        condition.await(timeout, timeoutUnit);
+      } catch (InterruptedException e) {
+        if (watchdog.resetInterrupt) {
+          LOGGER.trace("Pool watchdog reset, returning to wait: timeout {} {}.", timeout,
+              timeoutUnit);
+          watchdog.resetInterrupt = false;
+          continue;
+        }
+        if (!watchdog.runInterrupt) {
+          LOGGER.trace("Pool watchdog wait was interrupted; exiting.");
+          break;
+        }
+        watchdog.runInterrupt = false;
+      } finally {
+        lock.unlock();
+      }
+
+      if (Thread.interrupted()) {
+        break;
+      }
+
+      LOGGER.trace("Pool watchdog initiating scan.");
+      scan();
+      LOGGER.trace("Pool watchdog scan completed.");
+
+      long end = System.currentTimeMillis();
+      counters.recordSweep(end, end - start);
+    }
+
+    LOGGER.info("Exiting pool operation consumer.");
+    clear();
+
+    LOGGER.info("Pool operation queues cleared.");
+  }
+
+  public void runNow() {
+    watchdog.runInterrupt = true;
+    threadInterrupt();
+  }
+
+  public boolean scan(String pool, String addedTo, String removedFrom,
+                      String storageUnit, PoolV2Mode mode, boolean bypassStateCheck) {
+    lock.lock();
+    try {
+      return doScan(pool, addedTo, removedFrom, storageUnit, mode, bypassStateCheck);
+    } finally {
+      lock.unlock();
+    }
+  }
+
+  /**
+   *  Called by admin command.
+   *  <p/>
+   *  Tries to match the filter against pool operation on the WAITING or IDLE queue.
+   *  As in the auxiliary method called, WAITING operations have their
+   *  forceScan flag set to true, but are not promoted to RUNNING here.
+   *  <p/>
+   *  See documentation at {@link #doScan}.
+   */
+  public void scan(PoolFilter filter, StringBuilder reply, StringBuilder errors) {
+    lock.lock();
+    try {
+      Set<String> pools = getMappedPools();
+      for (String pool : pools) {
+        PoolOperation operation = null;
+        if (waiting.containsKey(pool)) {
+          operation = waiting.get(pool);
+        } else if (idle.containsKey(pool)) {
+          operation = idle.get(pool);
+        }
+
+        if (operation == null) {
+          continue;
+        }
+
+        if (filter.matches(pool, operation)) {
+          try {
+            PoolV2Mode mode = null;
+            SelectionPool selectionPool = changeHandler.getCurrentPsu().getPool(pool);
+            if (selectionPool != null) {
+              mode = changeHandler.getCurrentPsu().getPool(pool).getPoolMode();
+            }
+            if (doScan(pool, null, null, null, mode, true)) {
+              reply.append("\t").append(pool).append("\n");
+            }
+          } catch (IllegalArgumentException e) {
+            errors.append("\t")
+                  .append(String.format("%s, %s", pool, new ExceptionMessage(e))).append("\n");
+          }
+        }
+      }
+    } finally {
+      lock.unlock();
+    }
+  }
+
+  public void setExcludedPoolsFile(String excludedPoolsFile) {
+    this.excludedPoolsFile = excludedPoolsFile;
+  }
+
+  public void setHandler(PoolOperationHandler handler) {
+    this.handler = handler;
+  }
+
+  public void setInitializationGracePeriod(long initializationGracePeriod) {
+    this.initializationGracePeriod = initializationGracePeriod;
+  }
+
+  public void setInitializationGracePeriodUnit(TimeUnit initializationGracePeriodUnit) {
+    this.initializationGracePeriodUnit = initializationGracePeriodUnit;
+  }
+
+  public void setChangeHandler(PoolOpChangeHandler changeHandler) {
+    this.changeHandler = changeHandler;
+  }
+
+  public void setCounters(QoSScannerCounters counters) {
+    this.counters = counters;
+  }
+
+  public void setRescanWindow(int rescanWindow) {
+    watchdog.rescanWindow = rescanWindow;
+  }
+
+  public void setRescanWindowUnit(TimeUnit rescanWindowUnit) {
+    watchdog.rescanWindowUnit = rescanWindowUnit;
+  }
+
+  public void setWatchdog(boolean on) {
+    watchdog.running = on;
+  }
+
+  public boolean isInitialized(PoolV2Mode mode) {
+    return PoolQoSStatus.getStatusFor(mode) != PoolQoSStatus.UNINITIALIZED;
+  }
+
+  /**
+   *  Called upon receipt of a pool status update
+   *  (generated via comparison of PoolMonitor data).
+   */
+  public void updateStatus(String pool, PoolQoSStatus status) {
+    LOGGER.trace("updateStatus for {}: {}.", pool, status);
+    lock.lock();
+    try {
+      Map<String, PoolOperation> queue = running;
+      PoolOperation operation = queue.get(pool);
+
+      if (operation == null) {
+        queue = waiting;
+        operation = queue.get(pool);
+        if (operation == null) {
+          queue = idle;
+          operation = queue.get(pool);
+        }
+      }
+
+      NextAction nextAction = operation.getNextAction(status);
+      if (nextAction == NextAction.NOP) {
+        return;
+      }
+
+      if (operation.state == State.RUNNING) {
+        /*
+         *  NOTE:  there is a need to notify the verifier here,
+         *  so that all waiting file tasks would eventually find the
+         *  available replica count changed and act accordingly.
+         *  The problem is with possible inconsistencies in the child
+         *  counts for the operation, which need to be zeroed out
+         *  in order to guarantee the second operation will complete
+         *  successfully.
+         */
+        operation.task.cancel("pool " + pool + " changed");
+        handler.handlePoolScanCancelled(pool, status);
+      }
+
+      switch (nextAction) {
+        case DOWN_TO_UP:
+        case UP_TO_DOWN:
+          if (operation.state == State.WAITING) {
+            LOGGER.trace("Update, {} already on WAITING queue, {}.",
+                pool, operation);
+            break;
+          }
+
+          LOGGER.trace("Update, putting {} on WAITING queue, {}.",
+              pool, operation);
+          queue.remove(pool);
+          operation.resetChildren();
+          operation.resetFailed();
+          operation.lastUpdate = System.currentTimeMillis();
+          operation.state = State.WAITING;
+          operation.exception = null;
+          operation.task = null;
+          waiting.put(pool, operation);
+          break;
+      }
+      condition.signalAll();
+    } finally {
+      lock.unlock();
+    }
+  }
+
+  public void update(String pool, int children) {
+    update(pool, children, null);
+  }
+
+  public void update(String pool, boolean failed) {
+    LOGGER.debug("Parent {}, child operation has completed.", pool);
+    lock.lock();
+    try {
+      PoolOperation operation = get(pool);
+      operation.incrementCompleted(failed);
+      if (operation.isComplete()) {
+        terminate(pool, operation);
+        condition.signalAll();
+      }
+    } finally {
+      lock.unlock();
+    }
+  }
+
+  public void update(String pool, int children, CacheException exception) {
+    LOGGER.debug("Pool {}, operation update, children {}.", pool, children);
+    lock.lock();
+    try {
+      PoolOperation operation = get(pool);
+      operation.exception = exception;
+      operation.setChildren(children);
+      operation.lastUpdate = System.currentTimeMillis();
+
+      if (children == 0 || operation.isComplete()) {
+        terminate(pool, operation);
+        condition.signalAll();
+      }
+    } finally {
+      lock.unlock();
+    }
+  }
+
+  @VisibleForTesting
+  public void scan() {
+    scanIdle();
+    scanWaiting();
+  }
+
+  private void addPool(String pool) {
+    /*
+     *  Idempotency.  Should not fail.
+     */
+    if (idle.containsKey(pool)
+        || waiting.containsKey(pool)
+        || running.containsKey(pool)) {
+      return;
+    }
+
+    idle.put(pool,
+             new PoolOperation(initializationGracePeriodUnit.toMillis(initializationGracePeriod)));
+  }
+
+  private long cancel(Map<String, PoolOperation> queue, PoolMatcher filter) {
+    AtomicLong canceled = new AtomicLong(0);
+
+    ImmutableSet.copyOf(queue.keySet()).stream().forEach((k) -> {
+      PoolOperation operation = queue.get(k);
+      if (filter.matches(k, operation)) {
+        cancel(k, operation, queue);
+        canceled.incrementAndGet();
+      }
+    });
+
+    return canceled.get();
+  }
+
+  private void cancel(String pool, PoolOperation operation, Map<String, PoolOperation> queue) {
+    if (operation.task != null) {
+      operation.task.cancel("qos admin command");
+      operation.task = null;
+    }
+    counters.incrementCancelled(pool, operation.currStatus, operation.getCompleted(),
+                                operation.forceScan,
+                                System.currentTimeMillis() - operation.lastScan);
+    queue.remove(pool);
+    operation.state = State.CANCELED;
+    reset(pool, operation);
+    handler.handlePoolScanCancelled(pool, operation.currStatus);
+  }
+
+  private void clear() {
+    lock.lock();
+
+    try {
+      running.clear();
+      waiting.clear();
+      idle.clear();
+    } finally {
+      lock.unlock();
+    }
+  }
+
+  /**
+   *  Serves ad hoc scans. Ignores the grace period timeouts (this
+   *  corresponds to setting the <code>forceScan</code> flag on the operation).
+   *  <p/>
+   *  Will <i>not</i> override the behavior of normal task submission by
+   *  cancelling any outstanding task for this pool.
+   *  <p/>
+   *  If indicated, bypasses the transition checking of pool status.
+   *  <p/>
+   *  Called after lock has been acquired.
+   *
+   *  @param bypassStateCheck if false, will not bypass considerations of whether the pool has been
+   *                          previously scanned because it went down.  NOTE: an excluded pool will
+   *                          not be scanned under any circumstances until it is included.
+   *  @return true only if operation has been promoted from idle to waiting.
+   */
+  private boolean doScan(String pool,
+                         String addedTo,
+                         String removedFrom,
+                         String storageUnit,
+                         PoolV2Mode mode,
+                         boolean bypassStateCheck) {
+    LOGGER.debug("doScan called: (pool {})(addedTo {})(removedFrom {})"
+        + "(unit {})(mode {})(bypass check {})",
+        pool, addedTo, removedFrom, storageUnit, mode, bypassStateCheck);
+
+    if (running.containsKey(pool)) {
+      LOGGER.debug("Scan of {} is already in progress", pool);
+      return false;
+    }
+
+    PoolOperation operation;
+
+    if (waiting.containsKey(pool)) {
+      LOGGER.debug("Scan of {} is already in waiting state, setting its "
+          + "force flag to true.", pool);
+      waiting.get(pool).forceScan = true;
+      return false;
+    }
+
+    operation = idle.remove(pool);
+    if (operation == null) {
+      LOGGER.warn("No entry for {} in any queues; "
+          + "pool is not (yet) registered.", pool);
+      return false;
+    }
+
+    if (operation.currStatus == PoolQoSStatus.UNINITIALIZED) {
+      LOGGER.info("Cannot scan {} –– uninitialized", pool);
+      reset(pool, operation);
+      return false;
+    }
+
+    if (operation.state == State.EXCLUDED) {
+      LOGGER.info("Skipping scan {} –– pool is excluded", pool);
+      reset(pool, operation);
+      return false;
+    }
+
+    if (!bypassStateCheck) {
+      if (operation.currStatus == PoolQoSStatus.DOWN &&
+          operation.lastStatus == PoolQoSStatus.DOWN) {
+        LOGGER.info("Skipping scan {} –– pool is down and was already "
+            + "scanned", pool);
+        reset(pool, operation);
+        return false;
+      }
+    }
+
+    if (pool.equals(QoSMessageType.CHECK_CUSTODIAL_ONLINE.name())) {
+      operation.currStatus = PoolQoSStatus.ENABLED;
+    } else {
+      operation.getNextAction(PoolQoSStatus.getStatusFor(mode));
+      operation.group = addedTo != null ? addedTo : removedFrom;
+      operation.unit = storageUnit;
+    }
+
+    operation.forceScan = true;
+    operation.lastUpdate = System.currentTimeMillis();
+    operation.state = State.WAITING;
+    operation.exception = null;
+    operation.resetFailed();
+    operation.task = null;
+    waiting.put(pool, operation);
+    return true;
+  }
+
+  /**
+   *  @return operation, or <code>null</code> if not mapped.
+   */
+  private PoolOperation get(String pool) {
+    PoolOperation operation = running.get(pool);
+
+    if (operation == null) {
+      operation = waiting.get(pool);
+    }
+
+    if (operation == null) {
+      operation = idle.get(pool);
+    }
+
+    return operation;
+  }
+
+  private void reset(String pool, PoolOperation operation) {
+    operation.lastUpdate = System.currentTimeMillis();
+    operation.group = null;
+    operation.unit = null;
+    operation.forceScan = false;
+    operation.resetChildren();
+    if (pool.equals(QoSMessageType.CHECK_CUSTODIAL_ONLINE.name())
+        || changeHandler.getCurrentPsu().getPool(pool) != null) {
+      idle.put(pool, operation);
+    } else if (operation.state == State.FAILED || operation.failedChildren() > 0) {
+      String message = operation.exception == null ? "" : "exception: " +
+          new ExceptionMessage(operation.exception);
+      LOGGER.error(AlarmMarkerFactory.getMarker(
+          PredefinedAlarm.FAILED_REPLICATION, pool),
+          "{} was removed but final scan {}; {} failed file operations.",
+          pool, message, operation.failedChildren());
+    }
+  }
+
+  /**
+   *  Handles the periodic scan/watchdog function.
+   *  The scan uses the implicit temporal ordering of puts to the linked hash
+   *  map to find all expired pools (they will be at the head of the
+   *  list maintained by the map).
+   */
+  private void scanIdle() {
+    lock.lock();
+    try {
+      long now = System.currentTimeMillis();
+      long expiry = watchdog.getExpiry();
+
+      for (Iterator<Entry<String, PoolOperation>> i
+          = idle.entrySet().iterator(); i.hasNext(); ) {
+        Entry<String, PoolOperation> entry = i.next();
+        String pool = entry.getKey();
+        PoolOperation operation = entry.getValue();
+
+        if (operation.state == State.EXCLUDED) {
+          continue;
+        }
+
+        if (operation.currStatus == PoolQoSStatus.UNINITIALIZED) {
+          continue;
+        }
+
+        if (operation.lastStatus == PoolQoSStatus.DOWN &&
+            operation.currStatus == PoolQoSStatus.DOWN) {
+          /*
+           *  When a scan completes or the operation is reset,
+           *  the lastStatus is set to the current status.
+           *  If both of these are DOWN, then the pool has
+           *  not changed state since the last scan.  We avoid
+           *  rescanning DOWN pools that have already been scanned.
+           */
+          continue;
+        }
+
+        if (now - operation.lastScan >= expiry) {
+          i.remove();
+          operation.forceScan = true;
+          operation.state = State.WAITING;
+          operation.resetFailed();
+          operation.exception = null;
+          waiting.put(pool, operation);
+        } else {
+          /**
+           * time-ordering invariant guarantees there are
+           * no more candidates at this point
+           */
+          break;
+        }
+      }
+    } finally {
+      lock.unlock();
+    }
+  }
+
+  private void scanWaiting() {
+    lock.lock();
+    try {
+      long now = System.currentTimeMillis();
+      long downExpiry = downGracePeriodUnit.toMillis(downGracePeriod);
+      long restartExpiry = restartGracePeriodUnit.toMillis(restartGracePeriod);
+
+      for (Iterator<Entry<String, PoolOperation>> i = waiting.entrySet().iterator(); i.hasNext(); ) {
+        Entry<String, PoolOperation> entry = i.next();
+        String pool = entry.getKey();
+        PoolOperation operation = entry.getValue();
+        long expiry;
+
+        switch (operation.currStatus) {
+          case DOWN:
+            expiry = downExpiry;
+            break;
+          default:
+            expiry = restartExpiry;
+            break;
+        }
+
+        /*
+         *  promote to running if force scan is true or
+         *  the grace period has expired; only promote
+         *  when a slot is available
+         */
+        if ((operation.forceScan || now - operation.lastUpdate >= expiry)
+              && running.size() < maxConcurrentRunning) {
+          i.remove();
+          LOGGER.trace("{}, lapsed time {}, running {}: submitting.",
+              operation,
+              now - operation.lastUpdate,
+              running.size());
+          submit(pool, operation);
+        }
+      }
+    } finally {
+      lock.unlock();
+    }
+  }
+
+  private void submit(String pool, PoolOperation operation) {
+    QoSMessageType type = pool.equals(QoSMessageType.CHECK_CUSTODIAL_ONLINE.name()) ?
+        QoSMessageType.CHECK_CUSTODIAL_ONLINE : operation.currStatus.getMessageType();
+    operation.task = new PoolScanTask(pool, type, operation.group,
+                                      operation.unit, operation.forceScan, handler);
+    operation.state = State.RUNNING;
+    operation.lastUpdate = System.currentTimeMillis();
+    operation.lastStatus = operation.currStatus;
+    operation.task.setErrorHandler(e -> update(pool, 0, e));
+    running.put(pool, operation);
+    LOGGER.trace("Submitting pool scan task for {}.", pool);
+    operation.task.submit();
+  }
+
+  private void terminate(String pool, PoolOperation operation) {
+    LOGGER.debug("terminate, pool {}, {}.", pool, operation);
+
+    if (operation.exception != null) {
+      operation.state = State.FAILED;
+    } else {
+      operation.state = State.IDLE;
+    }
+
+    long sinceLast = operation.lastUpdate - operation.lastScan;
+    counters.increment(pool, operation.currStatus, operation.state == State.FAILED,
+        operation.getCompleted(), operation.forceScan, sinceLast);
+
+    if (running.containsKey(pool)) {
+      running.remove(pool);
+    } else {
+      waiting.remove(pool);
+    }
+
+    operation.lastScan = operation.lastUpdate;
+
+    reset(pool, operation);
+  }
+
+  private void update(PoolMatcher filter,
+                      Map<String, PoolOperation> queue,
+                      boolean include,
+                      Set<String> visited) {
+    ImmutableSet.copyOf(queue.keySet()).stream().forEach((k) -> {
+      if (!visited.contains(k)) {
+        PoolOperation operation = queue.get(k);
+        if (filter.matches(k, operation)) {
+          if (!include) {
+            if (operation.task != null) {
+              operation.task.cancel("pool include/exclude admin command");
+            }
+            operation.state = State.EXCLUDED;
+            queue.remove(k);
+            reset(k, operation);
+            visited.add(k);
+            handler.handlePoolExclusion(k, true);
+          } else if (operation.state == State.EXCLUDED) {
+            operation.state = State.IDLE;
+            /*
+             * treat the operation as if emerging from an
+             * undefined state; allow user to decide
+             * whether to scan or not
+             */
+            operation.currStatus = PoolQoSStatus.UNINITIALIZED;
+            PoolV2Mode mode = changeHandler.getCurrentPsu().getPool(k).getPoolMode();
+            updateStatus(k, PoolQoSStatus.getStatusFor(mode));
+            visited.add(k);
+            handler.handlePoolExclusion(k, false);
+          }
+        }
+      }
+    });
+  }
+
+  class Watchdog {
+    Integer rescanWindow;
+    TimeUnit rescanWindowUnit;
+    volatile boolean running = true;
+    volatile boolean resetInterrupt = false;
+    volatile boolean runInterrupt = false;
+
+    long getExpiry() {
+      if (!running) {
+        return Long.MAX_VALUE;
+      }
+      return rescanWindowUnit.toMillis(rescanWindow);
+    }
+  }
+}
\ No newline at end of file
diff --git a/modules/dcache-qos/src/main/java/org/dcache/qos/services/scanner/data/PoolScanSummary.java b/modules/dcache-qos/src/main/java/org/dcache/qos/services/scanner/data/PoolScanSummary.java
new file mode 100644
index 0000000000..cc70a5e71d
--- /dev/null
+++ b/modules/dcache-qos/src/main/java/org/dcache/qos/services/scanner/data/PoolScanSummary.java
@@ -0,0 +1,127 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos.services.scanner.data;
+
+import java.io.Serializable;
+import org.dcache.qos.data.QoSMessageType;
+
+/**
+ *  Simple struct to use during pool scan; shared between handlers, task and namespace access.
+ */
+public final class PoolScanSummary implements Serializable {
+    private static final long serialVersionUID = 7907827079755395974L;
+
+    private final String          pool;
+    private final QoSMessageType  type;
+    private final String          group;
+    private final String          storageUnit;
+    private final boolean         forced;
+
+    private int                   files;
+
+    private volatile boolean cancelled  = false;
+
+    public PoolScanSummary(String pool,
+                           QoSMessageType type,
+                           String group,
+                           String storageUnit,
+                           boolean forced) {
+        this.pool = pool;
+        this.type = type;
+        this.group = group;
+        this.storageUnit = storageUnit;
+        this.forced = forced;
+        files = 0;
+    }
+
+    public int getCount() {
+        return files;
+    }
+
+    public String getGroup() {
+        return group;
+    }
+
+    public String getPool() {
+        return pool;
+    }
+
+    public String getStorageUnit() {
+        return storageUnit;
+    }
+
+    public QoSMessageType getType() {
+        return type;
+    }
+
+    public void incrementCount() {
+        ++files;
+    }
+
+    public boolean isCancelled() {
+        return cancelled;
+    }
+
+    public boolean isForced() { return forced; }
+
+    public void setCancelled(boolean cancelled) {
+        this.cancelled = cancelled;
+    }
+}
diff --git a/modules/dcache-qos/src/main/java/org/dcache/qos/services/scanner/handlers/PoolOpChangeHandler.java b/modules/dcache-qos/src/main/java/org/dcache/qos/services/scanner/handlers/PoolOpChangeHandler.java
new file mode 100644
index 0000000000..901075021a
--- /dev/null
+++ b/modules/dcache-qos/src/main/java/org/dcache/qos/services/scanner/handlers/PoolOpChangeHandler.java
@@ -0,0 +1,463 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos.services.scanner.handlers;
+
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Sets;
+import diskCacheV111.poolManager.PoolSelectionUnit;
+import diskCacheV111.poolManager.PoolSelectionUnit.SelectionPool;
+import diskCacheV111.poolManager.PoolSelectionUnit.SelectionPoolGroup;
+import diskCacheV111.poolManager.PoolSelectionUnit.SelectionUnit;
+import diskCacheV111.poolManager.StorageUnit;
+import diskCacheV111.poolManager.StorageUnitInfoExtractor;
+import diskCacheV111.pools.PoolV2Mode;
+import java.util.Collection;
+import java.util.Map.Entry;
+import java.util.Set;
+import java.util.stream.Collectors;
+import org.dcache.poolmanager.PoolMonitor;
+import org.dcache.qos.data.PoolQoSStatus;
+import org.dcache.qos.services.scanner.data.PoolFilter;
+import org.dcache.qos.services.scanner.data.PoolOperationMap;
+import org.dcache.qos.services.scanner.util.ScannerMapInitializer;
+import org.dcache.qos.util.PoolMonitorChangeHandler;
+
+/**
+ *  Manages changes in pool monitor data for the pool operation map.
+ *  <p/>
+ *  Certain kinds of changes are processed for potential task cancellation and pool (re)scans
+ *     which the changes may necessitate.
+ */
+public final class PoolOpChangeHandler extends PoolMonitorChangeHandler<PoolOpDiff, ScannerMapInitializer> {
+    private PoolOperationMap poolOperationMap;
+    private PoolOperationHandler poolOperationHandler;
+
+    public synchronized PoolOpDiff reloadAndScan(PoolMonitor newPoolMonitor) {
+        LOGGER.trace("Comparing current pool info to new psu.");
+        PoolOpDiff diff = compare(poolMonitor(), newPoolMonitor);
+
+        if (diff.isEmpty()) {
+            LOGGER.trace("reloadAndScan, nothing to do.");
+            lastRefresh = System.currentTimeMillis();
+            return diff;
+        }
+
+        LOGGER.trace("Cancelling pool operations for removed pools {}.", diff.getOldPools());
+        diff.getOldPools().stream().forEach(this::cancelAndRemoveCurrentPoolOperation);
+
+        LOGGER.trace("Cancelling pool operations for pools removed from groups {}.",
+                      diff.getPoolsRemovedFromPoolGroup());
+        diff.getPoolsRemovedFromPoolGroup().keySet()
+            .stream()
+            .forEach(this::cancelCurrentPoolOperation);
+
+        LOGGER.trace("Removing uninitialized from other sets.");
+        diff.getUninitializedPools().stream()
+            .forEach((p) -> {
+                diff.getPoolsAddedToPoolGroup().removeAll(p);
+                diff.getPoolsRemovedFromPoolGroup().removeAll(p);
+                diff.getModeChanged().remove(p);
+                diff.getTagsChanged().remove(p);
+            });
+
+        PoolSelectionUnit currentPsu = newPoolMonitor.getPoolSelectionUnit();
+
+        LOGGER.trace("Adding new pools to the pool operation map.");
+        diff.getNewPools().stream().forEach(poolOperationMap::add);
+
+        LOGGER.trace("Scanning pools added to pool groups.");
+        diff.getPoolsAddedToPoolGroup().entries().stream()
+            .forEach(g-> scanPoolAddedToPoolGroup(g, currentPsu));
+
+        LOGGER.trace("Scanning pools removed from pool groups.");
+        diff.getPoolsRemovedFromPoolGroup().entries().stream()
+            .forEach(e -> scanPoolRemovedFromPoolGroup(e, currentPsu));
+
+        LOGGER.trace("Scanning pool groups pointing to new units {}.",
+            diff.getNewUnits());
+        diff.getNewUnits().stream()
+                          .forEach(u->scanPoolsWithStorageUnitModified(u.getName(), currentPsu));
+
+        LOGGER.trace("Scanning pool groups with units whose "
+                        + "constraints have changed; new constraints {}.",
+                     diff.getConstraintsChanged());
+        diff.getConstraintsChanged().stream()
+            .forEach(u-> scanPoolsWithStorageUnitModified(u, currentPsu));
+
+        LOGGER.trace("Alerting change of pool status.");
+        diff.getModeChanged().entrySet().stream()
+            .forEach(e -> poolOperationHandler.handlePoolStatusChange(e.getKey(),
+                            PoolQoSStatus.getStatusFor(e.getValue())));
+
+        LOGGER.trace("Rescanning the pool groups whose marker changed.");
+        diff.getMarkerChanged().stream().forEach(g->scanPoolsOfModifiedPoolGroup(g, currentPsu));
+
+        LOGGER.trace("Rescanning the pools with changed tags.");
+        diff.getTagsChanged().keySet().stream()
+            .map(currentPsu::getPool)
+            .forEach(p -> poolOperationMap.scan(p.getName(),
+                                       null,
+                                    null,
+                                     null,
+                                                p.getPoolMode(),
+                                true));
+
+        LOGGER.trace("Checking to see if previously uninitialized pools are now ready.");
+        poolOperationMap.saveExcluded();
+        lastRefresh = System.currentTimeMillis();
+
+        LOGGER.trace("DIFF:\n{}", diff);
+
+        LOGGER.trace("Swapping pool monitors");
+        initializer.updatePoolMonitor(newPoolMonitor);
+        return diff;
+    }
+
+    public void setMapInitializer(ScannerMapInitializer initializer) {
+        this.initializer = initializer;
+    }
+
+    public void setPoolOperationHandler(PoolOperationHandler poolOperationHandler) {
+        this.poolOperationHandler = poolOperationHandler;
+    }
+
+    public void setPoolOperationMap(PoolOperationMap poolOperationMap) {
+        this.poolOperationMap = poolOperationMap;
+    }
+
+    private void cancelAndRemoveCurrentPoolOperation(String pool) {
+        cancelCurrentPoolOperation(pool);
+        poolOperationMap.remove(pool);
+    }
+
+    private void cancelCurrentPoolOperation(String pool) {
+        PoolFilter poolFilter = new PoolFilter();
+        poolFilter.setPools(pool);
+        poolOperationMap.cancel(poolFilter);
+    }
+
+    private PoolOpDiff compare(PoolMonitor currentPoolMonitor, PoolMonitor nextPoolMonitor) {
+        PoolSelectionUnit nextPsu = nextPoolMonitor.getPoolSelectionUnit();
+        PoolSelectionUnit currentPsu = currentPoolMonitor.getPoolSelectionUnit();
+        PoolOpDiff diff = new PoolOpDiff();
+
+        LOGGER.trace("Searching for currently uninitialized pools.");
+        getUninitializedPools(diff, currentPsu);
+
+        LOGGER.trace("comparing pools");
+        Set<String> commonPools = comparePools(diff, currentPsu, nextPsu);
+
+        LOGGER.trace("comparing pool groups");
+        Set<String> common = comparePoolGroups(diff, currentPsu, nextPsu);
+
+        LOGGER.trace("adding pools and units to new pool groups");
+        addPoolsAndUnitsToNewPoolGroups(diff, nextPsu);
+
+        LOGGER.trace("comparing pools in pool groups");
+        comparePoolsInPoolGroups(diff, common, currentPsu, nextPsu);
+
+        LOGGER.trace("find pool group marker changes");
+        comparePoolGroupMarkers(diff, common, currentPsu, nextPsu);
+
+        LOGGER.trace("comparing storage units");
+        common = compareStorageUnits(diff, currentPsu, nextPsu);
+
+        LOGGER.trace("adding pool groups for new storage units");
+        addPoolGroupsForNewUnits(diff, nextPsu);
+
+        LOGGER.trace("comparing storage unit links and constraints");
+        compareStorageUnitLinksAndConstraints(diff, common, currentPsu, nextPsu);
+
+        LOGGER.trace("comparing pool mode");
+        comparePoolMode(diff, commonPools, nextPsu);
+
+        return diff;
+    }
+
+    private void addPoolsAndUnitsToNewPoolGroups(PoolOpDiff diff, PoolSelectionUnit nextPsu) {
+        Collection<String> newGroups = diff.getNewGroups();
+        for (String group : newGroups) {
+            nextPsu.getPoolsByPoolGroup(group)
+                .stream()
+                .map(SelectionPool::getName)
+                .forEach((p) -> diff.poolsAdded.put(p, group));
+            StorageUnitInfoExtractor.getStorageUnitsInGroup(group, nextPsu)
+                .stream()
+                .forEach((u) -> diff.unitsAdded.put(group, u.getName()));
+        }
+    }
+
+    private void addPoolGroupsForNewUnits(PoolOpDiff diff, PoolSelectionUnit nextPsu) {
+        Collection<StorageUnit> newUnits = diff.getNewUnits();
+        for (StorageUnit unit : newUnits) {
+            String name = unit.getName();
+            StorageUnitInfoExtractor.getPrimaryGroupsFor(name, nextPsu)
+                .stream()
+                .forEach((g) -> diff.unitsAdded.put(g, name));
+        }
+    }
+
+    private void comparePoolGroupMarkers(PoolOpDiff diff,
+                                         Set<String> common,
+                                         PoolSelectionUnit currentPsu,
+                                         PoolSelectionUnit nextPsu) {
+        for (String group : common) {
+            SelectionPoolGroup nextPoolGroup = nextPsu.getPoolGroups().get(group);
+            SelectionPoolGroup currPoolGroup = currentPsu.getPoolGroups().get(group);
+            if (nextPoolGroup.isPrimary() != currPoolGroup.isPrimary()) {
+                diff.getOldGroups().add(group);
+                diff.getNewGroups().add(nextPoolGroup.getName());
+
+                /*
+                 * Only rescan groups whose marker changed.
+                 */
+                diff.getMarkerChanged().add(group);
+            }
+        }
+    }
+
+    private void comparePoolMode(PoolOpDiff diff, Set<String> commonPools, PoolSelectionUnit psu) {
+        /*
+         *  First add the info for all new pools to the diff.
+         */
+        diff.getNewPools().stream()
+            .forEach((p) -> {
+                diff.getModeChanged().put(p, psu.getPool(p).getPoolMode());
+            });
+
+        /*
+         * Now check for differences with current pools that are still valid.
+         */
+        commonPools.stream()
+            .forEach((p) -> {
+                PoolV2Mode newMode = psu.getPool(p).getPoolMode();
+                PoolQoSStatus oldStatus = poolOperationMap.getCurrentStatus(p);
+                PoolQoSStatus newStatus = PoolQoSStatus.getStatusFor(newMode);
+                if (newStatus != oldStatus) {
+                    diff.getModeChanged().put(p, newMode);
+                }
+            });
+    }
+
+    private void comparePoolsInPoolGroups(PoolOpDiff diff,
+                                          Set<String> common,
+                                          PoolSelectionUnit currentPsu,
+                                          PoolSelectionUnit nextPsu) {
+        for (String group : common) {
+            Set<String> next = nextPsu.getPoolsByPoolGroup(group)
+                .stream()
+                .map(SelectionPool::getName)
+                .collect(Collectors.toSet());
+            Set<String> curr = currentPsu.getPoolsByPoolGroup(group)
+                .stream()
+                .map(SelectionPool::getName)
+                .collect(Collectors.toSet());
+            Sets.difference(next, curr).stream().forEach((p) -> diff.poolsAdded.put(p, group));
+            Sets.difference(curr, next).stream().filter((p) -> !diff.oldPools.contains(p))
+                .forEach((p) -> diff.poolsRmved.put(p, group));
+        }
+    }
+
+    private Set<String> compareStorageUnits(PoolOpDiff diff,
+                                            PoolSelectionUnit currentPsu,
+                                            PoolSelectionUnit nextPsu) {
+        Set<String> next = nextPsu.getSelectionUnits().values()
+            .stream()
+            .filter(StorageUnit.class::isInstance)
+            .map(SelectionUnit::getName)
+            .collect(Collectors.toSet());
+        Set<String> curr = currentPsu.getSelectionUnits().values()
+            .stream()
+            .filter(StorageUnit.class::isInstance)
+            .map(SelectionUnit::getName)
+            .collect(Collectors.toSet());
+        Sets.difference(next, curr).stream().map(nextPsu::getStorageUnit).forEach(diff.newUnits::add);
+        Sets.difference(curr, next).stream().forEach(diff.oldUnits::add);
+        return Sets.intersection(next, curr);
+    }
+
+    private void compareStorageUnitLinksAndConstraints(PoolOpDiff diff,
+                                                       Set<String> common,
+                                                       PoolSelectionUnit currentPsu,
+                                                       PoolSelectionUnit nextPsu) {
+        for (String unit : common) {
+            StorageUnit nextUnit = nextPsu.getStorageUnit(unit);
+            Set<String> next
+                = ImmutableSet.copyOf(StorageUnitInfoExtractor.getPoolGroupsFor(unit,
+                nextPsu,
+                false));
+            StorageUnit currentUnit = currentPsu.getStorageUnit(unit);
+            Set<String> curr
+                = ImmutableSet.copyOf(StorageUnitInfoExtractor.getPoolGroupsFor(unit,
+                currentPsu,
+                false));
+            Sets.difference(next, curr).stream().forEach(g -> diff.unitsAdded.put(g, unit));
+            Sets.difference(curr, next).stream().filter(g -> !diff.oldGroups.contains(g))
+                .forEach(g -> diff.unitsRmved.put(g, unit));
+
+            Integer required = nextUnit.getRequiredCopies();
+            int newRequired = required == null ? -1 : required;
+            required = currentUnit.getRequiredCopies();
+            int oldRequired = required == null ? -1 : required;
+
+            Set<String> nextConstraints = ImmutableSet.copyOf(nextUnit.getOnlyOneCopyPer());
+            Set<String> currConstraints = ImmutableSet.copyOf(currentUnit.getOnlyOneCopyPer());
+
+            if (newRequired != oldRequired || !nextConstraints.equals(currConstraints)) {
+                diff.constraintsChanged.add(unit);
+            }
+        }
+    }
+
+    private void getUninitializedPools(PoolOpDiff diff, PoolSelectionUnit currentPsu) {
+        currentPsu.getPools().values()
+            .stream()
+            .filter(p -> PoolQoSStatus.getStatusFor(p.getPoolMode())
+                == PoolQoSStatus.UNINITIALIZED)
+            .forEach(p -> diff.getUninitializedPools().add(p.getName()));
+    }
+
+    private Set<String> comparePools(PoolOpDiff diff,
+                                     PoolSelectionUnit currentPsu,
+                                     PoolSelectionUnit nextPsu) {
+        Set<String> next = nextPsu.getPools().values().stream().map(SelectionPool::getName)
+            .collect(Collectors.toSet());
+        Set<String> curr = currentPsu.getPools().values().stream().map(SelectionPool::getName)
+            .collect(Collectors.toSet());
+        Sets.difference(next, curr).stream().forEach(p -> diff.newPools.add(p));
+        Sets.difference(curr, next).stream().forEach(p -> diff.oldPools.add(p));
+        return Sets.intersection(curr, next);
+    }
+
+    private Set<String> comparePoolGroups(PoolOpDiff diff,
+                                          PoolSelectionUnit currentPsu,
+                                          PoolSelectionUnit nextPsu) {
+        Set<String> next = nextPsu.getPoolGroups().values()
+            .stream()
+            .map(SelectionPoolGroup::getName)
+            .collect(Collectors.toSet());
+        Set<String> curr = currentPsu.getPoolGroups().values()
+            .stream()
+            .map(SelectionPoolGroup::getName)
+            .collect(Collectors.toSet());
+        Sets.difference(next, curr).stream().forEach(diff.newGroups::add);
+        Sets.difference(curr, next).stream().forEach(diff.oldGroups::add);
+        return Sets.intersection(next, curr);
+    }
+
+    /**
+     *  Scans the "new" pool, also making sure all files have the sticky bit.
+     */
+    private void scanPoolAddedToPoolGroup(Entry<String, String> entry, PoolSelectionUnit psu) {
+        String pool = entry.getKey();
+        String addedTo = entry.getValue();
+        PoolV2Mode mode = psu.getPool(pool).getPoolMode();
+        poolOperationMap.add(pool);
+        poolOperationMap.updateStatus(pool, PoolQoSStatus.getStatusFor(mode));
+        scanPool(pool, addedTo, mode);
+    }
+
+    /**
+     *  We allow the scanner to react to changes in the "primary" status of a pool group.
+     */
+    private void scanPoolsOfModifiedPoolGroup(String poolGroupName, PoolSelectionUnit psu) {
+        psu.getPoolsByPoolGroup(poolGroupName).stream()
+            .forEach(p -> scanPool(p.getName(), null, null, p.getPoolMode()));
+    }
+
+    /**
+     *  NB: if we try to scan the pool as DOWN, this means we need to pass the old group id
+     *  for the pool, because we cannot synchronize the scan + adjustment tasks such as to
+     *  create a barrier so that we can remove the pool from the map after everything completes.
+     */
+    private void scanPoolRemovedFromPoolGroup(Entry<String, String> entry, PoolSelectionUnit psu) {
+        String pool = entry.getKey();
+        String removedFrom = entry.getValue();
+        PoolV2Mode mode = psu.getPool(pool).getPoolMode();
+        scanPool(entry.getKey(), null, removedFrom, mode);
+    }
+
+    /**
+     *  Will skip the grace period wait, but still take into consideration whether the pool has
+     *  already been scanned because it went DOWN, or whether it is EXCLUDED.
+     */
+    private void scanPool(String pool, String addedTo, String removedFrom, PoolV2Mode mode) {
+        if (poolOperationMap.isInitialized(mode)) {
+            poolOperationMap.scan(pool, addedTo, removedFrom, null, mode, false);
+        }
+    }
+
+    /**
+     *  Will skip the grace period wait, as well as transition checks.
+     */
+    private void scanPool(String pool, String unit, PoolV2Mode mode) {
+        poolOperationMap.scan(pool, null, null, unit, mode, true);
+    }
+
+    private void scanPoolsInGroup(String poolGroupName, String unit, PoolSelectionUnit psu) {
+        psu.getPoolsByPoolGroup(poolGroupName).stream().forEach(p -> scanPool(p.getName(), unit, p.getPoolMode()));
+
+    }
+
+    private void scanPoolsWithStorageUnitModified(String unit, PoolSelectionUnit psu) {
+        StorageUnitInfoExtractor.getPoolGroupsFor(unit, psu,false)
+                                .stream().forEach((group) -> scanPoolsInGroup(group, unit, psu));
+    }
+}
diff --git a/modules/dcache-qos/src/main/java/org/dcache/qos/services/scanner/handlers/PoolOpDiff.java b/modules/dcache-qos/src/main/java/org/dcache/qos/services/scanner/handlers/PoolOpDiff.java
new file mode 100644
index 0000000000..18155a2a9f
--- /dev/null
+++ b/modules/dcache-qos/src/main/java/org/dcache/qos/services/scanner/handlers/PoolOpDiff.java
@@ -0,0 +1,211 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos.services.scanner.handlers;
+
+import com.google.common.collect.HashMultimap;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.Multimap;
+import diskCacheV111.poolManager.StorageUnit;
+import diskCacheV111.pools.PoolV2Mode;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ *  Container for recording changes based on a PoolMonitor update. Records pools, pool
+ *  groups and storage units that have been added or removed, and modifications to the pool
+ *  set of a pool group, to storage unit constraints, and to the mode or tags for new or
+ *  current pools.
+ */
+public final class PoolOpDiff {
+    final Collection<String> newPools = new ArrayList<>();
+    final Collection<String> oldPools = new ArrayList<>();
+    final Collection<String> uninitPools = new ArrayList<>();
+    final Collection<String> newGroups = new ArrayList<>();
+    final Collection<String> oldGroups = new ArrayList<>();
+    final Collection<StorageUnit> newUnits = new ArrayList<>();
+    final Collection<String> oldUnits = new ArrayList<>();
+    final Collection<String> markerChanged = new ArrayList<>();
+    final Collection<String> constraintsChanged = new ArrayList<>();
+
+    /*
+     *  (pool, poolGroup)
+     */
+    final Multimap<String, String> poolsAdded = HashMultimap.create();
+
+    /*
+     *  (pool, poolGroup)
+     */
+    final Multimap<String, String> poolsRmved = HashMultimap.create();
+
+    /*
+     *  (pgroup, unit)
+     */
+    final Multimap<String, String> unitsAdded = HashMultimap.create();
+
+    /*
+     *  (pgroup, unit)
+     */
+    final Multimap<String, String> unitsRmved = HashMultimap.create();
+
+    /*
+     *  (pool, mode)
+     */
+    private final Map<String, PoolV2Mode> modeChanged = new HashMap<>();
+
+    /*
+     *  (pool, tags)
+     */
+    private final Map<String, ImmutableMap<String, String>> tagsChanged
+                    = new HashMap<>();
+
+    public Collection<String> getConstraintsChanged() {
+        return constraintsChanged;
+    }
+
+    public Collection<String> getMarkerChanged() { return markerChanged; }
+
+    public Map<String, PoolV2Mode> getModeChanged() {
+        return modeChanged;
+    }
+
+    public Collection<String> getNewGroups() {
+        return newGroups;
+    }
+
+    public Collection<String> getNewPools() {
+        return newPools;
+    }
+
+    public Collection<StorageUnit> getNewUnits() {
+        return newUnits;
+    }
+
+    public Collection<String> getOldGroups() {
+        return oldGroups;
+    }
+
+    public Collection<String> getOldPools() {
+        return oldPools;
+    }
+
+    public Collection<String> getOldUnits() {
+        return oldUnits;
+    }
+
+    public Multimap<String, String> getPoolsAddedToPoolGroup() {
+        return poolsAdded;
+    }
+
+    public Multimap<String, String> getPoolsRemovedFromPoolGroup() {
+        return poolsRmved;
+    }
+
+    public Map<String, ImmutableMap<String, String>> getTagsChanged() {
+        return tagsChanged;
+    }
+
+    public Collection<String> getUninitializedPools() {
+        return uninitPools;
+    }
+
+    public Multimap<String, String> getUnitsAddedToPoolGroup() {
+        return unitsAdded;
+    }
+
+    public Multimap<String, String> getUnitsRemovedFromPoolGroup() {
+        return unitsRmved;
+    }
+
+    public boolean isEmpty() {
+        return newPools.isEmpty() && oldPools.isEmpty() && uninitPools.isEmpty()
+                        && newGroups.isEmpty() && oldGroups.isEmpty()
+                        && newUnits.isEmpty() && oldUnits.isEmpty()
+                        && poolsAdded.isEmpty() && poolsRmved.isEmpty()
+                        && unitsAdded.isEmpty() && unitsRmved.isEmpty()
+                        && constraintsChanged.isEmpty() && tagsChanged.isEmpty()
+                        && modeChanged.isEmpty();
+    }
+
+    public String toString() {
+        return String.format("New Pools:            %s\n" +
+                                        "Old Pools:            %s\n" +
+                                        "Uninitialized Pools:  %s\n" +
+                                        "New Groups:           %s\n" +
+                                        "Old Groups:           %s\n" +
+                                        "New Units:            %s\n" +
+                                        "Old Units:            %s\n" +
+                                        "Pools Added:          %s\n" +
+                                        "Pools Removed:        %s\n" +
+                                        "Units Added:          %s\n" +
+                                        "Units Removed:        %s\n" +
+                                        "Constraints changed:  %s\n" +
+                                        "Mode changed:         %s\n" +
+                                        "Tags changed:         %s\n",
+                        newPools, oldPools, uninitPools,
+                        newGroups, oldGroups,
+                        newUnits, oldUnits,
+                        poolsAdded, poolsRmved,
+                        unitsAdded, unitsRmved,
+                        constraintsChanged, modeChanged,
+                        tagsChanged);
+    }
+}
diff --git a/modules/dcache-qos/src/main/java/org/dcache/qos/services/scanner/handlers/PoolOperationHandler.java b/modules/dcache-qos/src/main/java/org/dcache/qos/services/scanner/handlers/PoolOperationHandler.java
new file mode 100644
index 0000000000..2a8676f7d8
--- /dev/null
+++ b/modules/dcache-qos/src/main/java/org/dcache/qos/services/scanner/handlers/PoolOperationHandler.java
@@ -0,0 +1,162 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos.services.scanner.handlers;
+
+import diskCacheV111.util.CacheException;
+import java.util.concurrent.ExecutorService;
+import org.dcache.qos.QoSException;
+import org.dcache.qos.data.PoolQoSStatus;
+import org.dcache.qos.listeners.QoSPoolScanResponseListener;
+import org.dcache.qos.listeners.QoSVerificationListener;
+import org.dcache.qos.services.scanner.data.PoolOperationMap;
+import org.dcache.qos.services.scanner.data.PoolScanSummary;
+import org.dcache.qos.services.scanner.namespace.NamespaceAccess;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ *  Dispatches to the namespace the scan summary request and calls complete when if terminates.
+ *  Updates the scan counts on the basis of verification response.  Updates the operation map
+ *  when a pool's status has changed.
+ */
+public final class PoolOperationHandler {
+    private static final Logger LOGGER = LoggerFactory.getLogger(PoolOperationHandler.class);
+
+    private PoolOperationMap operationMap;
+    private NamespaceAccess  namespace;
+    private QoSPoolScanResponseListener listener;
+    private QoSVerificationListener verificationListener;
+
+    private ExecutorService taskService;
+    private ExecutorService updateService;
+
+    private PoolTaskCompletionHandler completionHandler;
+
+    public ExecutorService getTaskService() {
+        return taskService;
+    }
+
+    public void handlePoolScan(PoolScanSummary scan) {
+        try {
+            namespace.handlePnfsidsForPool(scan);
+            completionHandler.taskCompleted(scan);
+        } catch (CacheException e) {
+            completionHandler.taskFailed(scan, e);
+        }
+    }
+
+    public void handlePoolStatusChange(String pool, PoolQoSStatus status) {
+        if (status != PoolQoSStatus.UNINITIALIZED) {
+            operationMap.updateStatus(pool, status);
+        }
+    }
+
+    public void handleBatchedVerificationResponse(String location, int succeeded, int failed) {
+        updateService.submit(() -> listener.scanRequestUpdated(location, succeeded, failed));
+    }
+
+    public void handlePoolScanCancelled(String pool, PoolQoSStatus status) {
+        try {
+            LOGGER.trace("handlePoolScanCancelled for {}: {}, notifying cancellation.", pool, status);
+            verificationListener.fileQoSBatchedVerificationCancelled(pool);
+        } catch (QoSException e) {
+            LOGGER.error("Could not send batch cancellation notification for {}: {}.",
+                pool, e.toString());
+        }
+    }
+
+    public void handlePoolExclusion(String pool, boolean excluded) {
+        try {
+            verificationListener.notifyLocationExclusion(pool, excluded);
+        } catch (QoSException e) {
+            String action = excluded ? "excluded" : "re-included";
+            LOGGER.error("Could not notify verification listener of {} pool {}: {}.",
+                action, pool, e.toString());
+        }
+    }
+
+    public void setCompletionHandler(PoolTaskCompletionHandler completionHandler) {
+        this.completionHandler = completionHandler;
+    }
+
+    public void setScanResponseListener(QoSPoolScanResponseListener listener) {
+        this.listener = listener;
+    }
+
+    public void setVerificationListener(QoSVerificationListener verificationListener) {
+        this.verificationListener = verificationListener;
+    }
+
+    public void setNamespace(NamespaceAccess namespace) {
+        this.namespace = namespace;
+    }
+
+    public void setOperationMap(PoolOperationMap operationMap) {
+        this.operationMap = operationMap;
+    }
+
+    public void setTaskService(ExecutorService taskService) {
+        this.taskService = taskService;
+    }
+
+    public void setUpdateService(ExecutorService updateService) {
+        this.updateService = updateService;
+    }
+}
diff --git a/modules/dcache-qos/src/main/java/org/dcache/qos/services/scanner/handlers/PoolTaskCompletionHandler.java b/modules/dcache-qos/src/main/java/org/dcache/qos/services/scanner/handlers/PoolTaskCompletionHandler.java
new file mode 100644
index 0000000000..5b23d52119
--- /dev/null
+++ b/modules/dcache-qos/src/main/java/org/dcache/qos/services/scanner/handlers/PoolTaskCompletionHandler.java
@@ -0,0 +1,91 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos.services.scanner.handlers;
+
+import diskCacheV111.util.CacheException;
+import org.dcache.qos.services.scanner.data.PoolOperationMap;
+import org.dcache.qos.services.scanner.data.PoolScanSummary;
+
+/**
+ *  Implements the handling of pool scan task termination via pass-through to the operation map.
+ */
+public final class PoolTaskCompletionHandler {
+    private PoolOperationMap map;
+
+    public void childTerminated(String pool) {
+        map.update(pool,false);
+    }
+
+    public void childTerminatedWithFailure(String pool) {
+        map.update(pool, true);
+    }
+
+    public void setMap(PoolOperationMap map) {
+        this.map = map;
+    }
+
+    public void taskCompleted(PoolScanSummary scan) {
+        map.update(scan.getPool(), scan.getCount());
+    }
+
+    public void taskFailed(PoolScanSummary scan, CacheException e) {
+        map.update(scan.getPool(), scan.getCount(), e);
+    }
+}
diff --git a/modules/dcache-qos/src/main/java/org/dcache/qos/services/scanner/namespace/LocalNamespaceAccess.java b/modules/dcache-qos/src/main/java/org/dcache/qos/services/scanner/namespace/LocalNamespaceAccess.java
new file mode 100644
index 0000000000..c9beeb0c70
--- /dev/null
+++ b/modules/dcache-qos/src/main/java/org/dcache/qos/services/scanner/namespace/LocalNamespaceAccess.java
@@ -0,0 +1,321 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos.services.scanner.namespace;
+
+import diskCacheV111.namespace.NameSpaceProvider;
+import diskCacheV111.util.CacheException;
+import diskCacheV111.util.PnfsId;
+import java.io.PrintWriter;
+import java.sql.Connection;
+import java.sql.PreparedStatement;
+import java.sql.ResultSet;
+import java.sql.SQLException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.stream.Collectors;
+import javax.sql.DataSource;
+import org.dcache.cells.CellStub;
+import org.dcache.chimera.BackEndErrorHimeraFsException;
+import org.dcache.chimera.IOHimeraFsException;
+import org.dcache.qos.QoSException;
+import org.dcache.qos.data.QoSMessageType;
+import org.dcache.qos.listeners.QoSVerificationListener;
+import org.dcache.qos.services.scanner.data.PoolScanSummary;
+import org.dcache.qos.util.CacheExceptionUtils;
+import org.dcache.qos.vehicles.QoSBatchedVerificationRequest;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import static org.dcache.qos.data.QoSMessageType.CHECK_CUSTODIAL_ONLINE;
+import static org.dcache.util.SqlHelper.tryToClose;
+
+/**
+ *  Provides handling of specialized long-running queries which require direct access to the
+ *  underlying namespace database.
+ *  <p/>
+ *  Class is not marked final so that a test version can be implemented by extension.
+ */
+public class LocalNamespaceAccess implements NamespaceAccess {
+    static final String SQL_GET_ALL_FOR_LOCATION
+                    = "SELECT n.ipnfsid FROM t_locationinfo l, t_inodes n "
+                                    + "WHERE l.inumber = n.inumber "
+                                    + "AND l.itype = 1 "
+                                    + "AND l.ilocation = ?";
+
+    static final String SQL_GET_CONTAINED_IN
+                    = "SELECT n.ipnfsid FROM t_locationinfo l, t_inodes n "
+                                    + "WHERE n.inumber = l.inumber "
+                                    + "AND l.ilocation IN (%s) "
+                                    + "AND NOT EXISTS "
+                                    + "(SELECT n1.ipnfsid FROM t_locationinfo l1, t_inodes n1 "
+                                    + "WHERE n.inumber = l1.inumber "
+                                    + "AND n.inumber = n1.inumber "
+                                    + "AND l1.ilocation NOT IN (%s))";
+
+    static final String SQL_MISSING_ONLINE_CUSTODIAL
+                    = "SELECT n.ipnfsid FROM t_inodes n, t_locationinfo l0 "
+                                    + "WHERE n.inumber=l0.inumber "
+                                    + "AND l0.itype=0 "
+                                    + "AND n.iaccess_latency=1 "
+                                    + "AND n.iretention_policy=0 "
+                                    + "AND NOT EXISTS "
+                                    + "(SELECT * FROM t_locationinfo l1 "
+                                    + "WHERE n.inumber=l1.inumber "
+                                    + "AND l1.itype=1)";
+
+    private static final Logger LOGGER = LoggerFactory.getLogger(LocalNamespaceAccess.class);
+
+    /**
+     *  Callback to service for sending notifications.
+     */
+    protected QoSVerificationListener verificationListener;
+
+    /**
+     *  Database connection pool for queries returning multiple pnfsid info.
+     */
+    private DataSource connectionPool;
+
+    /**
+     *  Delegate service used to extract file attributes; this is used when printing the
+     *  results of the inaccessible or contained-in queries.
+     */
+    private NameSpaceProvider namespace;
+
+    /**
+     *  Round-trip buffer used when running pool-based queries.
+     */
+    private int fetchSize;
+
+    /**
+     *  Endpoint used for verifying replicas.
+     */
+    private CellStub pools;
+
+    @Override
+    public void printContainedInFiles(List<String> locations, PrintWriter printWriter)
+                    throws CacheException, InterruptedException {
+        try {
+            Connection connection = getConnection();
+            try {
+                printResults(connection, locations, printWriter);
+            } catch (SQLException e) {
+                throw new IOHimeraFsException(e.getMessage());
+            } finally {
+                tryToClose(connection);
+            }
+        } catch (IOHimeraFsException e) {
+            throw new CacheException(CacheException.RESOURCE,
+                                     String.format("Could not handle pnfsids for %s",
+                                                   locations), e);
+        }
+    }
+
+    @Override
+    public void handlePnfsidsForPool(PoolScanSummary scan) throws CacheException {
+        try {
+            Connection connection = getConnection();
+            try {
+                handleQuery(connection, scan);
+            } catch (SQLException e) {
+                throw new IOHimeraFsException(e.getMessage());
+            } catch (QoSException e) {
+                throw CacheExceptionUtils.getCacheExceptionFrom(e);
+            } finally {
+                tryToClose(connection);
+            }
+        } catch (IOHimeraFsException e) {
+            throw new CacheException(CacheException.RESOURCE,
+                                     String.format("Could not handle pnfsids for %s",
+                                                   scan.getPool()), e);
+        }
+    }
+
+    @Override
+    public void setConnectionPool(DataSource connectionPool) {
+        this.connectionPool = connectionPool;
+    }
+
+    @Override
+    public void setFetchSize(int fetchSize) {
+        this.fetchSize = fetchSize;
+    }
+
+    @Override
+    public void setNamespace(NameSpaceProvider namespace) {
+        this.namespace = namespace;
+    }
+
+    public void setPools(CellStub pools) {
+        this.pools = pools;
+    }
+
+    public void setVerificationListener(QoSVerificationListener verificationListener) {
+        this.verificationListener = verificationListener;
+    }
+
+    private Connection getConnection() throws IOHimeraFsException {
+        try {
+            return connectionPool.getConnection();
+        } catch (SQLException e) {
+            throw new BackEndErrorHimeraFsException(e.getMessage());
+        }
+    }
+
+    /**
+     *  The query processes all replicas for the location by batching the returned pnfsids
+     *  into lists to be dispatched to the verification service.
+     */
+    private void handleQuery(Connection connection, PoolScanSummary scan)
+        throws SQLException, QoSException {
+        PreparedStatement statement = null;
+        ResultSet resultSet = null;
+        String pool = scan.getPool();
+        String group = scan.getGroup();
+        String storageUnit = scan.getStorageUnit();
+        QoSMessageType type = scan.getType();
+        boolean forced = scan.isForced();
+        List<PnfsId> replicas = new ArrayList<>();
+        QoSBatchedVerificationRequest request;
+
+        LOGGER.debug("handleQuery: (pool {})(group {})(storageUnit {})(type {})(forced {})",
+            pool, group, storageUnit, type, forced);
+
+        try {
+            if (CHECK_CUSTODIAL_ONLINE == type) {
+                statement = connection.prepareStatement(SQL_MISSING_ONLINE_CUSTODIAL);
+            } else {
+                statement = connection.prepareStatement(SQL_GET_ALL_FOR_LOCATION);
+                statement.setString(1, pool);
+            }
+            statement.setFetchSize(fetchSize);
+            if (scan.isCancelled()) {
+                return;
+            }
+
+            resultSet = statement.executeQuery();
+
+            while (resultSet.next() && !scan.isCancelled()) {
+                replicas.add(new PnfsId(resultSet.getString(1)));
+                scan.incrementCount();
+                if (replicas.size() >= fetchSize) {
+                    request = new QoSBatchedVerificationRequest(pool, replicas, type, group,
+                        storageUnit, forced);
+                    verificationListener.fileQoSVerificationRequested(request);
+                    replicas = new ArrayList<>();
+                }
+            }
+
+            if (!replicas.isEmpty() && !scan.isCancelled()) {
+                request = new QoSBatchedVerificationRequest(pool, replicas, type, group,
+                    storageUnit, forced);
+                verificationListener.fileQoSVerificationRequested(request);
+            }
+        } finally {
+            tryToClose(resultSet);
+            tryToClose(statement);
+        }
+    }
+
+    private void printResults(Connection connection, List<String> locations, PrintWriter writer)
+                    throws SQLException, InterruptedException {
+        String placeholders = String.join(",", locations.stream()
+                        .map(l -> "?").collect(Collectors.toList()));
+
+        String query = String.format(SQL_GET_CONTAINED_IN,
+                                     placeholders,
+                                     placeholders);
+
+        PreparedStatement statement = null;
+        ResultSet resultSet = null;
+        int len = locations.size();
+
+        try {
+            statement = connection.prepareStatement(query);
+            for (int i = 1; i <= len; ++i) {
+                statement.setString(i, locations.get(i-1));
+                statement.setString(i+len, locations.get(i-1));
+            }
+            statement.setFetchSize(fetchSize);
+
+            if (Thread.interrupted()) {
+                throw new InterruptedException();
+            }
+
+            LOGGER.info("executing {}.", statement);
+            resultSet = statement.executeQuery();
+
+            LOGGER.info("starting check of pnfsids for {}.", locations);
+
+            while (resultSet.next()) {
+                if (Thread.interrupted()) {
+                    throw new InterruptedException();
+                }
+
+                PnfsId pnfsId = new PnfsId(resultSet.getString(1));
+                writer.println(pnfsId);
+            }
+        } finally {
+            tryToClose(resultSet);
+            tryToClose(statement);
+        }
+
+        LOGGER.info("Printing of contained files for {} completed.", locations);
+    }
+}
diff --git a/modules/dcache-qos/src/main/java/org/dcache/qos/services/scanner/namespace/NamespaceAccess.java b/modules/dcache-qos/src/main/java/org/dcache/qos/services/scanner/namespace/NamespaceAccess.java
new file mode 100644
index 0000000000..5a5de6d816
--- /dev/null
+++ b/modules/dcache-qos/src/main/java/org/dcache/qos/services/scanner/namespace/NamespaceAccess.java
@@ -0,0 +1,105 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos.services.scanner.namespace;
+
+import diskCacheV111.namespace.NameSpaceProvider;
+import diskCacheV111.util.CacheException;
+import java.io.PrintWriter;
+import java.util.Collections;
+import java.util.EnumSet;
+import java.util.List;
+import java.util.Set;
+import javax.sql.DataSource;
+import org.dcache.namespace.FileAttribute;
+import org.dcache.qos.services.scanner.data.PoolScanSummary;
+
+/**
+ *  Specialized namespace API for scan handling.
+ */
+public interface NamespaceAccess {
+    Set<FileAttribute> LOCATION_ATTRIBUTES
+        = Collections.unmodifiableSet(EnumSet.of(FileAttribute.PNFSID, FileAttribute.LOCATIONS));
+
+    /**
+     *  The main query.
+     *
+     * @param scan for initializing scan and tracking progress.
+     *
+     * @throws CacheException
+     */
+    void handlePnfsidsForPool(PoolScanSummary scan) throws CacheException;
+
+    /**
+     *  Used by the admin command to create a file of all the pnfsids on a pool which
+     *  currently have replicas only on the pools in the list.
+     *
+     *  @param locations pool name.
+     *  @param printWriter to write the results to.
+     */
+    void printContainedInFiles(List<String> locations,
+                               PrintWriter printWriter)
+                    throws CacheException, InterruptedException;
+
+    void setConnectionPool(DataSource connectionPool);
+
+    void setFetchSize(int fetchSize);
+
+    void setNamespace(NameSpaceProvider namespace);
+}
diff --git a/modules/dcache-qos/src/main/java/org/dcache/qos/services/scanner/util/PoolScanTask.java b/modules/dcache-qos/src/main/java/org/dcache/qos/services/scanner/util/PoolScanTask.java
new file mode 100644
index 0000000000..2e187da6fa
--- /dev/null
+++ b/modules/dcache-qos/src/main/java/org/dcache/qos/services/scanner/util/PoolScanTask.java
@@ -0,0 +1,112 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos.services.scanner.util;
+
+import java.util.concurrent.Future;
+import org.dcache.pool.classic.Cancellable;
+import org.dcache.qos.data.QoSMessageType;
+import org.dcache.qos.services.scanner.data.PoolScanSummary;
+import org.dcache.qos.services.scanner.handlers.PoolOperationHandler;
+import org.dcache.qos.util.ErrorAwareTask;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ *  Executes call to scan a pool and dispatch verification requests.
+ */
+public final class PoolScanTask extends ErrorAwareTask implements Cancellable {
+    private static final Logger LOGGER = LoggerFactory.getLogger(PoolScanTask.class);
+
+    private final PoolOperationHandler handler;
+    private final PoolScanSummary scan;
+    private Future future;
+
+    public PoolScanTask(String pool,
+                        QoSMessageType type,
+                        String group,
+                        String storageUnit,
+                        boolean forced,
+                        PoolOperationHandler handler) {
+        scan = new PoolScanSummary(pool, type, group, storageUnit, forced);
+        this.handler = handler;
+    }
+
+    @Override
+    public Void call() {
+        if (!scan.isCancelled()) {
+            handler.handlePoolScan(scan);
+        }
+
+        return null;
+    }
+
+    @Override
+    public synchronized void cancel(String explanation) {
+        scan.setCancelled(true);
+        if (future != null) {
+            future.cancel(true);
+        }
+    }
+
+    public void submit() {
+        future = handler.getTaskService()
+                        .submit(createFireAndForgetTask());
+    }
+}
diff --git a/modules/dcache-qos/src/main/java/org/dcache/qos/services/scanner/util/QoSScannerCounters.java b/modules/dcache-qos/src/main/java/org/dcache/qos/services/scanner/util/QoSScannerCounters.java
new file mode 100644
index 0000000000..3b796fa4cd
--- /dev/null
+++ b/modules/dcache-qos/src/main/java/org/dcache/qos/services/scanner/util/QoSScannerCounters.java
@@ -0,0 +1,239 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos.services.scanner.util;
+
+import java.time.Instant;
+import java.util.HashMap;
+import java.util.concurrent.atomic.AtomicLong;
+import org.dcache.qos.data.PoolQoSStatus;
+import org.dcache.qos.util.QoSCounter;
+import org.dcache.qos.util.QoSCounterGroup;
+import org.dcache.qos.util.QoSCounters;
+
+import static org.dcache.qos.data.QoSMessageType.POOL_STATUS_DOWN;
+import static org.dcache.qos.data.QoSMessageType.POOL_STATUS_UP;
+
+public final class QoSScannerCounters extends QoSCounters {
+  private static final String SCANS          = "SCANS";
+  private static final String POOLS          = "POOLS";
+  private static final String FORMAT_SCANS = "%-25s %12s %12s\n";
+  private static final String FORMAT_DETAILS = "%-25s | %12s %12s | %12s %12s %12s | %12s %20s\n";
+  private static final String[] SCANS_HEADER = {"ACTION", "COMPLETED", "FAILED" };
+  private static final String[] DETAILS_HEADER = {"NAME", "TOTAL", "FAILED", "UP", "DOWN", "FORCED",
+                                                  "FILES", "AVGPRD (ms)"};
+  private static final String FORMAT_STATS = "%-15s  | %20s | %25s %8s %5s %12s %5s\n";
+  private static final String[] STATS_HEADER = {"EPOCH", "DATETIME", "POOL", "STATUS", "FORCED", "FILES", "FAILED"};
+
+  class QoSScanCounterGroup extends QoSCounterGroup<QoSCounter> {
+    protected QoSScanCounterGroup(String name) {
+      super(name);
+    }
+
+    @Override
+    public void toFormattedString(StringBuilder builder) {
+      getKeys().stream()
+               .forEach(k-> {
+                  QoSCounter c = getCounter(k);
+                  builder.append(String.format(FORMAT_SCANS, k, c.getTotal(), c.getFailed()));
+          });
+    }
+
+    @Override
+    protected QoSCounter createCounter(String key) {
+      return new QoSCounter(key);
+    }
+  }
+
+  class QoSPoolCounterGroup extends QoSCounterGroup<QoSPoolCounter> {
+    protected QoSPoolCounterGroup(String name) {
+      super(name);
+    }
+
+    @Override
+    public void toFormattedString(StringBuilder builder) {
+      getKeys().stream()
+          .forEach(k -> {
+              QoSPoolCounter c = getCounter(k);
+              long total = c.getTotal();
+              builder.append(String.format(FORMAT_DETAILS, k, c.getTotal(), c.getFailed(),
+                                            c.up.get(), c.down.get(), c.forced.get(), c.files.get(),
+                                            total == 0L ? 0L : c.interval.get()/total));
+          });
+    }
+
+    @Override
+    protected QoSPoolCounter createCounter(String key) {
+      return new QoSPoolCounter(key);
+    }
+  }
+
+  class QoSPoolCounter extends QoSCounter {
+    final AtomicLong canceled = new AtomicLong(0L);
+    final AtomicLong files = new AtomicLong(0L);
+    final AtomicLong forced = new AtomicLong(0L);
+    final AtomicLong down = new AtomicLong(0L);
+    final AtomicLong up = new AtomicLong(0L);
+    final AtomicLong interval = new AtomicLong(0L);
+
+    protected QoSPoolCounter(String name) {
+      super(name);
+    }
+  }
+
+  @Override
+  public void initialize() {
+    groupMap = new HashMap<>();
+    QoSCounterGroup group = new QoSScanCounterGroup(SCANS);
+    group.addCounter(POOL_STATUS_UP.name());
+    group.addCounter(POOL_STATUS_DOWN.name());
+    groupMap.put(SCANS, group);
+
+    group = new QoSPoolCounterGroup(POOLS);
+    groupMap.put(POOLS, group);
+  }
+
+  @Override
+  public void appendCounts(StringBuilder builder) {
+    builder.append(String.format(FORMAT_SCANS, SCANS_HEADER));
+    QoSCounterGroup group = groupMap.get(SCANS);
+    group.toFormattedString(builder);
+  }
+
+  @Override
+  public void appendDetails(StringBuilder builder) {
+    builder.append(String.format(FORMAT_DETAILS, DETAILS_HEADER));
+    QoSPoolCounterGroup group = (QoSPoolCounterGroup)groupMap.get(POOLS);
+    group.toFormattedString(builder);
+  }
+
+  public void incrementCancelled(String pool, PoolQoSStatus status,
+                                 long files, boolean forced, long sincePrevious) {
+    checkPoolCounters(pool);
+    QoSPoolCounterGroup poolCounterGroup = (QoSPoolCounterGroup)groupMap.get(POOLS);
+    QoSPoolCounter counter = poolCounterGroup.getCounter(pool);
+    update(counter, status == PoolQoSStatus.DOWN, files, forced, sincePrevious);
+    counter.canceled.incrementAndGet();
+  }
+
+  public void increment(String pool, PoolQoSStatus status, boolean failed,
+                        long files, boolean forced, long sincePrevious) {
+    boolean down = status == PoolQoSStatus.DOWN;
+
+    QoSCounterGroup group = groupMap.get(SCANS);
+    QoSCounter actionCounter
+        = group.getCounter(down ? POOL_STATUS_DOWN.name() : POOL_STATUS_UP.name());
+    actionCounter.incrementTotal();
+
+    checkPoolCounters(pool);
+    QoSPoolCounterGroup poolCounterGroup = (QoSPoolCounterGroup)groupMap.get(POOLS);
+    QoSPoolCounter counter = poolCounterGroup.getCounter(pool);
+
+    if (failed) {
+      actionCounter.incrementFailed();
+      counter.incrementFailed();
+    }
+
+    update(counter, down, files, forced, sincePrevious);
+    counter.incrementTotal();
+
+    if (toFile) {
+      Instant now = Instant.now();
+      synchronized (statisticsBuffer) {
+        statisticsBuffer.add(String.format(FORMAT_STATS, now.toEpochMilli(),
+            DATE_FORMATER.format(now), pool,
+            status.name(), forced, files, failed));
+      }
+    }
+  }
+
+  @Override
+  protected String getStatisticsFormat() {
+    return FORMAT_STATS;
+  }
+
+  @Override
+  protected String[] getStatisticsHeader() {
+    return STATS_HEADER;
+  }
+
+  private void checkPoolCounters(String pool) {
+    QoSPoolCounterGroup group = (QoSPoolCounterGroup)groupMap.get(POOLS);
+    if (!group.hasCounter(pool)) {
+      group.addCounter(pool);
+    }
+  }
+
+  private void update(QoSPoolCounter counter, boolean down, long files,
+                      boolean forced, long sincePrevious) {
+    if (down) {
+      counter.down.incrementAndGet();
+    } else {
+      counter.up.incrementAndGet();
+    }
+
+    counter.files.addAndGet(files);
+
+    if (forced) {
+      counter.forced.incrementAndGet();
+    }
+
+    counter.interval.addAndGet(sincePrevious);
+  }
+}
diff --git a/modules/dcache-qos/src/main/java/org/dcache/qos/services/scanner/util/ScannerMapInitializer.java b/modules/dcache-qos/src/main/java/org/dcache/qos/services/scanner/util/ScannerMapInitializer.java
new file mode 100644
index 0000000000..79e8a38a69
--- /dev/null
+++ b/modules/dcache-qos/src/main/java/org/dcache/qos/services/scanner/util/ScannerMapInitializer.java
@@ -0,0 +1,136 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos.services.scanner.util;
+
+import java.util.concurrent.TimeUnit;
+import org.dcache.qos.services.scanner.data.PoolOperationMap;
+import org.dcache.qos.services.scanner.handlers.PoolOpChangeHandler;
+import org.dcache.qos.util.MapInitializer;
+
+/**
+ *  Initialization sequence waits for the pool monitor, loads and initializes pool
+ *  operations, then enables messages and starts the pool scanner watchdog.
+ */
+public final class ScannerMapInitializer extends MapInitializer {
+    private PoolOperationMap         poolOperationMap;
+    private PoolOpChangeHandler      poolOpChangeHandler;
+
+    public synchronized void shutDown() {
+        LOGGER.info("Shutting down pool info change watchdog.");
+        poolOpChangeHandler.setEnabled(false);
+        poolOpChangeHandler.stopWatchdog();
+
+        if (poolOperationMap.isRunning()) {
+            LOGGER.info("Shutting down pool operation map.");
+            poolOperationMap.shutdown();
+        }
+
+        super.shutDown();
+    }
+
+    public void run() {
+        if (isInitialized()) {
+            return;
+        }
+
+        poolOpChangeHandler.setRefreshService(initService);
+        poolOpChangeHandler.setEnabled(true);
+
+        if (!waitForPoolMonitor()) {
+            return;
+        }
+
+        /*
+         *  Synchronous sequence of initialization procedures;
+         *  order must be maintained.
+         */
+        LOGGER.info("Loading pool operations.");
+        poolOperationMap.loadPools();
+
+        LOGGER.info("Pool maps reloaded; initializing ...");
+        poolOperationMap.initialize();
+
+        LOGGER.info("Pool maps initialized; delivering backlog.");
+        messageGuard.enable();
+
+        setInitialized();
+
+        LOGGER.info("Starting the periodic pool monitor refresh check.");
+        poolOpChangeHandler.startWatchdog();
+    }
+
+    public void setChangeHandler(PoolOpChangeHandler changeHandler) {
+        this.poolOpChangeHandler = changeHandler;
+    }
+
+    public void setPoolOperationMap(PoolOperationMap poolOperationMap) {
+        this.poolOperationMap = poolOperationMap;
+    }
+
+    @Override
+    protected long getRefreshTimeout() {
+        return poolOpChangeHandler.getRefreshTimeout();
+    }
+
+    @Override
+    protected TimeUnit getRefreshTimeoutUnit() {
+        return poolOpChangeHandler.getRefreshTimeoutUnit();
+    }
+}
