diff --git a/modules/dcache-qos/src/main/java/org/dcache/qos/local/clients/LocalQoSAdjustmentClient.java b/modules/dcache-qos/src/main/java/org/dcache/qos/local/clients/LocalQoSAdjustmentClient.java
new file mode 100644
index 0000000000..88aceef890
--- /dev/null
+++ b/modules/dcache-qos/src/main/java/org/dcache/qos/local/clients/LocalQoSAdjustmentClient.java
@@ -0,0 +1,88 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos.local.clients;
+
+import diskCacheV111.util.PnfsId;
+import org.dcache.qos.QoSException;
+import org.dcache.qos.listeners.QoSAdjustmentListener;
+import org.dcache.qos.services.adjuster.handlers.QoSAdjusterTaskHandler;
+import org.dcache.qos.vehicles.QoSAdjustmentRequest;
+
+/**
+ *  A pass-through to the adjuster task handler. Use this listener when plugging in directly to
+ *  the adjustment service.
+ */
+public final class LocalQoSAdjustmentClient implements QoSAdjustmentListener {
+  private QoSAdjusterTaskHandler taskHandler;
+
+  @Override
+  public void fileQoSAdjustmentRequested(QoSAdjustmentRequest adjustmentRequest) {
+      taskHandler.handleAdjustmentRequest(adjustmentRequest);
+  }
+
+  @Override
+  public void fileQoSAdjustmentCancelled(PnfsId pnfsId) throws QoSException {
+      taskHandler.handleAdjustmentCancelled(pnfsId);
+  }
+
+  public void setTaskHandler(QoSAdjusterTaskHandler taskHandler) {
+    this.taskHandler = taskHandler;
+  }
+}
diff --git a/modules/dcache-qos/src/main/java/org/dcache/qos/remote/receivers/QoSAdjustmentReceiver.java b/modules/dcache-qos/src/main/java/org/dcache/qos/remote/receivers/QoSAdjustmentReceiver.java
new file mode 100644
index 0000000000..c2b26b3c29
--- /dev/null
+++ b/modules/dcache-qos/src/main/java/org/dcache/qos/remote/receivers/QoSAdjustmentReceiver.java
@@ -0,0 +1,109 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos.remote.receivers;
+
+import diskCacheV111.util.PnfsId;
+import dmg.cells.nucleus.CellMessageReceiver;
+import org.dcache.qos.services.adjuster.handlers.QoSAdjusterTaskHandler;
+import org.dcache.qos.util.MessageGuard;
+import org.dcache.qos.util.MessageGuard.Status;
+import org.dcache.qos.vehicles.QoSAdjustmentCancelledMessage;
+import org.dcache.qos.vehicles.QoSAdjustmentRequestMessage;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ *  Implements message reception for remote adjustment service.
+ *  <p/>
+ *  If disabled manually, messages will be dropped.
+ */
+public final class QoSAdjustmentReceiver implements CellMessageReceiver {
+  private static final Logger ACTIVITY_LOGGER = LoggerFactory.getLogger("org.dcache.qos-log");
+
+  private MessageGuard messageGuard;
+  private QoSAdjusterTaskHandler taskHandler;
+
+  public void messageArrived(QoSAdjustmentRequestMessage message) {
+    ACTIVITY_LOGGER.info("Received request for adjustment of {}.", message.getRequest().getPnfsId());
+    if (messageGuard.getStatus("QoSAdjustmentRequestMessage", message)
+        == Status.DISABLED) {
+      return;
+    }
+    taskHandler.handleAdjustmentRequest(message.getRequest());
+  }
+
+  public void messageArrived(QoSAdjustmentCancelledMessage message) {
+    PnfsId pnfsId = message.getPnfsId();
+    ACTIVITY_LOGGER.info("Received cancelleation for adjustment of {}.", pnfsId);
+    if (messageGuard.getStatus("QoSAdjustmentCancelledMessage", message)
+        == Status.DISABLED) {
+      return;
+    }
+    taskHandler.handleAdjustmentCancelled(pnfsId);
+  }
+
+  public void setTaskHandler(QoSAdjusterTaskHandler taskHandler) {
+    this.taskHandler = taskHandler;
+  }
+
+  public void setMessageGuard(MessageGuard messageGuard) {
+    this.messageGuard = messageGuard;
+  }
+}
diff --git a/modules/dcache-qos/src/main/java/org/dcache/qos/services/adjuster/adjusters/CopyAdjuster.java b/modules/dcache-qos/src/main/java/org/dcache/qos/services/adjuster/adjusters/CopyAdjuster.java
new file mode 100644
index 0000000000..128234034b
--- /dev/null
+++ b/modules/dcache-qos/src/main/java/org/dcache/qos/services/adjuster/adjusters/CopyAdjuster.java
@@ -0,0 +1,155 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos.services.adjuster.adjusters;
+
+import diskCacheV111.vehicles.PoolManagerPoolInformation;
+import java.util.Collections;
+import java.util.List;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.stream.Collectors;
+import org.dcache.cells.CellStub;
+import org.dcache.pool.migration.PoolMigrationCopyFinishedMessage;
+import org.dcache.pool.migration.Task;
+import org.dcache.pool.migration.TaskParameters;
+import org.dcache.pool.repository.ReplicaState;
+import org.dcache.qos.services.adjuster.util.QoSAdjusterTask;
+import org.dcache.qos.services.adjuster.util.StaticSinglePoolList;
+import org.dcache.qos.services.adjuster.util.DegenerateSelectionStrategy;
+
+/**
+ *  Attempts to make a single copy of the file.  Uses a migration task which
+ *  sends a migration request to the pool's migration module.  While this
+ *  effectively relinquishes the task thread, the task state does not
+ *  change to completed until it receives a response from the module.
+ */
+public class CopyAdjuster extends QoSAdjuster {
+  protected Task migrationTask;
+
+  CellStub pinManager;
+  CellStub pools;
+  ScheduledExecutorService executorService;
+
+  @Override
+  public synchronized void cancel(String explanation) {
+    if (migrationTask != null) {
+      migrationTask.cancel(explanation);
+      completionHandler.taskCancelled(migrationTask.getPnfsId());
+    }
+  }
+
+  public void relayMessage(PoolMigrationCopyFinishedMessage message) {
+    migrationTask.messageArrived(message);
+  }
+
+  @Override
+  protected void runAdjuster(QoSAdjusterTask task) {
+    createTask(task.getTargetInfo(), task.getSource());
+    migrationTask.run();
+  }
+
+  protected void createTask(TaskParameters taskParameters, String source) {
+    migrationTask = new Task(taskParameters,
+        completionHandler,
+        source,
+        pnfsId,
+        ReplicaState.CACHED,
+        ONLINE_STICKY_RECORD,
+        Collections.EMPTY_LIST,
+        attributes,
+        attributes.getAccessTime());
+  }
+
+  /**
+   *  Wraps the creation of a migration {@link Task}.  The task is given
+   *  a static single pool list and a degenerate selection strategy,
+   *  since the target has already been selected.
+   */
+  private synchronized void createTask(PoolManagerPoolInformation targetInfo, String source) {
+    LOGGER.debug("Configuring migration task for {}, {}.", pnfsId, action);
+
+    StaticSinglePoolList list = new StaticSinglePoolList(targetInfo);
+
+    TaskParameters taskParameters = new TaskParameters( pools,
+                                                  null,     // PnfsManager cell stub not used
+                                                        pinManager,
+                                                        executorService,
+                                                        new DegenerateSelectionStrategy(),
+                                                        list,
+                                                false,   // eager; update should not happen
+                                             false,   // just move the metadata; not relevant here
+                                false,   // compute checksum on update; should not happen
+                                         false,   // force copy even if pool is not readable
+                                           true,    // maintain atime
+                                                1);      // only one copy per task
+
+    createTask(taskParameters, source);
+
+    if (ACTIVITY_LOGGER.isInfoEnabled()) {
+      List<String> allPools = list.getPools().stream()
+                                             .map(PoolManagerPoolInformation::getName)
+                                             .collect(Collectors.toList());
+      ACTIVITY_LOGGER.info("Initiating migration for {} of {} from {} to"
+              + " pools: {}, offline: {}", action, pnfsId, source, allPools, list.getOfflinePools());
+    }
+
+    LOGGER.debug("Created migration task for {} of {}: source {}, list {}.",
+        action, pnfsId, source, list);
+  }
+}
diff --git a/modules/dcache-qos/src/main/java/org/dcache/qos/services/adjuster/adjusters/FlushAdjuster.java b/modules/dcache-qos/src/main/java/org/dcache/qos/services/adjuster/adjusters/FlushAdjuster.java
new file mode 100644
index 0000000000..daa1f46d50
--- /dev/null
+++ b/modules/dcache-qos/src/main/java/org/dcache/qos/services/adjuster/adjusters/FlushAdjuster.java
@@ -0,0 +1,90 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos.services.adjuster.adjusters;
+
+import java.util.Collections;
+import org.dcache.pool.migration.Task;
+import org.dcache.pool.migration.TaskParameters;
+import org.dcache.pool.repository.ReplicaState;
+
+/**
+ *  This adjustment usually will be in response to a user/admin request to
+ *  change a disk-only file to tape, but could also involve an initial write
+ *  of a CUSTODIAL file which did not land on an HSM pool.  A suitable HSM pool
+ *  will have been found by the verification service.
+ *  <p/>
+ *  As with its parent, task state does not change to completed until it receives a response
+ *  from the module.  However, in the case of FLUSH, this response occurs immediately
+ *  after the file has either been copied or its PRECIOUS bit has been set.
+ */
+public final class FlushAdjuster extends CopyAdjuster {
+  @Override
+  protected void createTask(TaskParameters taskParameters, String source) {
+    migrationTask = new Task(taskParameters,
+                             completionHandler,
+                             source,
+                             pnfsId,
+        ReplicaState.PRECIOUS,
+        Collections.EMPTY_LIST,
+        Collections.EMPTY_LIST,
+        attributes,
+        attributes.getAccessTime());
+  }
+}
diff --git a/modules/dcache-qos/src/main/java/org/dcache/qos/services/adjuster/adjusters/QoSAdjuster.java b/modules/dcache-qos/src/main/java/org/dcache/qos/services/adjuster/adjusters/QoSAdjuster.java
new file mode 100644
index 0000000000..cf6186b2fe
--- /dev/null
+++ b/modules/dcache-qos/src/main/java/org/dcache/qos/services/adjuster/adjusters/QoSAdjuster.java
@@ -0,0 +1,106 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos.services.adjuster.adjusters;
+
+import com.google.common.collect.ImmutableList;
+import diskCacheV111.util.PnfsId;
+import org.dcache.pool.classic.Cancellable;
+import org.dcache.pool.repository.StickyRecord;
+import org.dcache.qos.data.QoSAction;
+import org.dcache.qos.services.adjuster.handlers.QoSAdjustTaskCompletionHandler;
+import org.dcache.qos.services.adjuster.util.QoSAdjusterTask;
+import org.dcache.qos.util.MessageGuard;
+import org.dcache.vehicles.FileAttributes;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ *  Parent class for adjusters. Generates a QOS session id for the remote messaging
+ *  to identify events originating here.
+ */
+public abstract class QoSAdjuster implements Cancellable {
+  protected static final Logger LOGGER = LoggerFactory.getLogger(QoSAdjuster.class);
+  protected static final Logger ACTIVITY_LOGGER = LoggerFactory.getLogger("org.dcache.qos-log");
+  protected static final ImmutableList<StickyRecord> ONLINE_STICKY_RECORD
+      = ImmutableList.of(new StickyRecord("system", StickyRecord.NON_EXPIRING));
+
+  protected PnfsId pnfsId;
+  protected FileAttributes attributes;
+  protected QoSAction action;
+  protected QoSAdjustTaskCompletionHandler completionHandler;
+
+  public void adjustQoS(QoSAdjusterTask task) {
+    pnfsId = task.getPnfsId();
+    action = task.getAction();
+    attributes = task.getAttributes();
+
+    /*
+     *  Generate the SESSION ID.   This is used by the QoS status endpoint
+     *  (requirements listener or QoS engine) to exclude location updates
+     *  which result from copies or actions initiated here (an optimization
+     *  so as not to resend redundant verification requests).
+     */
+    MessageGuard.setQoSSession();
+
+    runAdjuster(task);
+  }
+
+  protected abstract void runAdjuster(QoSAdjusterTask task);
+}
diff --git a/modules/dcache-qos/src/main/java/org/dcache/qos/services/adjuster/adjusters/QoSAdjusterFactory.java b/modules/dcache-qos/src/main/java/org/dcache/qos/services/adjuster/adjusters/QoSAdjusterFactory.java
new file mode 100644
index 0000000000..a40082aea5
--- /dev/null
+++ b/modules/dcache-qos/src/main/java/org/dcache/qos/services/adjuster/adjusters/QoSAdjusterFactory.java
@@ -0,0 +1,152 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos.services.adjuster.adjusters;
+
+import java.util.concurrent.ScheduledExecutorService;
+import org.dcache.cells.CellStub;
+import org.dcache.qos.data.QoSAction;
+import org.dcache.qos.services.adjuster.handlers.QoSAdjustTaskCompletionHandler;
+
+/**
+ *  Provides the adjuster corresponding to the adjustment activity to the task.
+ *  Injects the necessary endpoints, handlers and executors.
+ */
+public final class QoSAdjusterFactory {
+  private CellStub pinManager;
+  private CellStub pools;
+
+  /**
+   *  Should be CDC-preserving so as to pass on the QOS session id.
+   */
+  private ScheduledExecutorService scheduledExecutor;
+  private QoSAdjustTaskCompletionHandler completionHandler;
+
+  public QoSAdjusterBuilder newBuilder() {
+    return new QoSAdjusterBuilder();
+  }
+
+  public void setPinManager(CellStub pinManager) {
+    this.pinManager = pinManager;
+  }
+
+  public void setPools(CellStub pools) {
+    this.pools = pools;
+  }
+
+  public void setCompletionHandler(QoSAdjustTaskCompletionHandler completionHandler) {
+    this.completionHandler = completionHandler;
+  }
+
+  public void setScheduledExecutor(ScheduledExecutorService scheduledExecutor) {
+    this.scheduledExecutor = scheduledExecutor;
+  }
+
+  public class QoSAdjusterBuilder {
+    private QoSAction action;
+
+    private QoSAdjusterBuilder() {
+    }
+
+    public QoSAdjusterBuilder of(QoSAction action) {
+      this.action = action;
+      return this;
+    }
+
+    public QoSAdjuster build() {
+      if (action == null) {
+        throw new IllegalStateException("QoSAdjuster action was null.  This is a bug.");
+      }
+
+      switch (action) {
+        case COPY_REPLICA:
+          CopyAdjuster copyAdjuster = new CopyAdjuster();
+          copyAdjuster.completionHandler = completionHandler;
+          copyAdjuster.executorService = scheduledExecutor;
+          copyAdjuster.pinManager = pinManager;
+          copyAdjuster.pools = pools;
+          return copyAdjuster;
+        case FLUSH:
+          FlushAdjuster flushAdjuster = new FlushAdjuster();
+          flushAdjuster.completionHandler = completionHandler;
+          flushAdjuster.executorService = scheduledExecutor;
+          flushAdjuster.pinManager = pinManager;
+          flushAdjuster.pools = pools;
+          return flushAdjuster;
+        case WAIT_FOR_STAGE:
+          StagingAdjuster stagingAdjuster = new StagingAdjuster();
+          stagingAdjuster.completionHandler = completionHandler;
+          stagingAdjuster.executorService = scheduledExecutor;
+          stagingAdjuster.pinManager = pinManager;
+          return stagingAdjuster;
+        case CACHE_REPLICA:
+        case PERSIST_REPLICA:
+        case UNSET_PRECIOUS_REPLICA:
+          ReplicaStateAdjuster stateAdjuster = new ReplicaStateAdjuster();
+          stateAdjuster.completionHandler = completionHandler;
+          stateAdjuster.executorService = scheduledExecutor;
+          stateAdjuster.pools = pools;
+          return stateAdjuster;
+        default:
+          throw new IllegalStateException("QoSAdjuster action of unknown type " + action
+              + ".  This is a bug.");
+      }
+    }
+  }
+}
diff --git a/modules/dcache-qos/src/main/java/org/dcache/qos/services/adjuster/adjusters/ReplicaStateAdjuster.java b/modules/dcache-qos/src/main/java/org/dcache/qos/services/adjuster/adjusters/ReplicaStateAdjuster.java
new file mode 100644
index 0000000000..c158aa1395
--- /dev/null
+++ b/modules/dcache-qos/src/main/java/org/dcache/qos/services/adjuster/adjusters/ReplicaStateAdjuster.java
@@ -0,0 +1,178 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos.services.adjuster.adjusters;
+
+import diskCacheV111.util.CacheException;
+import diskCacheV111.util.PnfsId;
+import diskCacheV111.vehicles.Message;
+import dmg.cells.nucleus.CellPath;
+import java.util.Optional;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Future;
+import org.dcache.cells.CellStub;
+import org.dcache.qos.data.QoSAction;
+import org.dcache.qos.services.adjuster.handlers.QoSAdjustTaskCompletionHandler;
+import org.dcache.qos.services.adjuster.util.QoSAdjusterTask;
+import org.dcache.qos.util.CacheExceptionUtils;
+import org.dcache.util.CacheExceptionFactory;
+import org.dcache.vehicles.qos.ChangePreciousBitMessage;
+import org.dcache.vehicles.qos.ChangeStickyBitMessage;
+
+import static org.dcache.qos.services.adjuster.handlers.QoSAdjustTaskCompletionHandler.FAILED_STATE_CHANGE_MESSAGE;
+
+/**
+ *  Changes the sticky bit on the replica in question in response to the need for
+ *  another permanent replica or from the discovery of an excess permanent replica.
+ *  Task is synchronous (waits for reply).
+ */
+public final class ReplicaStateAdjuster extends QoSAdjuster {
+  CellStub pools;
+  ExecutorService executorService;
+  QoSAdjustTaskCompletionHandler completionHandler;
+
+  private PnfsId pnfsId;
+  private String target;
+  private QoSAction action;
+  private Future<Message> future;
+
+  @Override
+  protected void runAdjuster(QoSAdjusterTask task) {
+    pnfsId = task.getPnfsId();
+    target = task.getTarget();
+    action = task.getAction();
+
+    executorService.submit(() -> {
+      sendMessageToRepository();
+      waitForReply();
+    });
+  }
+
+  @Override
+  public synchronized void cancel(String explanation) {
+    if (future != null) {
+      future.cancel(true);
+    }
+  }
+
+  private synchronized void sendMessageToRepository() {
+    Message msg;
+    switch (action) {
+      case UNSET_PRECIOUS_REPLICA:
+        msg = new ChangePreciousBitMessage(target, pnfsId);
+        break;
+      case PERSIST_REPLICA:
+        msg = new ChangeStickyBitMessage(target, pnfsId, true);
+        break;
+      case CACHE_REPLICA:
+        msg = new ChangeStickyBitMessage(target, pnfsId, false);
+        break;
+      default:
+        throw new RuntimeException("ReplicaStateAdjuster does not handle "
+            + action +"; this is a bug.");
+    }
+
+    LOGGER.debug("Sending {} message to {} for {}.", action, target, pnfsId);
+    ACTIVITY_LOGGER.info("Sending {} message to {} for {}.", action, target, pnfsId);
+    future = pools.send(new CellPath(target), msg);
+  }
+
+  private void waitForReply() {
+    synchronized (this) {
+      if (future == null) {
+        completionHandler.taskFailed(pnfsId, Optional.empty(),
+                                     new CacheException(CacheException.SERVICE_UNAVAILABLE,
+                                                        "no future returned by message send."));
+        return;
+      }
+    }
+
+    CacheException exception = null;
+    Message msg = null;
+
+    try {
+      LOGGER.debug("Waiting for {} reply for {} from {}.", action, pnfsId, target);
+      msg = future.get();
+    } catch (InterruptedException | ExecutionException e) {
+      exception = CacheExceptionUtils.getCacheException(CacheException.SELECTED_POOL_FAILED,
+                                                        FAILED_STATE_CHANGE_MESSAGE,
+                                                        pnfsId,
+                                                        action,
+                                                        target,
+                                                        e);
+    }
+
+    LOGGER.debug("Calling completion handler for {} reply for {} from {}.", action, pnfsId, target);
+
+    if (exception != null) {
+      completionHandler.taskFailed(pnfsId, Optional.empty(), exception);
+      return;
+    }
+
+    exception = msg.getErrorObject() == null ? null : CacheExceptionFactory.exceptionOf(msg);
+
+    if (exception != null && !CacheExceptionUtils.replicaNotFound(exception)) {
+      completionHandler.taskFailed(pnfsId, Optional.empty(), exception);
+      return;
+    }
+
+    completionHandler.taskCompleted(pnfsId, Optional.empty());
+  }
+}
diff --git a/modules/dcache-qos/src/main/java/org/dcache/qos/services/adjuster/adjusters/StagingAdjuster.java b/modules/dcache-qos/src/main/java/org/dcache/qos/services/adjuster/adjusters/StagingAdjuster.java
new file mode 100644
index 0000000000..4e34c0e28d
--- /dev/null
+++ b/modules/dcache-qos/src/main/java/org/dcache/qos/services/adjuster/adjusters/StagingAdjuster.java
@@ -0,0 +1,203 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos.services.adjuster.adjusters;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import diskCacheV111.util.CacheException;
+import diskCacheV111.vehicles.HttpProtocolInfo;
+import diskCacheV111.vehicles.ProtocolInfo;
+import java.net.InetSocketAddress;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.util.Optional;
+import java.util.concurrent.CancellationException;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.TimeUnit;
+import org.dcache.cells.CellStub;
+import org.dcache.pinmanager.PinManagerPinMessage;
+import org.dcache.pinmanager.PinManagerUnpinMessage;
+import org.dcache.qos.services.adjuster.util.QoSAdjusterTask;
+import org.dcache.qos.util.CacheExceptionUtils;
+import org.dcache.vehicles.FileAttributes;
+
+import static com.google.common.util.concurrent.Uninterruptibles.getUninterruptibly;
+
+/**
+ *  Sends message to pin manager to pin file, triggering a stage.
+ *  Task is synchronous (waits for reply).
+ */
+public final class StagingAdjuster extends QoSAdjuster {
+  private static final  String             QOS_PIN_REQUEST_ID = "qos";
+  private static final  long               QOS_PIN_TEMP_LIFETIME = TimeUnit.SECONDS.toMillis(30);
+
+  private static ProtocolInfo getProtocolInfo() throws URISyntaxException {
+    return new HttpProtocolInfo("Http",
+        1,
+        1,
+        new InetSocketAddress("localhost", 0),
+        null,
+        null,
+        null,
+        new URI("http",
+            "localhost",
+            null,
+            null));
+  }
+
+  CellStub pinManager;
+  ExecutorService executorService;
+
+  private String poolGroup;
+  private FileAttributes attributes;
+  private ListenableFuture<PinManagerPinMessage> future;
+
+  @Override
+  protected void runAdjuster(QoSAdjusterTask task) {
+    poolGroup = task.getPoolGroup();
+    attributes = task.getAttributes();
+    executorService.submit(() -> {
+      handleStaging();
+      waitForStaging();
+    });
+  }
+
+  @Override
+  public synchronized void cancel(String explanation) {
+    if (future != null) {
+      future.cancel(true);
+      cancelPin();
+    }
+  }
+
+  /**
+   *  Called when there are no available replicas, but the file can be retrieved from an HSM.
+   *  Issues a request.>
+   */
+  private synchronized void handleStaging() {
+    LOGGER.debug("handleStaging {}, pool group {}.", pnfsId, poolGroup);
+    try {
+      ACTIVITY_LOGGER.info("Staging {}", pnfsId);
+      PinManagerPinMessage message = new PinManagerPinMessage(attributes,
+                                                              getProtocolInfo(),
+                                                              QOS_PIN_REQUEST_ID,
+                                                              QOS_PIN_TEMP_LIFETIME);
+      future = pinManager.send(message, Long.MAX_VALUE);
+      LOGGER.debug("handleStaging, sent pin manager request for {}.", pnfsId);
+    } catch (URISyntaxException e) {
+      completionHandler.taskFailed(pnfsId, Optional.empty(),
+                                   CacheExceptionUtils.getCacheException(CacheException.INVALID_ARGS,
+                                        "could not construct HTTP protocol: %s.",
+                                         pnfsId,
+                                         action,
+                                         e.getMessage(),
+                                         null));
+      }
+  }
+
+  private void cancelPin() {
+    LOGGER.debug("handleStaging, cancelling pin {}.", pnfsId);
+    ACTIVITY_LOGGER.info("handleStaging, cancelling pin {}", pnfsId);
+    PinManagerUnpinMessage message = new PinManagerUnpinMessage(pnfsId);
+    pinManager.send(message, Long.MAX_VALUE);
+    LOGGER.debug("handleStaging, sent pin manager request to unpin {}.", pnfsId);
+  }
+
+  private void waitForStaging() {
+    synchronized (this) {
+      if (future == null) {
+        completionHandler.taskFailed(pnfsId, Optional.empty(),
+                                     new CacheException(CacheException.SERVICE_UNAVAILABLE,
+                                     "no future returned by message send."));
+        return;
+      }
+    }
+
+    PinManagerPinMessage migrationReply = null;
+    Object error = null;
+
+    try {
+      LOGGER.debug("handleStaging, waiting for pin request future for {}.", pnfsId);
+      migrationReply = getUninterruptibly(future);
+      if (migrationReply.getReturnCode() != 0) {
+        error = migrationReply.getErrorObject();
+      }
+    } catch (CancellationException e) {
+      /*
+       *  Cancelled state set by caller.
+       */
+    } catch (ExecutionException e) {
+      error = e.getCause();
+    }
+
+    LOGGER.debug("handleStaging, calling completion handler for {}.", pnfsId);
+    String target = migrationReply.getPool();
+
+    if (error == null) {
+      completionHandler.taskCompleted(pnfsId, Optional.ofNullable(target));
+    } else if (error instanceof Throwable) {
+      completionHandler.taskFailed(pnfsId, Optional.ofNullable(target),
+          new CacheException("Pin failure", (Throwable) error));
+    } else {
+      completionHandler.taskFailed(pnfsId, Optional.ofNullable(target),
+          new CacheException(String.valueOf(error)));
+    }
+  }
+}
diff --git a/modules/dcache-qos/src/main/java/org/dcache/qos/services/adjuster/admin/QoSAdjusterAdmin.java b/modules/dcache-qos/src/main/java/org/dcache/qos/services/adjuster/admin/QoSAdjusterAdmin.java
new file mode 100644
index 0000000000..8fe03cd6a7
--- /dev/null
+++ b/modules/dcache-qos/src/main/java/org/dcache/qos/services/adjuster/admin/QoSAdjusterAdmin.java
@@ -0,0 +1,484 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos.services.adjuster.admin;
+
+import com.google.common.base.Strings;
+import dmg.cells.nucleus.CellCommandListener;
+import dmg.util.command.Argument;
+import dmg.util.command.Command;
+import dmg.util.command.Option;
+import java.util.Arrays;
+import java.util.Set;
+import java.util.concurrent.TimeUnit;
+import java.util.function.Predicate;
+import java.util.regex.Pattern;
+import java.util.stream.Collectors;
+import org.dcache.qos.data.QoSAction;
+import org.dcache.qos.services.adjuster.data.QoSAdjusterTaskMap;
+import org.dcache.qos.services.adjuster.util.QoSAdjusterCounters;
+import org.dcache.qos.services.adjuster.util.QoSAdjusterTask;
+import org.dcache.qos.util.InitializerAwareCommand;
+import org.dcache.qos.util.MapInitializer;
+import org.dcache.qos.util.MessageGuard;
+import org.dcache.qos.util.QoSHistory;
+
+public final class QoSAdjusterAdmin implements CellCommandListener {
+
+  abstract class FilteredAdjusterTaskCommand extends InitializerAwareCommand {
+    @Option(name = "action",
+        valueSpec = "COPY_REPLICA|CACHE_REPLICA|PERSIST_REPLICA|WAIT_FOR_STAGE|FLUSH",
+        usage = "Match only operations for files with this action type.")
+    protected QoSAction action;
+
+    @Option(name = "state",
+        valueSpec = "INITIALIZED|RUNNING|CANCELLED|DONE",
+        separator = ",",
+        usage = "Match only operations for files matching this comma-delimited set of states; "
+            + "default is RUNNING.")
+    protected String[] state = {"RUNNING"};
+
+    @Option(name = "group",
+        usage = "Match only operations with this preferred pool group; use the option with no "
+            + "value to match only operations without a specified group.")
+    protected String poolGroup;
+
+    @Option(name = "source",
+        usage = "Match only operations with this source pool name; use the option with no value "
+            + "to match only operations without a source pool.")
+    protected String source;
+
+    @Option(name = "target",
+        usage = "Match only operations with this target pool name; use the option with no value "
+            + "to match only operations without a target pool.")
+    protected String target;
+
+    @Option(name = "retry",
+        usage = "Match only the operation with this number of retries.")
+    protected Integer retry;
+
+    @Option(name = "startedBefore",
+        valueSpec = FORMAT_STRING,
+        usage = "Match only operations whose start time is before this date-time.")
+    protected String startedBefore;
+
+    @Option(name = "startedAfter",
+        valueSpec = FORMAT_STRING,
+        usage = "Match only operations whose start time is after this date-time.")
+    protected String startedAfter;
+
+    @Argument(required = false,
+        usage = "Match only activities for this comma-delimited list of pnfsids. '*' "
+            + "matches all operations.")
+    protected String pnfsids;
+
+    protected FilteredAdjusterTaskCommand() {
+      super(initializer);
+    }
+
+    protected Predicate<QoSAdjusterTask> getFilter() {
+      Pattern grpPattern = poolGroup == null ? null : Pattern.compile(poolGroup);
+      Pattern srcPattern = source == null ? null : Pattern.compile(source);
+      Pattern tgtPattern = target == null ? null : Pattern.compile(target);
+
+      Set<String> stateSet;
+      if (state == null) {
+        stateSet = null;
+      } else {
+        stateSet = Arrays.stream(state).collect(Collectors.toSet());
+      }
+
+      Set<String> pnfsIdSet;
+      if (pnfsids == null || pnfsids.equals("*")) {
+        pnfsIdSet = null;
+      } else {
+        pnfsIdSet = Arrays.stream(pnfsids.split(",")).collect(Collectors.toSet());
+      }
+
+      Long before = startedBefore == null ? null : getTimestamp(startedBefore);
+      Long after = startedAfter == null ? null : getTimestamp(startedAfter);
+
+      Predicate<QoSAdjusterTask> matchesAction = (task) -> action == null
+          || action == task.getAction();
+
+      Predicate<QoSAdjusterTask> matchesState = (task) -> stateSet == null
+          || stateSet.contains(task.getStatusName());
+
+      Predicate<QoSAdjusterTask> matchesGroup = (task) -> grpPattern == null
+          || grpPattern.matcher(Strings.nullToEmpty(task.getPoolGroup())).find();
+
+      Predicate<QoSAdjusterTask> matchesSource = (task) -> srcPattern == null
+          || srcPattern.matcher(Strings.nullToEmpty(task.getSource())).find();
+
+      Predicate<QoSAdjusterTask> matchesTarget = (task) -> tgtPattern == null
+          || tgtPattern.matcher(Strings.nullToEmpty(task.getTarget())).find();
+
+      Predicate<QoSAdjusterTask> matchesRetry = (task) -> retry == null
+          || task.getRetry() == retry;
+
+      Predicate<QoSAdjusterTask> matchesPnfsIds = (task) -> pnfsIdSet == null
+          || pnfsIdSet.contains(task.getPnfsId().toString());
+
+      Predicate<QoSAdjusterTask> matchesBefore = (task) -> before == null
+          || task.getStartTime() <= before;
+
+      Predicate<QoSAdjusterTask> matchesAfter = (task) -> after == null
+          || task.getStartTime() >= after;
+
+      return matchesBefore.and(matchesAfter)
+                          .and(matchesAction)
+                          .and(matchesState)
+                          .and(matchesGroup)
+                          .and(matchesSource)
+                          .and(matchesTarget)
+                          .and(matchesRetry)
+                          .and(matchesPnfsIds);
+    }
+  }
+
+  @Command(name = "task cancel",
+      hint = "cancel adjuster tasks ",
+      description = "Scans the file table and cancels tasks matching the filter parameters.")
+  class TaskCancelCommand extends FilteredAdjusterTaskCommand {
+
+    @Override
+    protected String doCall() {
+      if (pnfsids == null) {
+        return "To cancel you must specify one or more pnfsids, or '*' for all matching pnfsids.";
+      }
+
+      taskMap.cancel(getFilter());
+      return "Issued cancel command to cancel file operations.";
+    }
+  }
+
+  @Command(name = "task ctrl",
+      hint = "control  handling of tasks",
+      description = "Turn processing of task on or off "
+          + "(start/shutdown), wake up the queue, or display info relevant to queue processing. "
+          + "NOTE that the max number of running tasks must be reset through properties "
+          + "(with domain restart) as it is also used to initialize the thread pool.")
+  class TaskControlCommand extends InitializerAwareCommand {
+    @Argument(valueSpec = "START|SHUTDOWN|RESET|RUN|INFO",
+        required = false,
+        usage = "info = information (default); reset = reset properties; start = (re)start "
+            + "processing of file operations; shutdown = stop all processing of file operations; "
+            + "run = wake up queue." )
+    String arg = "INFO";
+
+    @Option(name = "sweep",
+        usage = "With reset mode. Minimal interval between sweeps of the task queues.")
+    Long sweep;
+
+    @Option(name = "unit",
+        valueSpec = "SECONDS|MINUTES|HOURS",
+        usage = "sweep interval unit.")
+    TimeUnit unit;
+
+    @Option(name = "retries",
+        usage = "Maximum number of retries on a failed operation.")
+    Integer retries;
+
+    private ControlMode mode;
+
+    TaskControlCommand() {
+      super(initializer);
+    }
+
+    @Override
+    public String call() {
+      mode = ControlMode.valueOf(arg.toUpperCase());
+      if (mode == ControlMode.START) {
+        new Thread(() -> startAll()).start();
+        return "Consumer initialization started.";
+      }
+      return super.call();
+    }
+
+    @Override
+    protected String doCall() throws Exception {
+      switch (mode) {
+        case SHUTDOWN:
+          shutdownAll();
+          return "Consumer has been shutdown.";
+        case RUN:
+          if (!taskMap.isRunning()) {
+            return "Consumer is not running.";
+          }
+          taskMap.signalAll();
+          return "Woke up consumer.";
+        case RESET:
+          if (sweep != null) {
+            taskMap.setTimeout(sweep);
+          }
+
+          if (unit != null) {
+            taskMap.setTimeoutUnit(unit);
+          }
+
+          if (retries != null) {
+            taskMap.setMaxRetries(retries);
+          }
+
+          taskMap.signalAll();
+          // fall through here
+        case INFO:
+        default:
+          StringBuilder builder = new StringBuilder();
+          taskMap.getInfo(builder);
+          return builder.toString();
+      }
+    }
+  }
+
+  @Command(name = "task details",
+           hint = "list diagnostic information concerning tasks by pool",
+      description = "Gives task counts by activity and role (source, target).")
+  class TaskDetailsCommand extends InitializerAwareCommand {
+    TaskDetailsCommand() { super(initializer); }
+
+    @Override
+    protected String doCall() throws Exception {
+      StringBuilder builder = new StringBuilder();
+      counters.appendDetails(builder);
+      return builder.toString();
+    }
+  }
+
+  @Command(name = "task history",
+      hint = "display a history of the most recent terminated file operations",
+      description = "When file operations complete or are aborted, their string representations "
+          + "are added to a circular buffer whose capacity is set by the property "
+          + "'qos.limits.file.operation-history'.")
+  class TaskHistoryCommand extends InitializerAwareCommand {
+    @Argument(required = false, valueSpec = "errors", usage = "Display just the failures.")
+    String errors;
+
+    @Option(name = "limit", usage = "Display up to this number of entries.")
+    Integer limit;
+
+    @Option(name = "order", valueSpec = "ASC|DESC",
+            usage = "Display entries in ascending (default) or descending order of arrival.")
+    String order = "ASC";
+
+    TaskHistoryCommand() {
+      super(initializer);
+    }
+
+    @Override
+    protected String doCall() throws Exception {
+      boolean failed = false;
+      if (errors != null) {
+        if (!"errors".equals(errors)) {
+          return  "Optional argument must be 'errors'";
+        }
+        failed = true;
+      }
+
+      SortOrder order = SortOrder.valueOf(this.order.toUpperCase());
+
+      switch (order) {
+        case DESC:
+          if (limit != null) {
+            return history.descending(failed, limit);
+          }
+          return history.descending(failed);
+        default:
+          if (limit != null) {
+            return history.ascending(failed, limit);
+          }
+          return history.ascending(failed);
+      }
+    }
+  }
+
+  @Command(name = "task ls",
+      hint = "list entries in the adjuster task table",
+      description = "Scans the table and returns tasks matching the filter parameters.")
+  class TaskLsCommand extends FilteredAdjusterTaskCommand {
+
+    @Option(name = "count", usage="Do not list, but return only the number of matches.")
+    boolean count = false;
+
+    @Option(name = "limit",
+        usage = "Maximum number of rows to list.  This option becomes required when "
+            + "the operation queues reach " + LS_THRESHOLD + "; be aware that "
+            + "listing more than this number of rows may provoke an out of memory "
+            + "error for the domain.")
+    protected Integer limit;
+
+    @Override
+    protected String doCall() throws Exception {
+      Predicate<QoSAdjusterTask> filter = getFilter();
+      if (count) {
+        return taskMap.count(filter) + " matching pnfsids";
+      } else {
+        if (limit == null) {
+          int size = taskMap.size();
+          if ((state == null || Arrays.asList(state).contains("WAITING"))
+              && size >= LS_THRESHOLD) {
+            return String.format(REQUIRE_LIMIT, size, size);
+          }
+        }
+        return taskMap.list(filter, limit == null ? Integer.MAX_VALUE : limit);
+      }
+    }
+  }
+
+  @Command(name = "task stats", hint = "print diagnostic statistics history",
+      description = "Reads in the contents of the diagnostic history file recording task statistics.")
+  class TaskStatsCommand extends InitializerAwareCommand {
+    @Option(name = "offset", usage = "Start at this line number.")
+    Integer offset = 0;
+
+    @Option(name = "limit", usage = "Display up to this number of lines (default is 5000).")
+    Integer limit = 5000;
+
+    @Option(name = "order", valueSpec = "asc|desc",
+            usage = "Display lines in ascending (default) or descending order by timestamp.")
+    String order = "asc";
+
+    @Option(name = "enable", usage = "Turn the recording of statistics to file on or off (default).")
+    Boolean enable = null;
+
+    TaskStatsCommand() {
+      super(initializer);
+    }
+
+    protected String doCall() throws Exception {
+      if (enable != null) {
+        counters.setToFile(enable);
+        return "Recording to file is now " + (enable ? "on." : "off.");
+      }
+
+      SortOrder order = SortOrder.valueOf(this.order.toUpperCase());
+      StringBuilder builder = new StringBuilder();
+      counters.readStatistics(builder, offset, limit, order == SortOrder.DESC);
+      return builder.toString();
+    }
+  }
+
+  class NoPMapInitializer extends MapInitializer {
+    NoPMapInitializer() {
+      setInitialized();
+    }
+
+    public boolean initialize() {
+      if (isInitialized()) {
+        return false;
+      }
+      setInitialized();
+      return true;
+    }
+
+    @Override
+    public void run() {
+    }
+
+    @Override
+    protected long getRefreshTimeout() {
+      return 0;
+    }
+
+    @Override
+    protected TimeUnit getRefreshTimeoutUnit() {
+      return TimeUnit.MILLISECONDS;
+    }
+  }
+
+  private final MapInitializer initializer = new NoPMapInitializer();
+
+  private MessageGuard messageGuard;
+  private QoSHistory history;
+  private QoSAdjusterCounters counters;
+  private QoSAdjusterTaskMap taskMap;
+
+  public void setHistory(QoSHistory history) {
+    this.history = history;
+  }
+
+  public void setCounters(QoSAdjusterCounters counters) {
+    this.counters = counters;
+  }
+
+  public void setMessageGuard(MessageGuard messageGuard) {
+    this.messageGuard = messageGuard;
+  }
+
+  public void setTaskMap(QoSAdjusterTaskMap taskMap) {
+    this.taskMap = taskMap;
+  }
+
+  private void startAll() {
+    initializer.initialize();
+    if (taskMap.isRunning()) {
+      taskMap.shutdown();
+    }
+    taskMap.initialize();
+    messageGuard.enable();
+  }
+
+  private void shutdownAll() {
+    if (taskMap.isRunning()) {
+      taskMap.shutdown();
+    }
+    messageGuard.disable(true);
+    initializer.shutDown();
+  }
+}
diff --git a/modules/dcache-qos/src/main/java/org/dcache/qos/services/adjuster/data/QoSAdjusterTaskMap.java b/modules/dcache-qos/src/main/java/org/dcache/qos/services/adjuster/data/QoSAdjusterTaskMap.java
new file mode 100644
index 0000000000..085fabbaba
--- /dev/null
+++ b/modules/dcache-qos/src/main/java/org/dcache/qos/services/adjuster/data/QoSAdjusterTaskMap.java
@@ -0,0 +1,513 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos.services.adjuster.data;
+
+import com.google.common.annotations.VisibleForTesting;
+import diskCacheV111.util.CacheException;
+import diskCacheV111.util.PnfsId;
+import dmg.cells.nucleus.CellInfoProvider;
+import java.io.PrintWriter;
+import java.util.ArrayList;
+import java.util.Deque;
+import java.util.List;
+import java.util.Map;
+import java.util.Optional;
+import java.util.Queue;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.LinkedBlockingDeque;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+import java.util.function.Predicate;
+import java.util.stream.Collectors;
+import javax.annotation.concurrent.GuardedBy;
+import org.dcache.pool.migration.PoolMigrationCopyFinishedMessage;
+import org.dcache.qos.services.adjuster.adjusters.QoSAdjusterFactory;
+import org.dcache.qos.services.adjuster.handlers.QoSAdjusterTaskHandler;
+import org.dcache.qos.services.adjuster.util.QoSAdjusterCounters;
+import org.dcache.qos.services.adjuster.util.QoSAdjusterTask;
+import org.dcache.qos.util.QoSHistory;
+import org.dcache.qos.vehicles.QoSAdjustmentRequest;
+import org.dcache.util.RunnableModule;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ *  Manages adjuster tasks that are submitted from the verification service.
+ */
+public final class QoSAdjusterTaskMap extends RunnableModule implements CellInfoProvider {
+    private static final Logger LOGGER = LoggerFactory.getLogger(QoSAdjusterTaskMap.class);
+    private static final String MISSING_ENTRY = "Entry for {} was removed from map before "
+        + "completion of outstanding task.";
+
+    private static final int RUNNING = 0;
+    private static final int READY = 1;
+
+    private final ReadWriteLock lock   = new ReentrantReadWriteLock(true);
+    private final Lock          write  = lock.writeLock();
+    private final Lock          read   = lock.readLock();
+
+    private final Map<String, QoSAdjusterTask> index = new ConcurrentHashMap<>();
+    private final Deque<QoSAdjusterTask>[] queues
+        = new Deque[]{
+                            new LinkedBlockingDeque<>(),  // RUNNING
+                            new LinkedBlockingDeque<>(),  // READY
+                     };
+    private final AtomicLong signalled = new AtomicLong(0L);
+
+    private QoSAdjusterFactory factory;
+    private QoSAdjusterCounters counters;
+    private QoSHistory history;
+
+    private ScheduledExecutorService executorService;
+
+    /*
+     *  A callback.  Note that this creates a cyclical dependency in the spring context.
+     *  The rationale here is that the map controls the terminal logic for adjustment
+     *  tasks on a single thread, and thus needs to notify other components (such
+     *  as the verifier) of termination.  It makes sense that only the
+     *  handler would communicate with the "outside", and that the map should
+     *  be internal to this service.
+     */
+    private QoSAdjusterTaskHandler taskHandler;
+
+    /*
+     *  Note that this throttle is necessary.  Staging adjustments and migration tasks
+     *  relinguish the thread, so we cannot rely on the thread pool to put a barrier
+     *  on the number of concurrent (or "waiting") jobs.
+     */
+    private int maxRunning = 200;
+
+    /**
+     *   Meaning for a given source-target pair (i.e., this task).  The verifier
+     *   will retry new pairings if possible and resubmit the task request.
+     */
+    private int maxRetries = 1;
+
+    public void cancel(PnfsId pnfsId) {
+        write.lock();
+        try {
+            QoSAdjusterTask task = index.get(pnfsId.toString());
+            if (task != null) {
+                LOGGER.debug("TaskMap cancel {}", pnfsId);
+                task.cancel("Cancelled by admin/user.");
+            }
+        } finally {
+            write.unlock();
+        }
+
+        signalAll();
+    }
+
+    /**
+     *  Used by admin command.
+     */
+    public void cancel(Predicate<QoSAdjusterTask> filter) {
+        write.lock();
+        try {
+            index.values().stream().filter(filter).forEach(task -> {
+                if (task != null) {
+                    task.cancel("Cancelled by admin/user.");
+                }
+            });
+        } finally {
+            write.unlock();
+        }
+
+        signalAll();
+    }
+
+    /**
+     *  Used by admin command.
+     */
+    public long count(Predicate<QoSAdjusterTask> filter) {
+        read.lock();
+        try {
+            return index.values().stream().filter(filter).count();
+        } finally {
+            read.unlock();
+        }
+    }
+
+    @Override
+    public void getInfo(PrintWriter pw) {
+        StringBuilder builder = new StringBuilder();
+        getInfo(builder);
+        pw.println(builder.toString());
+    }
+
+    /**
+     *  Used by admin command.
+     */
+    public void getInfo(StringBuilder builder) {
+        counters.appendRunning(builder);
+        counters.appendSweep(builder);
+        builder.append("maximum running tasks:     ").append(maxRunning).append("\n");
+        builder.append("maximum number of retries: ").append(maxRetries).append("\n\n");
+        counters.appendCounts(builder);
+    }
+
+    public void initialize() {
+        super.initialize();
+        LOGGER.info("Adjuster task map initialized.");
+    }
+
+    /*
+     *  Testing only.
+     */
+    @VisibleForTesting
+    public List<QoSAdjusterTask> getTasks(Predicate<QoSAdjusterTask> filter, int limit) {
+        read.lock();
+        try {
+            return index.values().stream()
+                                 .filter(filter)
+                                 .limit(limit)
+                                 .collect(Collectors.toList());
+        } finally {
+            read.unlock();
+        }
+    }
+
+    /**
+     *  Used by admin command.
+     */
+    public String list(Predicate<QoSAdjusterTask> filter, int limit) {
+        StringBuilder builder = new StringBuilder();
+        AtomicInteger total = new AtomicInteger(0);
+
+        read.lock();
+        try {
+            index.values().stream()
+                .filter(filter)
+                .limit(limit)
+                .forEach(t -> {
+                    builder.append(t).append("\n");
+                    total.incrementAndGet();
+                });
+        } finally {
+            read.unlock();
+        }
+
+        if (total.get() == 0) {
+            builder.append("NO (MATCHING) TASKS.\n");
+        } else {
+            builder.append("TOTAL TASKS:\t\t").append(total.get()).append("\n");
+        }
+        return builder.toString();
+    }
+
+    public void register(QoSAdjustmentRequest request) {
+        QoSAdjusterTask task = new QoSAdjusterTask(request, factory);
+        LOGGER.debug("register task {}: {}", request.getPnfsId(), task);
+        write.lock();
+        try {
+            if (!add(task.getPnfsId(), task)) {
+                LOGGER.error("received request for {} but a task for this file is already registered.",
+                                task.getPnfsId());
+            }
+        } finally {
+            write.unlock();
+        }
+
+        signalAll();
+    }
+
+    /**
+     *  The consumer thread. When notified or times out, runs scan.
+     *  <p/>
+     *  Note that since the scan takes place outside of the monitor, the
+     *  signals sent by various update methods will not be caught before
+     *  the current thread is inside {@link #await}; for this reason, a
+     *  counter is used and reset to 0 before each scan. No wait occurs if
+     *  the counter is non-zero after the scan.
+     */
+    public void run() {
+        try {
+            while (!Thread.interrupted()) {
+                LOGGER.trace("Calling scan.");
+
+                signalled.set(0);
+                long start = System.currentTimeMillis();
+
+                scan();
+
+                long end = System.currentTimeMillis();
+                counters.recordSweep(end, end-start);
+
+                if (signalled.get() > 0) {
+                    /*
+                     *  Give the operations completed during the scan a chance
+                     *  to free slots immediately, if possible, by rescanning now.
+                     */
+                    LOGGER.trace("Scan complete, received {} signals; "
+                                    + "rechecking for requeued operations ...",
+                                    signalled.get());
+                    continue;
+                }
+
+                if (Thread.interrupted()) {
+                    break;
+                }
+
+                LOGGER.trace("Scan complete, waiting ...");
+                await();
+            }
+        } catch (InterruptedException e) {
+            LOGGER.trace("Consumer was interrupted.");
+        }
+
+        LOGGER.trace("Exiting file operation consumer.");
+        clear();
+
+        LOGGER.trace("File operation queues and index cleared.");
+    }
+
+    /**
+     *  Iterates over the queues to check the state of running tasks and to submit
+     *  waiting tasks if there are open slots.  Removes completed tasks.
+     */
+    @VisibleForTesting
+    public void scan() {
+        write.lock();
+        try {
+            final List<QoSAdjusterTask> toRemove = new ArrayList<>();
+            /*
+             *  Check both queues in case of cancellation.
+             */
+            for (Queue<QoSAdjusterTask> queue : queues) {
+                queue.stream().filter(QoSAdjusterTask::isDone)
+                              .forEach(t -> {
+                                                toRemove.add(t);
+                                                handleTerminatedTask(t);
+                });
+
+                toRemove.stream().forEach(queue::remove);
+                toRemove.clear();
+            }
+
+            int available = maxRunning - queues[RUNNING].size();
+
+            QoSAdjusterTask task;
+
+            while ((task = queues[READY].poll()) != null && available > 0) {
+                queues[RUNNING].add(task);
+                submit(task);
+                --available;
+            }
+        } finally {
+            write.unlock();
+        }
+    }
+
+    public void setCounters(QoSAdjusterCounters counters) {
+        this.counters = counters;
+    }
+
+    public void setFactory(QoSAdjusterFactory factory) {
+        this.factory = factory;
+    }
+
+    public void setExecutorService(ScheduledExecutorService executorService) {
+        this.executorService = executorService;
+    }
+
+    public void setHistory(QoSHistory history) {
+        this.history = history;
+    }
+
+    public void setMaxRetries(int maxRetries) {
+        this.maxRetries = maxRetries;
+    }
+
+    public void setMaxRunning(int maxRunning) {
+        this.maxRunning = maxRunning;
+    }
+
+    public void setHandler(QoSAdjusterTaskHandler taskHandler) {
+        this.taskHandler = taskHandler;
+    }
+
+    @Override
+    public void shutdown() {
+        LOGGER.info("Adjuster task map shutting down ...");
+        super.shutdown();
+    }
+
+    /**
+     *  <p>Also used by admin command.</p>
+     */
+    public synchronized void signalAll() {
+        signalled.incrementAndGet();
+        notifyAll();
+    }
+
+    public int size() {
+        read.lock();
+        try {
+            return index.size();
+        } finally {
+            read.unlock();
+        }
+    }
+
+    /**
+     *  Migration task termination.
+     *  <p/>
+     *  This call will bottom out in the completion handler finally calling
+     *  #updateTask(PnfsId, CacheException).  It is there that the callback
+     *  message is triggered.
+     */
+    public void updateTask(PoolMigrationCopyFinishedMessage message) {
+        PnfsId pnfsId = message.getPnfsId();
+        read.lock();
+        try {
+            QoSAdjusterTask task = index.get(pnfsId.toString());
+            if (task == null) {
+                /*
+                 *  Treat the missing entry benignly,
+                 *  as it is possible to have a race between removal
+                 *  from forced cancellation and the arrival of the task
+                 *  callback.
+                 */
+                LOGGER.warn(MISSING_ENTRY, pnfsId);
+            } else {
+                task.relayMessage(message);
+            }
+        } finally {
+            read.unlock();
+        }
+    }
+
+    /**
+     *  Calls task terminated.
+     *
+     *  @param pnfsId of the file undergoing adjustment.
+     *  @param target an optional target update (this is used only by staging, where the pool
+     *               manager selects the pool via the pin manager).
+     *  @param exception
+     */
+    public void updateTask(PnfsId pnfsId, Optional<String> target, CacheException exception) {
+        QoSAdjusterTask task;
+
+        read.lock();
+        try {
+            task = index.get(pnfsId.toString());
+            if (task == null) {
+                /*
+                 *  Treat the missing entry benignly,
+                 *  as it is possible to have a race between removal
+                 *  from forced cancellation and the arrival of the task
+                 *  callback.
+                 */
+                LOGGER.warn(MISSING_ENTRY, pnfsId);
+            } else {
+                task.taskTerminated(target, exception);
+            }
+        } finally {
+            read.unlock();
+        }
+
+        signalAll();
+    }
+
+    @GuardedBy("write")
+    private boolean add(PnfsId pnfsId, QoSAdjusterTask task) {
+        String key = pnfsId.toString();
+        if (index.containsKey(key)) {
+            return false;
+        }
+        index.put(key, task);
+        queues[READY].add(task);
+        return true;
+    }
+
+    private synchronized void await() throws InterruptedException {
+        wait(timeoutUnit.toMillis(timeout));
+    }
+
+    private synchronized void clear() {
+        queues[RUNNING].clear();
+        queues[READY].clear();
+        index.clear();
+    }
+
+    private void handleTerminatedTask(QoSAdjusterTask task) {
+        int retry = task.getRetry();
+        if (task.getException() != null && retry < maxRetries) {
+            LOGGER.debug("TaskMap handleTerminatedTask, readding {}", task.getPnfsId());
+            task = new QoSAdjusterTask(task, retry + 1);
+            index.put(task.getPnfsId().toString(), task);
+            queues[READY].add(task);
+        } else {
+            LOGGER.debug("TaskMap handleTerminatedTask, removing {}", task.getPnfsId());
+            index.remove(task.getPnfsId().toString());
+            history.add(task.getPnfsId(), task.toHistoryString(), task.getException() != null);
+            counters.recordTask(task);
+            taskHandler.notifyAdjustmentCompleted(task);
+        }
+    }
+
+    private void submit(QoSAdjusterTask task) {
+        task.setFuture(executorService.submit(task.createFireAndForgetTask()));
+    }
+}
\ No newline at end of file
diff --git a/modules/dcache-qos/src/main/java/org/dcache/qos/services/adjuster/handlers/QoSAdjustTaskCompletionHandler.java b/modules/dcache-qos/src/main/java/org/dcache/qos/services/adjuster/handlers/QoSAdjustTaskCompletionHandler.java
new file mode 100644
index 0000000000..b903d907d8
--- /dev/null
+++ b/modules/dcache-qos/src/main/java/org/dcache/qos/services/adjuster/handlers/QoSAdjustTaskCompletionHandler.java
@@ -0,0 +1,143 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos.services.adjuster.handlers;
+
+import diskCacheV111.util.CacheException;
+import diskCacheV111.util.PnfsId;
+import java.util.Optional;
+import org.dcache.pool.migration.Task;
+import org.dcache.pool.migration.TaskCompletionHandler;
+import org.dcache.qos.data.QoSAction;
+import org.dcache.qos.services.adjuster.data.QoSAdjusterTaskMap;
+import org.dcache.qos.util.CacheExceptionUtils;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ *  Implements the handling of adjuster task termination.
+ *  Also implements the migration task termination logic.
+ */
+public final class QoSAdjustTaskCompletionHandler implements TaskCompletionHandler {
+    public static final String FAILED_COPY_MESSAGE
+                    = "Migration task for %s failed. %s%s.";
+
+    public static final String FAILED_STATE_CHANGE_MESSAGE
+                    = "Failed to change %s to %s; %s. ";
+
+    private static final Logger LOGGER
+                    = LoggerFactory.getLogger(QoSAdjustTaskCompletionHandler.class);
+
+    private QoSAdjusterTaskMap map;
+
+    public void setMap(QoSAdjusterTaskMap map) {
+        this.map = map;
+    }
+
+    @Override
+    public void taskCancelled(Task task) {
+        taskCancelled(task.getPnfsId());
+    }
+
+    public void taskCancelled(PnfsId pnfsId) {
+        LOGGER.debug("{}, Task cancelled.", pnfsId);
+        map.cancel(pnfsId);
+    }
+
+    public void taskCompleted(PnfsId pnfsId, Optional<String> target) {
+        LOGGER.debug("{}. Task completed.", pnfsId);
+        map.updateTask(pnfsId, target, null);
+    }
+
+    @Override
+    public void taskCompleted(Task task) {
+        LOGGER.debug("Migration Task for {} completed successfully.", task.getPnfsId());
+        taskCompleted(task.getPnfsId(), Optional.empty());
+    }
+
+    public void taskFailed(PnfsId pnfsId, Optional<String> target, CacheException exception) {
+        LOGGER.debug("{}, Task failed: {}.", pnfsId, exception.getMessage());
+        map.updateTask(pnfsId, target, exception);
+    }
+
+    @Override
+    public void taskFailed(Task task, int rc, String msg) {
+        LOGGER.debug("Migration task {} failed.", task.getPnfsId());
+        PnfsId pnfsId = task.getPnfsId();
+        CacheException exception = CacheExceptionUtils.getCacheException(rc,
+                                                                         FAILED_COPY_MESSAGE,
+                                                                         pnfsId,
+                                                                         QoSAction.COPY_REPLICA,
+                                                                         msg,
+                                                                         null);
+        taskFailed(pnfsId, Optional.empty(), exception);
+    }
+
+    /**
+     *  Permanent failures do not receive special treatment, since, for example,
+     *  the file not found on the source can at times be an ephemeral error.
+     *  <p/>
+     *  Delegates to #taskFailed(Task task, int rc, String msg)
+     *  to decide what should be done.
+     */
+    @Override
+    public void taskFailedPermanently(Task task, int rc, String msg) {
+        taskFailed(task, rc, msg);
+    }
+}
diff --git a/modules/dcache-qos/src/main/java/org/dcache/qos/services/adjuster/handlers/QoSAdjusterTaskHandler.java b/modules/dcache-qos/src/main/java/org/dcache/qos/services/adjuster/handlers/QoSAdjusterTaskHandler.java
new file mode 100644
index 0000000000..6a1b570370
--- /dev/null
+++ b/modules/dcache-qos/src/main/java/org/dcache/qos/services/adjuster/handlers/QoSAdjusterTaskHandler.java
@@ -0,0 +1,152 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos.services.adjuster.handlers;
+
+import diskCacheV111.util.PnfsId;
+import dmg.cells.nucleus.CellMessageReceiver;
+import java.util.concurrent.ExecutorService;
+import org.dcache.pool.migration.PoolMigrationCopyFinishedMessage;
+import org.dcache.qos.QoSException;
+import org.dcache.qos.data.QoSAction;
+import org.dcache.qos.data.QoSAdjustmentStatus;
+import org.dcache.qos.listeners.QoSVerificationListener;
+import org.dcache.qos.services.adjuster.data.QoSAdjusterTaskMap;
+import org.dcache.qos.services.adjuster.util.QoSAdjusterTask;
+import org.dcache.qos.vehicles.QoSAdjustmentRequest;
+import org.dcache.qos.vehicles.QoSAdjustmentResponse;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ *  Registers the request in the map as a new task.  Also serves to relay
+ *  completion messages to the task from the migration module.  Relays completion
+ *  of the task to the verification endpoint.
+ */
+public final class QoSAdjusterTaskHandler implements CellMessageReceiver {
+  private static final Logger LOGGER = LoggerFactory.getLogger(QoSAdjusterTaskHandler.class);
+
+  private QoSAdjusterTaskMap taskMap;
+  private ExecutorService taskService;
+  private QoSVerificationListener verificationListener;
+
+  public void handleAdjustmentRequest(QoSAdjustmentRequest request) {
+    LOGGER.debug("handleAdjustmentRequest for {}, {}", request.getPnfsId(), request.getAction());
+    taskService.submit(() -> {
+        LOGGER.debug("handleAdjustmentRequest, registering request for {}, {}",
+            request.getPnfsId(), request.getAction());
+        taskMap.register(request);
+    });
+  }
+
+  public void handleAdjustmentCancelled(PnfsId pnfsId) {
+    LOGGER.debug("handleAdjustmentCancelled for {}", pnfsId);
+    taskService.submit(() -> {
+      LOGGER.debug("handleAdjustmentCancelled, calling cancel on taskMap for {}", pnfsId);
+      taskMap.cancel(pnfsId);
+    });
+  }
+
+  public void notifyAdjustmentCompleted(QoSAdjusterTask task) {
+    QoSAdjustmentStatus status;
+
+    if (task.isCancelled()) {
+      status = QoSAdjustmentStatus.CANCELLED;
+    } else if (task.getException() != null) {
+      status = QoSAdjustmentStatus.FAILED;
+    } else {
+      status = QoSAdjustmentStatus.COMPLETED;
+    }
+
+    PnfsId pnfsId = task.getPnfsId();
+    QoSAction action = task.getAction();
+    Throwable error = task.getException();
+
+    QoSAdjustmentResponse response = new QoSAdjustmentResponse();
+    response.setAction(action);
+    response.setPnfsId(pnfsId);
+    response.setStatus(status);
+    response.setError(error);
+
+    try {
+      LOGGER.debug("notifying adjustment completed for {}, {}, {}: {}.",
+          pnfsId, action, status, error);
+      verificationListener.fileQoSAdjustmentCompleted(response);
+    } catch (QoSException e) {
+      LOGGER.error("could not notify adjustment completed for {}, {}, {}, {}: {}.",
+          pnfsId, action, status, error, e.toString());
+    }
+  }
+
+  public void messageArrived(PoolMigrationCopyFinishedMessage message) {
+    taskService.submit(() -> taskMap.updateTask(message));
+  }
+
+  public void setTaskMap(QoSAdjusterTaskMap taskMap) {
+    this.taskMap = taskMap;
+  }
+
+  public void setTaskService(ExecutorService taskService) {
+    this.taskService = taskService;
+  }
+
+  public void setVerificationListener(QoSVerificationListener verificationListener) {
+    this.verificationListener = verificationListener;
+  }
+}
diff --git a/modules/dcache-qos/src/main/java/org/dcache/qos/services/adjuster/util/DegenerateSelectionStrategy.java b/modules/dcache-qos/src/main/java/org/dcache/qos/services/adjuster/util/DegenerateSelectionStrategy.java
new file mode 100644
index 0000000000..72ebffc726
--- /dev/null
+++ b/modules/dcache-qos/src/main/java/org/dcache/qos/services/adjuster/util/DegenerateSelectionStrategy.java
@@ -0,0 +1,84 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos.services.adjuster.util;
+
+import diskCacheV111.vehicles.PoolManagerPoolInformation;
+import java.util.List;
+import javax.annotation.Nullable;
+import org.dcache.pool.migration.PoolSelectionStrategy;
+import org.dcache.pool.migration.Task;
+
+/**
+ *  Simply returns the single member of the list.
+ *  <p/>
+ *  The reason for its existence is so that the verification handler can preselect the source
+ *  and target pools, but still make use of the migration module {@link Task}, which requires
+ *  an implementation of {@link PoolSelectionStrategy} to be provided.
+ */
+public final class DegenerateSelectionStrategy implements PoolSelectionStrategy {
+    @Nullable
+    @Override
+    public PoolManagerPoolInformation select(List<PoolManagerPoolInformation> pools) {
+        if (pools.isEmpty()) {
+            return null;
+        }
+        return pools.get(0);
+    }
+}
diff --git a/modules/dcache-qos/src/main/java/org/dcache/qos/services/adjuster/util/QoSAdjusterCounters.java b/modules/dcache-qos/src/main/java/org/dcache/qos/services/adjuster/util/QoSAdjusterCounters.java
new file mode 100644
index 0000000000..3b5dda075d
--- /dev/null
+++ b/modules/dcache-qos/src/main/java/org/dcache/qos/services/adjuster/util/QoSAdjusterCounters.java
@@ -0,0 +1,295 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos.services.adjuster.util;
+
+import java.time.Instant;
+import java.util.HashMap;
+import java.util.concurrent.atomic.AtomicLong;
+import org.dcache.qos.data.QoSAction;
+import org.dcache.qos.util.QoSCounter;
+import org.dcache.qos.util.QoSCounterGroup;
+import org.dcache.qos.util.QoSCounters;
+
+import static org.dcache.qos.data.QoSAction.CACHE_REPLICA;
+import static org.dcache.qos.data.QoSAction.COPY_REPLICA;
+import static org.dcache.qos.data.QoSAction.FLUSH;
+import static org.dcache.qos.data.QoSAction.PERSIST_REPLICA;
+import static org.dcache.qos.data.QoSAction.UNSET_PRECIOUS_REPLICA;
+import static org.dcache.qos.data.QoSAction.WAIT_FOR_STAGE;
+
+public final class QoSAdjusterCounters extends QoSCounters {
+  private static final String ACTIONS        = "ACTIONS";
+  private static final String POOLS          = "POOLS";
+  private static final String FORMAT_ACTIONS = "%-26s %12s %12s\n";
+  private static final String FORMAT_DETAILS = "%-28s | %12s %12s | %12s %12s %12s | %12s %12s %12s "
+                                                  + "| %12s %12s\n";
+  private static final String FORMAT_STAT
+      = "%-15s %37s | %15s | %25s %25s | %25s %25s | %9s seconds | %15s\n";
+  private static final String[] ACTIONS_HEADER = {"ACTION", "TOTAL", "FAILED"};
+  private static final String[] DETAILS_HEADER = {"POOL", "TGT", "FAILED", "CPSRC", "CPTGT", "CPBYT",
+                                                  "CACHE", "PERSIST", "UNSETP", "STAGE", "FLUSH"};
+  private static final String[] STATS_HEADER = {"END", "ID", "ACTION", "START", "END",
+                                                "SRC", "TGT", "DURATION", "FAILURE"};
+
+  class QoSAdjustCounter extends QoSCounter {
+    final AtomicLong copySrc = new AtomicLong(0L);
+    final AtomicLong copyTgt = new AtomicLong(0L);
+    final AtomicLong copyByt = new AtomicLong(0L);
+    final AtomicLong cacheTgt = new AtomicLong(0L);
+    final AtomicLong persistTgt = new AtomicLong(0L);
+    final AtomicLong unsetTgt = new AtomicLong(0L);
+    final AtomicLong stageTgt = new AtomicLong(0L);
+    final AtomicLong flushTgt = new AtomicLong(0L);
+
+    public QoSAdjustCounter(String name) {
+      super(name);
+    }
+  }
+
+  class QoSAdjustCounterGroup extends QoSCounterGroup<QoSCounter> {
+    protected QoSAdjustCounterGroup(String name) {
+      super(name);
+    }
+
+    @Override
+    public void toFormattedString(StringBuilder builder) {
+      getKeys().stream()
+          .forEach(k-> {
+            QoSCounter c = getCounter(k);
+            builder.append(String.format(FORMAT_ACTIONS, k, c.getTotal(), c.getFailed()));
+          });
+    }
+
+    @Override
+    protected QoSCounter createCounter(String key) {
+      return new QoSCounter(key);
+    }
+  }
+
+  class QoSAdjustDetailsCounterGroup extends QoSCounterGroup<QoSAdjustCounter> {
+    protected QoSAdjustDetailsCounterGroup(String name) {
+      super(name);
+    }
+
+    @Override
+    public void toFormattedString(StringBuilder builder) {
+      getKeys().stream()
+          .forEach(k-> {
+            QoSAdjustCounter c = getCounter(k);
+            builder.append(String.format(FORMAT_DETAILS, k, c.getTotal(), c.getFailed(),
+                c.copySrc.get(), c.copyTgt.get(), formatWithPrefix(c.copyByt.get()),
+                c.cacheTgt.get(), c.persistTgt.get(), c.unsetTgt.get(), c.stageTgt.get(),
+                c.flushTgt.get()));
+          });
+    }
+
+    @Override
+    protected QoSAdjustCounter createCounter(String key) {
+      return new QoSAdjustCounter(key);
+    }
+  }
+
+  @Override
+  public void initialize() {
+    groupMap = new HashMap<>();
+    QoSCounterGroup group = new QoSAdjustCounterGroup(ACTIONS);
+    group.addCounter(COPY_REPLICA.name());
+    group.addCounter(CACHE_REPLICA.name());
+    group.addCounter(PERSIST_REPLICA.name());
+    group.addCounter(UNSET_PRECIOUS_REPLICA.name());
+    group.addCounter(WAIT_FOR_STAGE.name());
+    group.addCounter(FLUSH.name());
+    groupMap.put(ACTIONS, group);
+
+    group = new QoSAdjustDetailsCounterGroup(POOLS);
+    groupMap.put(POOLS, group);
+  }
+
+  @Override
+  public void appendCounts(StringBuilder builder) {
+    builder.append(String.format(FORMAT_ACTIONS, ACTIONS_HEADER));
+    QoSCounterGroup group = groupMap.get(ACTIONS);
+    group.toFormattedString(builder);
+  }
+
+  @Override
+  public void appendDetails(StringBuilder builder) {
+    builder.append(String.format(FORMAT_DETAILS, DETAILS_HEADER));
+    QoSCounterGroup group = groupMap.get(POOLS);
+    group.toFormattedString(builder);
+  }
+
+  public void recordTask(QoSAdjusterTask task) {
+    if (task == null) {
+      LOGGER.debug("recordTaskStatistics called with null task");
+      return;
+    }
+
+    boolean failed = task.getException() != null;
+    QoSAction action = task.getAction();
+    QoSCounter actionCounter = groupMap.get(ACTIONS).getCounter(action.name());
+    actionCounter.incrementTotal();
+    if (failed) {
+      actionCounter.incrementFailed();
+    }
+
+    if (toFile) {
+      synchronized(statisticsBuffer) {
+        statisticsBuffer.add(toFormatted(task));
+      }
+    }
+
+    String target = task.getTarget();
+    if (target == null) {
+      /*
+       *  NB.  This is possible if this is a staging task which was cancelled.
+       */
+      LOGGER.debug("{}, no target", task);
+      return;
+    }
+
+    checkPoolCounters(target);
+    QoSAdjustCounter targetCounter = (QoSAdjustCounter)groupMap.get(POOLS).getCounter(target);
+
+    /*
+     *  Count total and failed only on target pools.
+     */
+    targetCounter.incrementTotal();
+    if (failed) {
+      targetCounter.incrementFailed();
+    }
+
+    switch (action) {
+      case COPY_REPLICA:
+        targetCounter.copyTgt.incrementAndGet();
+        targetCounter.copyByt.addAndGet(task.getAttributes().getSize());
+        String source = task.getSource();
+        if (source == null) {
+          LOGGER.debug("{} no source ... could be a potential bug?", task);
+          return;
+        }
+        checkPoolCounters(source);
+        QoSAdjustCounter srcCounter = (QoSAdjustCounter)groupMap.get(POOLS).getCounter(source);
+        srcCounter.copySrc.incrementAndGet();
+        break;
+      case UNSET_PRECIOUS_REPLICA:
+        targetCounter.unsetTgt.incrementAndGet();
+        break;
+      case CACHE_REPLICA:
+        targetCounter.cacheTgt.incrementAndGet();
+        break;
+      case PERSIST_REPLICA:
+        targetCounter.persistTgt.incrementAndGet();
+        break;
+      case FLUSH:
+        targetCounter.flushTgt.incrementAndGet();
+        break;
+      case WAIT_FOR_STAGE:
+        targetCounter.stageTgt.incrementAndGet();
+        break;
+      default:
+        LOGGER.debug("{} UNKNOWN ACTION?", task);
+        break;
+    }
+  }
+
+  @Override
+  protected String getStatisticsFormat() {
+    return FORMAT_STAT;
+  }
+
+  @Override
+  protected String[] getStatisticsHeader() {
+    return STATS_HEADER;
+  }
+
+  private void checkPoolCounters(String pool) {
+    QoSAdjustDetailsCounterGroup group = (QoSAdjustDetailsCounterGroup)groupMap.get(POOLS);
+    if (!group.hasCounter(pool)) {
+      group.addCounter(pool);
+    }
+  }
+
+  private String toFormatted(QoSAdjusterTask task) {
+    String source = task.getSource();
+    String target = task.getTarget();
+    long startTime = task.getStartTime();
+    long endTime = task.getEndTime();
+    Exception exception = task.getException();
+    return String.format(FORMAT_STAT,
+        endTime,
+        task.getPnfsId(),
+        task.getAction(),
+        DATE_FORMATER.format(Instant.ofEpochMilli(startTime)),
+        DATE_FORMATER.format(Instant.ofEpochMilli(endTime)),
+        source == null ? "-----" : source,
+        target == null ? "-----" : target,
+        getTimeInSeconds(endTime-startTime),
+        exception == null ? task.getStatus() : task.getStatus() + ": " + exception.toString());
+  }
+
+  private static String getTimeInSeconds(long elapsed) {
+    if (elapsed < 0) {
+      return "-----";
+    }
+    double delta = ((double)elapsed)/(1000.0);
+    return String.format("%.3f", delta);
+  }
+}
diff --git a/modules/dcache-qos/src/main/java/org/dcache/qos/services/adjuster/util/QoSAdjusterTask.java b/modules/dcache-qos/src/main/java/org/dcache/qos/services/adjuster/util/QoSAdjusterTask.java
new file mode 100644
index 0000000000..cc5c9be122
--- /dev/null
+++ b/modules/dcache-qos/src/main/java/org/dcache/qos/services/adjuster/util/QoSAdjusterTask.java
@@ -0,0 +1,298 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos.services.adjuster.util;
+
+import diskCacheV111.util.PnfsId;
+import diskCacheV111.vehicles.PoolManagerPoolInformation;
+import java.util.Optional;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import org.dcache.pool.classic.Cancellable;
+import org.dcache.pool.migration.PoolMigrationCopyFinishedMessage;
+import org.dcache.qos.data.FileQoSUpdate;
+import org.dcache.qos.data.QoSAction;
+import org.dcache.qos.services.adjuster.adjusters.CopyAdjuster;
+import org.dcache.qos.services.adjuster.adjusters.QoSAdjuster;
+import org.dcache.qos.services.adjuster.adjusters.QoSAdjusterFactory;
+import org.dcache.qos.util.ErrorAwareTask;
+import org.dcache.qos.util.ExceptionMessage;
+import org.dcache.qos.vehicles.QoSAdjustmentRequest;
+import org.dcache.vehicles.FileAttributes;
+
+/**
+ *  Responsible for running the adjuster.
+ */
+public final class QoSAdjusterTask extends ErrorAwareTask implements Cancellable {
+  private static final String TO_STRING = "%s (%s %s)(src %s, tgt %s, retried %s)";
+  private static final String TO_HISTORY_STRING = "%s (%s %s)(src %s, tgt %s, retried %s, secs %s) %s";
+
+  private final PnfsId pnfsId;
+  private final QoSAction type;
+  private final int retry;
+  private final QoSAdjusterFactory factory;
+  private final FileAttributes attributes;
+  private final PoolManagerPoolInformation targetInfo;
+  private final String source;
+  private final String poolGroup;
+
+  private String target;
+  private QoSAdjuster adjuster;
+  private Future future;
+  private Exception exception;
+
+  /*
+   *  Monitoring statistics.
+   */
+  private long startTime;
+  private long endTime;
+
+  enum Status {
+    INITIALIZED, RUNNING, CANCELLED, DONE
+  }
+
+  private Status status;
+
+  public QoSAdjusterTask(QoSAdjustmentRequest request, QoSAdjusterFactory factory) {
+    this.pnfsId = request.getPnfsId();
+    this.type = request.getAction();
+    this.retry = 0;
+    this.factory = factory;
+    this.attributes = request.getAttributes();
+    this.targetInfo = request.getTargetInfo();
+    this.source = request.getSource();
+    this.target = request.getTarget();
+    this.poolGroup = request.getPoolGroup();
+    this.status = Status.INITIALIZED;
+  }
+
+  public QoSAdjusterTask(QoSAdjusterTask task, int retry) {
+    this.pnfsId = task.pnfsId;
+    this.type = task.type;;
+    this.retry = retry;
+    this.factory = task.factory;
+    this.attributes = task.attributes;
+    this.targetInfo = task.targetInfo;
+    this.source = task.source;
+    this.target = task.target;
+    this.poolGroup = task.poolGroup;
+    this.status = task.status;
+  }
+
+  @Override
+  public Void call() {
+    synchronized (this) {
+      status = Status.RUNNING;
+      exception = null;
+      adjuster = factory.newBuilder().of(type).build();
+      startTime = System.currentTimeMillis();
+    }
+
+    switch (type) {
+      case VOID:
+        taskTerminated(Optional.empty(), null);
+        break;
+      default:
+        if (isCancelled()) {
+          break;
+        }
+        adjuster.adjustQoS(this);
+        break;
+    }
+
+    return null;
+  }
+
+  @Override
+  public void cancel(String explanation) {
+    cancel();
+
+    if (adjuster != null) {
+      adjuster.cancel(explanation);
+    }
+
+    if (future != null) {
+      future.cancel(true);
+    }
+
+    taskTerminated(Optional.empty(),null);
+  }
+
+  public Exception getException() {
+    return exception;
+  }
+
+  public synchronized long getStartTime() {
+    return startTime;
+  }
+
+  public synchronized long getEndTime() {
+    return endTime;
+  }
+
+  public synchronized Status getStatus() {
+    return status;
+  }
+
+  public synchronized String getStatusName() {
+    return status.name();
+  }
+
+  public Integer getTypeValue() {
+    if (type == null) {
+      return null;
+    }
+    return type.ordinal();
+  }
+
+  public QoSAction getAction() {
+    return type;
+  }
+
+  public PnfsId getPnfsId() {
+    return pnfsId;
+  }
+
+  public int getRetry() {
+    return retry;
+  }
+
+  public FileAttributes getAttributes() {
+    return attributes;
+  }
+
+  public String getSource() {
+    return source;
+  }
+
+  public String getTarget() {
+    return target;
+  }
+
+  public String getPoolGroup() {
+    return poolGroup;
+  }
+
+  public PoolManagerPoolInformation getTargetInfo() {
+    return targetInfo;
+  }
+
+  public synchronized boolean isCancelled() {
+    return status == Status.CANCELLED;
+  }
+
+  public synchronized boolean isRunning() {
+    return status == Status.RUNNING;
+  }
+
+  public synchronized boolean isDone() {
+    return status == Status.DONE || status == Status.CANCELLED;
+  }
+
+  public void relayMessage(PoolMigrationCopyFinishedMessage message) {
+    if (!message.getPnfsId().equals(pnfsId)) {
+      return;
+    }
+
+    if (!(adjuster instanceof CopyAdjuster)) {
+      String msg = String.format( "migration copy finished message arrived for %s, but there is "
+                                    + "no corresponding migration task.", pnfsId);
+      throw new IllegalStateException(msg);
+    }
+
+    ((CopyAdjuster) adjuster).relayMessage(message);
+  }
+
+  public synchronized void setFuture(Future future) {
+    this.future = future;
+  }
+
+  public synchronized void taskTerminated(Optional<String> target, Exception exception) {
+    if (target.isPresent()) {
+      this.target = target.get();
+    }
+    if (!isDone()) {
+      status = Status.DONE;
+    }
+    this.exception = exception;
+    endTime = System.currentTimeMillis();
+  }
+
+  public String toString() {
+    return String.format(TO_STRING,
+        startTime == 0L ? "" : FileQoSUpdate.getFormattedDateFromMillis(startTime),
+        pnfsId, type.name(),
+        source == null ? "none" : source, target == null ? "none" : target,
+        retry);
+  }
+
+  public String toHistoryString() {
+    return String.format(TO_HISTORY_STRING,
+        startTime == 0L ? "" : FileQoSUpdate.getFormattedDateFromMillis(startTime),
+        pnfsId, type.name(),
+        source == null ? "none" : source, target == null ? "none" : target,
+        retry,
+        TimeUnit.MILLISECONDS.toSeconds(endTime-startTime),
+        exception == null ? "" : new ExceptionMessage(exception));
+  }
+
+  private synchronized void cancel() {
+    this.status = Status.CANCELLED;
+  }
+}
diff --git a/modules/dcache-qos/src/main/java/org/dcache/qos/services/adjuster/util/StaticSinglePoolList.java b/modules/dcache-qos/src/main/java/org/dcache/qos/services/adjuster/util/StaticSinglePoolList.java
new file mode 100644
index 0000000000..2bc6819bc9
--- /dev/null
+++ b/modules/dcache-qos/src/main/java/org/dcache/qos/services/adjuster/util/StaticSinglePoolList.java
@@ -0,0 +1,107 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos.services.adjuster.util;
+
+import com.google.common.collect.ImmutableList;
+import diskCacheV111.vehicles.PoolManagerPoolInformation;
+import org.dcache.pool.migration.RefreshablePoolList;
+
+/**
+ *  A simplified degenerate implementation of {@link RefreshablePoolList}
+ *  tailored for use by the qos system. Provides a static list
+ *  of the pool information to the migration task.
+ *  <p/>
+ *  As currently used, the pool list will actually contain
+ *  only a single pool which has been precomputed for selection by the
+ *  verification service, already taking into account offline pools.
+ */
+public final class StaticSinglePoolList implements RefreshablePoolList {
+    private final ImmutableList<PoolManagerPoolInformation> pools;
+    private final ImmutableList<String> offline = ImmutableList.of();
+
+    public StaticSinglePoolList(PoolManagerPoolInformation info) {
+        this.pools = ImmutableList.of(info);
+    }
+
+    @Override
+    public synchronized ImmutableList<String> getOfflinePools() {
+        return offline;
+    }
+
+    @Override
+    public synchronized ImmutableList<PoolManagerPoolInformation> getPools() {
+        return pools;
+    }
+
+    @Override
+    public synchronized boolean isValid() {
+        return true;
+    }
+
+    @Override
+    public synchronized void refresh() {
+        //NOP
+    }
+
+    @Override
+    public String toString() {
+        return String.format("pools %s, offline %s", pools, offline);
+    }
+}
