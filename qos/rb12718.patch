diff --git a/modules/dcache-qos/src/main/java/org/dcache/qos/local/clients/LocalQoSRequirementsClient.java b/modules/dcache-qos/src/main/java/org/dcache/qos/local/clients/LocalQoSRequirementsClient.java
new file mode 100644
index 0000000000000000000000000000000000000000..d8b69b0069f215b2bbbe2d536b3e1c5d7bdc9c15
--- /dev/null
+++ b/modules/dcache-qos/src/main/java/org/dcache/qos/local/clients/LocalQoSRequirementsClient.java
@@ -0,0 +1,96 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos.local.clients;
+
+import diskCacheV111.util.PnfsId;
+import org.dcache.qos.QoSException;
+import org.dcache.qos.data.FileQoSRequirements;
+import org.dcache.qos.data.FileQoSUpdate;
+import org.dcache.qos.listeners.QoSRequirementsListener;
+import org.dcache.qos.services.engine.provider.QoSRequirementsProvider;
+
+/**
+ *  A pass-through to the requirements provider.  Also calls back to verification listener.
+ */
+public final class LocalQoSRequirementsClient implements QoSRequirementsListener {
+  private QoSRequirementsProvider provider;
+
+  @Override
+  public FileQoSRequirements fileQoSRequirementsRequested(FileQoSUpdate update) throws QoSException {
+    return provider.fetchRequirements(update);
+  }
+
+  @Override
+  public void fileQoSRequirementsModified(FileQoSRequirements newRequirements) throws QoSException {
+    provider.handleModifiedRequirements(newRequirements);
+  }
+
+  @Override
+  public void fileQoSRequirementsModifiedCancelled(PnfsId pnfsid) {
+    /*
+     *   The local client is an embedded one and thus would not be used to
+     *   dispatch a cancellation request.   This is a NOP.
+     */
+  }
+
+  public void setProvider(QoSRequirementsProvider provider) {
+    this.provider = provider;
+  }
+}
diff --git a/modules/dcache-qos/src/main/java/org/dcache/qos/remote/receivers/QoSRequirementsReceiver.java b/modules/dcache-qos/src/main/java/org/dcache/qos/remote/receivers/QoSRequirementsReceiver.java
new file mode 100644
index 0000000000000000000000000000000000000000..c8e7a8f78f7c9ab2397e5cdc267a8f291b913018
--- /dev/null
+++ b/modules/dcache-qos/src/main/java/org/dcache/qos/remote/receivers/QoSRequirementsReceiver.java
@@ -0,0 +1,185 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos.remote.receivers;
+
+import diskCacheV111.vehicles.Message;
+import diskCacheV111.vehicles.PnfsAddCacheLocationMessage;
+import diskCacheV111.vehicles.PnfsClearCacheLocationMessage;
+import dmg.cells.nucleus.CellMessageReceiver;
+import org.dcache.cells.MessageReply;
+import org.dcache.qos.services.engine.handler.FileQoSStatusHandler;
+import org.dcache.qos.util.BackloggedMessageReceiver;
+import org.dcache.qos.util.MessageGuard;
+import org.dcache.qos.util.MessageGuard.Status;
+import org.dcache.vehicles.CorruptFileMessage;
+import org.dcache.vehicles.qos.QoSActionCompleteMessage;
+import org.dcache.vehicles.qos.QoSCancelRequirementsModifiedMessage;
+import org.dcache.vehicles.qos.QoSRequirementsModifiedMessage;
+import org.dcache.vehicles.qos.QoSRequirementsRequestMessage;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ *  Implements message reception for remote requirements engine.
+ *  <p/>
+ *  Supports the reprocessing of backlogged messages received while the service
+ *  is manually disabled.
+ *  <p/>
+ *  Note that the message guard for cache location messages is set to enforce
+ *  EXTERNAL, meaning only messages not bearing a QOS session id.  This is to
+ *  prevent the redundant reprocessing of cache location changes triggered by
+ *  the QOS engine itself.
+ */
+public final class QoSRequirementsReceiver implements CellMessageReceiver, BackloggedMessageReceiver {
+  private static final Logger ACTIVITY_LOGGER = LoggerFactory.getLogger("org.dcache.qos-log");
+
+  private FileQoSStatusHandler fileStatusHandler;
+  private MessageGuard messageGuard;
+
+  public void messageArrived(CorruptFileMessage message) {
+    ACTIVITY_LOGGER.info("Received notice that file {} on pool {} is corrupt.",
+        message.getPnfsId(), message.getPool());
+    if (messageGuard.getStatus("CorruptFileMessage", message)
+        != Status.EXTERNAL) {
+      return;
+    }
+    fileStatusHandler.handleBrokenFile(message.getPnfsId(), message.getPool());
+  }
+
+  public void messageArrived(PnfsAddCacheLocationMessage message) {
+    ACTIVITY_LOGGER.info("Received notice that pool {} received file {}.",
+        message.getPoolName(), message.getPnfsId());
+    if (messageGuard.getStatus("PnfsAddCacheLocationMessage", message)
+        != Status.EXTERNAL) {
+      return;
+    }
+    fileStatusHandler.handleAddCacheLocation(message.getPnfsId(), message.getPoolName());
+  }
+
+  public void messageArrived(PnfsClearCacheLocationMessage message) {
+    ACTIVITY_LOGGER.info("Received notice that pool {} cleared file {}.",
+        message.getPoolName(), message.getPnfsId());
+    if (messageGuard.getStatus("PnfsClearCacheLocationMessage", message)
+        != Status.EXTERNAL) {
+      return;
+    }
+    fileStatusHandler.handleClearCacheLocation(message.getPnfsId(), message.getPoolName());
+  }
+
+  public MessageReply<QoSRequirementsRequestMessage> messageArrived(QoSRequirementsRequestMessage message) {
+    MessageReply<QoSRequirementsRequestMessage> reply = new MessageReply<>();
+    if (messageGuard.getStatus("QoSRequirementsRequestMessage", message)
+        == Status.DISABLED) {
+      return reply;
+    }
+    fileStatusHandler.handleRequirementsRequestReply(reply, message);
+    return reply;
+  }
+
+  public void messageArrived(QoSRequirementsModifiedMessage message) {
+    if (messageGuard.getStatus("QoSRequirementsModifiedMessage", message)
+        == Status.DISABLED) {
+      return;
+    }
+    fileStatusHandler.handleQoSModification(message.getRequirements());
+  }
+
+  public void messageArrived(QoSCancelRequirementsModifiedMessage message){
+    if (messageGuard.getStatus("QoSCancelRequirementsModifiedMessage", message)
+        == Status.DISABLED) {
+      return;
+    }
+    fileStatusHandler.handleQoSModificationCancelled(message.getPnfsId());
+  }
+
+  public void messageArrived(QoSActionCompleteMessage message){
+    if (messageGuard.getStatus("QoSActionCompleteMessage", message)
+        == Status.DISABLED) {
+      return;
+    }
+    fileStatusHandler.handleActionCompleted(message.getPnfsId(),
+                                            message.getAction(),
+                                            message.getErrorObject());
+  }
+
+  public void processBackloggedMessage(Message message) {
+    if (message instanceof CorruptFileMessage) {
+      messageArrived((CorruptFileMessage)message);
+    } else if (message instanceof PnfsAddCacheLocationMessage) {
+      messageArrived((PnfsAddCacheLocationMessage) message);
+    } else if (message instanceof PnfsClearCacheLocationMessage) {
+      messageArrived((PnfsClearCacheLocationMessage) message);
+    } else if (message instanceof QoSRequirementsRequestMessage) {
+      messageArrived((QoSRequirementsRequestMessage) message);
+    } else if (message instanceof QoSRequirementsModifiedMessage) {
+      messageArrived((QoSRequirementsModifiedMessage) message);
+    } else if (message instanceof QoSActionCompleteMessage) {
+      messageArrived((QoSActionCompleteMessage) message);
+    }
+  }
+
+  public void setMessageGuard(MessageGuard messageGuard) {
+    this.messageGuard = messageGuard;
+  }
+
+  public void setFileStatusHandler(FileQoSStatusHandler fileStatusHandler) {
+    this.fileStatusHandler = fileStatusHandler;
+  }
+}
diff --git a/modules/dcache-qos/src/main/java/org/dcache/qos/services/engine/admin/QoSEngineAdmin.java b/modules/dcache-qos/src/main/java/org/dcache/qos/services/engine/admin/QoSEngineAdmin.java
new file mode 100644
index 0000000000000000000000000000000000000000..017398d70f7c0680af2139c12fc7a39eeae2328d
--- /dev/null
+++ b/modules/dcache-qos/src/main/java/org/dcache/qos/services/engine/admin/QoSEngineAdmin.java
@@ -0,0 +1,177 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos.services.engine.admin;
+
+import dmg.cells.nucleus.CellCommandListener;
+import dmg.util.command.Command;
+import dmg.util.command.Option;
+import java.util.concurrent.TimeUnit;
+import org.dcache.qos.services.engine.util.QoSEngineCounters;
+import org.dcache.qos.util.InitializerAwareCommand;
+import org.dcache.qos.util.MapInitializer;
+import org.dcache.qos.util.MessageGuard;
+
+public final class QoSEngineAdmin implements CellCommandListener {
+  @Command(name = "disable", hint = "turn off handling",
+           description = "Prevents external messages from being processed by the qos system.")
+  class DisableCommand extends InitializerAwareCommand {
+    @Option(name="drop", valueSpec = "true|false",
+            usage = "If true, do not store backlogged messages; false by default.")
+    Boolean drop = false;
+
+    DisableCommand() { super(initializer); }
+
+    @Override
+    protected String doCall() throws Exception {
+      if (messageGuard.isEnabled()) {
+        messageGuard.disable(drop);
+        if (drop) {
+          return "Processing of incoming messages has been disabled; "
+              + "backlogged messages will be dropped.";
+        }
+        return "Processing of incoming messages has been disabled; "
+            + "backlogged messages will be stored.";
+      }
+
+      return "Receiver already disabled.";
+    }
+  }
+
+  @Command(name = "enable", hint = "turn on handling",
+           description = "Allows external messages to be received by the qos system.")
+  class EnableCommand extends InitializerAwareCommand {
+
+    EnableCommand() { super(initializer); }
+
+    @Override
+    protected String doCall() {
+      if (!messageGuard.isEnabled()) {
+        messageGuard.enable();
+        return "Processing of incoming messages has been re-enabled";
+      }
+      return "Receiver is already enabled.";
+    }
+  }
+
+  @Command(name = "engine stats", hint = "print diagnostic statistics",
+      description = "Reads in the contents of the file recording periodic statistics.")
+  class EngineStatsCommand extends InitializerAwareCommand {
+    @Option(name = "limit", usage = "Display up to this number of lines (default is 24 * 60).")
+    Integer limit = 24 * 60;
+
+    @Option(name = "order", valueSpec = "asc|desc",
+        usage = "Display lines in ascending (default) or descending order by timestamp.")
+    String order = "asc";
+
+    @Option(name = "enable",
+        usage = "Turn the recording of statistics to file on or off. Recording to file is "
+            + "off by default.")
+    Boolean enable = null;
+
+    EngineStatsCommand() { super(initializer); }
+
+    protected String doCall() throws Exception {
+      if (enable != null) {
+        counters.setToFile(enable);
+        if (enable) {
+          counters.scheduleStatistics();
+        }
+        return "Recording to file is now " + (enable ? "on." : "off.");
+      }
+
+      SortOrder order = SortOrder.valueOf(this.order.toUpperCase());
+      StringBuilder builder = new StringBuilder();
+      counters.readStatistics(builder, 0, limit, order == SortOrder.DESC);
+      return builder.toString();
+    }
+  }
+
+  private final MapInitializer initializer = new MapInitializer() {
+    @Override
+    protected long getRefreshTimeout() {
+      return 0;
+    }
+
+    @Override
+    protected TimeUnit getRefreshTimeoutUnit() {
+      return TimeUnit.MILLISECONDS;
+    }
+
+    @Override
+    public void run() {
+    }
+
+    @Override
+    public boolean isInitialized() {
+      return true;
+    }
+  };
+
+  private MessageGuard messageGuard;
+  private QoSEngineCounters counters;
+
+  public void setCounters(QoSEngineCounters counters) {
+    this.counters = counters;
+  }
+
+  public void setMessageGuard(MessageGuard messageGuard) {
+    this.messageGuard = messageGuard;
+  }
+}
diff --git a/modules/dcache-qos/src/main/java/org/dcache/qos/services/engine/handler/FileQoSStatusHandler.java b/modules/dcache-qos/src/main/java/org/dcache/qos/services/engine/handler/FileQoSStatusHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..8500de52a66baa159cc0ed37b32faffb4c8db6c6
--- /dev/null
+++ b/modules/dcache-qos/src/main/java/org/dcache/qos/services/engine/handler/FileQoSStatusHandler.java
@@ -0,0 +1,247 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos.services.engine.handler;
+
+import diskCacheV111.util.PnfsId;
+import dmg.cells.nucleus.CellInfoProvider;
+import java.io.PrintWriter;
+import java.io.Serializable;
+import java.util.concurrent.ExecutorService;
+import org.dcache.cells.CellStub;
+import org.dcache.cells.MessageReply;
+import org.dcache.qos.QoSException;
+import org.dcache.qos.data.FileQoSRequirements;
+import org.dcache.qos.data.FileQoSUpdate;
+import org.dcache.qos.data.QoSAction;
+import org.dcache.qos.listeners.QoSActionCompletedListener;
+import org.dcache.qos.listeners.QoSRequirementsListener;
+import org.dcache.qos.listeners.QoSVerificationListener;
+import org.dcache.qos.services.engine.util.QoSEngineCounters;
+import org.dcache.qos.vehicles.QoSVerificationRequest;
+import org.dcache.vehicles.qos.QoSRequirementsRequestMessage;
+import org.dcache.vehicles.qos.QoSTransitionCompletedMessage;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import static org.dcache.qos.data.QoSAction.VOID;
+import static org.dcache.qos.data.QoSMessageType.ADD_CACHE_LOCATION;
+import static org.dcache.qos.data.QoSMessageType.CLEAR_CACHE_LOCATION;
+import static org.dcache.qos.data.QoSMessageType.CORRUPT_FILE;
+import static org.dcache.qos.data.QoSMessageType.QOS_MODIFIED;
+import static org.dcache.qos.data.QoSMessageType.QOS_MODIFIED_CANCELED;
+import static org.dcache.qos.services.engine.util.QoSEngineCounters.QOS_ACTION_COMPLETED;
+import static org.dcache.qos.services.engine.util.QoSEngineCounters.QOS_REQUIREMENTS_REQUEST;
+
+/**
+ *   Implementation of the gateway to requirements dispatching.  For now, this is
+ *   a simple pass-through to the listeners providing the file requirements and
+ *   forwarding notifications to the verification service.
+ */
+public final class FileQoSStatusHandler implements CellInfoProvider, QoSActionCompletedListener {
+  private static final Logger LOGGER = LoggerFactory.getLogger(FileQoSStatusHandler.class);
+
+  private QoSRequirementsListener requirementsListener;
+  private QoSVerificationListener verificationListener;
+  private CellStub qosTransitionTopic;
+  private ExecutorService executor;
+  private QoSEngineCounters counters;
+
+  @Override
+  public void getInfo(PrintWriter pw) {
+    StringBuilder builder = new StringBuilder();
+    counters.appendRunning(builder);
+    counters.appendCounts(builder);
+    pw.print(builder.toString());
+  }
+
+  public void handleAddCacheLocation(PnfsId pnfsId, String pool) {
+    counters.increment(ADD_CACHE_LOCATION.name());
+    executor.execute(()-> {
+      try {
+        LOGGER.debug("handleAddCacheLocation calling fileQoSStatusChanged for {} on {}.", pnfsId, pool);
+        fileQoSStatusChanged(new FileQoSUpdate(pnfsId, pool, ADD_CACHE_LOCATION));
+      } catch (QoSException e) {
+        LOGGER.error("handleAddCacheLocation failed for {} on {}: {}.", pnfsId, pool, e.toString());
+      }
+    });
+  }
+
+  public void handleBrokenFile(PnfsId pnfsId, String pool) {
+    counters.increment(CORRUPT_FILE.name());
+    executor.execute(()-> {
+      try {
+        LOGGER.debug("handleBrokenFile calling fileQoSStatusChanged for {} on {}.", pnfsId, pool);
+        fileQoSStatusChanged(new FileQoSUpdate(pnfsId, pool, CORRUPT_FILE));
+      } catch (QoSException e) {
+        LOGGER.error("handleBrokenFile failed for {} on {}: {}.", pnfsId, pool, e.toString());
+      }
+    });
+  }
+
+  public void handleClearCacheLocation(PnfsId pnfsId, String pool) {
+    counters.increment(CLEAR_CACHE_LOCATION.name());
+    executor.execute(()-> {
+      try {
+        LOGGER.debug("handleClearCacheLocation calling fileQoSStatusChanged for {} on {}.", pnfsId, pool);
+        fileQoSStatusChanged(new FileQoSUpdate(pnfsId, pool, CLEAR_CACHE_LOCATION));
+      } catch (QoSException e) {
+        /*
+         *  The file was very likely deleted.  Log this only for informational purposes.
+         */
+        LOGGER.debug("handleClearCacheLocation for {} on {}: {}.", pnfsId, pool, e.toString());
+      }
+    });
+  }
+
+  public void handleQoSModification(FileQoSRequirements requirements) {
+    counters.increment(QOS_MODIFIED.name());
+    PnfsId pnfsId = requirements.getPnfsId();
+    executor.execute(()-> {
+      try {
+        LOGGER.debug("handleQoSModification calling fileQoSRequirementsModified for {}.", pnfsId);
+        requirementsListener.fileQoSRequirementsModified(requirements);
+        LOGGER.debug("handleQoSModification calling fileQoSStatusChanged for {}, {}.",
+            pnfsId, QOS_MODIFIED);
+        fileQoSStatusChanged(new FileQoSUpdate(pnfsId, null, QOS_MODIFIED));
+      } catch (QoSException e) {
+        LOGGER.error("Failed to handle QoS requirements for {}: {}.", requirements.getPnfsId(),
+                                                                      e.toString());
+        handleActionCompleted(pnfsId, VOID, e.toString());
+      }
+    });
+  }
+
+  public void handleQoSModificationCancelled(PnfsId pnfsId) {
+    counters.increment(QOS_MODIFIED_CANCELED.name());
+    executor.execute(()-> {
+      try {
+        LOGGER.debug("handleQoSModificationCancelled notifying verification listener to cancel {}.",
+            pnfsId);
+        verificationListener.fileQoSVerificationCancelled(pnfsId);
+      } catch (QoSException e) {
+        LOGGER.error("Failed to handle QoS requirements for {}: {}.", pnfsId, e.toString());
+      }
+    });
+  }
+
+  public void handleRequirementsRequestReply(MessageReply<QoSRequirementsRequestMessage> reply,
+                                             QoSRequirementsRequestMessage message) {
+    executor.execute(()-> {
+      try {
+        LOGGER.debug("handleRequirementsRequestReply calling fileQoSRequirementsRequested for {}.",
+            message.getUpdate());
+        message.setRequirements(requirementsListener.fileQoSRequirementsRequested(message.getUpdate()));
+        reply.reply(message);
+      } catch (QoSException e) {
+        reply.fail(message, e);
+      } catch (Exception e) {
+        reply.fail(message, e);
+      }
+    });
+  }
+
+  public FileQoSRequirements handleRequirementsRequest(FileQoSUpdate update) {
+    counters.increment(QOS_REQUIREMENTS_REQUEST);
+    try {
+      LOGGER.debug("handleRequirementsRequest calling fileQoSRequirementsRequested for {}.", update);
+      return requirementsListener.fileQoSRequirementsRequested(update);
+    } catch (QoSException e) {
+      return null;
+    }
+  }
+
+  public void handleActionCompleted(PnfsId pnfsId, QoSAction action, Serializable error) {
+    fileQoSActionCompleted(pnfsId, action, error);
+  }
+
+  public void setQoSEngineCounters(QoSEngineCounters counters) {
+    this.counters = counters;
+  }
+
+  public void setQosTransitionTopic(CellStub qosTransitionTopic) {
+    this.qosTransitionTopic = qosTransitionTopic;
+  }
+
+  public void setExecutor(ExecutorService executor) {
+    this.executor = executor;
+  }
+
+  public void setRequirementsListener(QoSRequirementsListener requirementsListener) {
+    this.requirementsListener = requirementsListener;
+  }
+
+  public void setVerificationListener(QoSVerificationListener verificationListener) {
+    this.verificationListener = verificationListener;
+  }
+
+  @Override
+  public void fileQoSActionCompleted(PnfsId pnfsId, QoSAction action, Serializable error) {
+    counters.increment(QOS_ACTION_COMPLETED);
+    qosTransitionTopic.notify(new QoSTransitionCompletedMessage(pnfsId, action, error));
+  }
+
+  private void fileQoSStatusChanged(FileQoSUpdate update) throws QoSException {
+    FileQoSRequirements requirements = requirementsListener.fileQoSRequirementsRequested(update);
+    QoSVerificationRequest request = new QoSVerificationRequest();
+    request.setUpdate(update);
+    request.setRequirements(requirements);
+    verificationListener.fileQoSVerificationRequested(request);
+  }
+}
diff --git a/modules/dcache-qos/src/main/java/org/dcache/qos/services/engine/provider/ALRPStorageUnitQoSProvider.java b/modules/dcache-qos/src/main/java/org/dcache/qos/services/engine/provider/ALRPStorageUnitQoSProvider.java
new file mode 100644
index 0000000000000000000000000000000000000000..4e8d63b8479d1453a8728700f3bf411683a152b4
--- /dev/null
+++ b/modules/dcache-qos/src/main/java/org/dcache/qos/services/engine/provider/ALRPStorageUnitQoSProvider.java
@@ -0,0 +1,342 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos.services.engine.provider;
+
+import com.google.common.annotations.VisibleForTesting;
+import diskCacheV111.poolManager.PoolSelectionUnit;
+import diskCacheV111.poolManager.PoolSelectionUnit.SelectionUnit;
+import diskCacheV111.poolManager.StorageUnit;
+import diskCacheV111.util.AccessLatency;
+import diskCacheV111.util.CacheException;
+import diskCacheV111.util.PnfsHandler;
+import diskCacheV111.util.PnfsId;
+import diskCacheV111.util.RetentionPolicy;
+import dmg.cells.nucleus.CellMessageReceiver;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.EnumSet;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import org.dcache.auth.Subjects;
+import org.dcache.auth.attributes.Restrictions;
+import org.dcache.cells.CellStub;
+import org.dcache.namespace.FileAttribute;
+import org.dcache.poolmanager.PoolMonitor;
+import org.dcache.poolmanager.SerializablePoolMonitor;
+import org.dcache.qos.QoSException;
+import org.dcache.qos.data.FileQoSRequirements;
+import org.dcache.qos.data.FileQoSUpdate;
+import org.dcache.qos.data.QoSMessageType;
+import org.dcache.vehicles.FileAttributes;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import static diskCacheV111.util.AccessLatency.NEARLINE;
+import static diskCacheV111.util.AccessLatency.ONLINE;
+import static diskCacheV111.util.RetentionPolicy.CUSTODIAL;
+import static diskCacheV111.util.RetentionPolicy.REPLICA;
+import static org.dcache.qos.data.QoSMessageType.CHECK_CUSTODIAL_ONLINE;
+import static org.dcache.qos.data.QoSMessageType.CLEAR_CACHE_LOCATION;
+import static org.dcache.qos.data.QoSMessageType.QOS_MODIFIED;
+import static org.dcache.qos.data.QoSMessageType.VALIDATE_ONLY;
+
+/**
+ *  Standard provisioning of (fixed) file requirements.  Uses access latency,
+ *  retention policy, and storage unit attributes (required, onlyOneCopyPer)
+ *  to determine the number and distribution of persistent disk locations and
+ *  whether the file should be on tape or not (currently limited to a single tape location).
+ *  <p/>
+ *  This will eventually be replaced by a more sophisticated "rule-engine" implementation
+ *  which will permit time-bound transitions and overriding of the default requirements
+ *  established by a file's storage class.
+ *  <p/>
+ *  Not marked final for testing purposes.
+ */
+public class ALRPStorageUnitQoSProvider implements QoSRequirementsProvider, CellMessageReceiver {
+  public static final Set<FileAttribute> REQUIRED_QOS_ATTRIBUTES
+      = Collections.unmodifiableSet(EnumSet.of(FileAttribute.PNFSID,
+                                               FileAttribute.ACCESS_LATENCY,
+                                               FileAttribute.RETENTION_POLICY,
+                                               FileAttribute.STORAGEINFO,
+                                               FileAttribute.CHECKSUM,
+                                               FileAttribute.SIZE,
+                                               FileAttribute.TYPE,
+                                               FileAttribute.CACHECLASS,
+                                               FileAttribute.HSM,
+                                               FileAttribute.FLAGS,
+                                               FileAttribute.LOCATIONS,
+                                               FileAttribute.ACCESS_TIME));
+
+  private static final Logger LOGGER = LoggerFactory.getLogger(ALRPStorageUnitQoSProvider.class);
+
+  private CellStub pnfsManager;
+  private PoolMonitor poolMonitor;
+
+  public synchronized void messageArrived(SerializablePoolMonitor poolMonitor) {
+    setPoolMonitor(poolMonitor);
+  }
+
+  /**
+   *  Exposed for testing purposes.
+   */
+  @VisibleForTesting
+  public synchronized void setPoolMonitor(PoolMonitor poolMonitor) {
+    this.poolMonitor = poolMonitor;
+  }
+
+  @Override
+  public FileQoSRequirements fetchRequirements(FileQoSUpdate update) throws QoSException {
+    FileQoSRequirements descriptor = initialize(update);
+    if (descriptor == null) {
+      /*
+       *  Should only happen when a CLEAR CACHE LOCATION finds no locations.
+       */
+      return null;
+    }
+
+    FileAttributes attributes = descriptor.getAttributes();
+    AccessLatency accessLatency = attributes.getAccessLatency();
+    RetentionPolicy retentionPolicy = attributes.getRetentionPolicy();
+
+    String unitKey = attributes.getStorageClass() + "@" + attributes.getHsm();
+    SelectionUnit unit = poolSelectionUnit().getStorageUnit(unitKey);
+    if (!(unit instanceof StorageUnit)) {
+      throw new QoSException(unitKey + " does not correspond to a storage unit; "
+          + "cannot retrieve requirements for " + descriptor.getPnfsId());
+    }
+
+    StorageUnit storageUnit = (StorageUnit)unit;
+    Integer required = storageUnit.getRequiredCopies();
+    List<String> onlyOneCopyPer = storageUnit.getOnlyOneCopyPer();
+
+    if (retentionPolicy == CUSTODIAL) {
+      /*
+       *  REVISIT -- currently we support only one tape location.
+       */
+      descriptor.setRequiredTape(1);
+    } else {
+      descriptor.setRequiredTape(0);
+    }
+
+    if (accessLatency == ONLINE) {
+      /*
+       *  REVISIT -- current override of file AL based on storage unit
+       *  REVISIT -- eventually we will want to override the storage unit default for a given file
+       */
+      descriptor.setRequiredDisk(required == null ? 1 : required);
+      if (onlyOneCopyPer != null) {
+        descriptor.setPartitionKeys(new HashSet<>(onlyOneCopyPer));
+      }
+    } else {
+      descriptor.setRequiredDisk(0);
+    }
+
+    LOGGER.debug("fetchRequirements for {}, returning {}.", update, descriptor);
+
+    return descriptor;
+  }
+
+  /*
+   *  REVISIT For now, we do not handle changes to number or partitioning of copies.
+   */
+  @Override
+  public void handleModifiedRequirements(FileQoSRequirements newRequirements) throws QoSException {
+    PnfsId pnfsId = newRequirements.getPnfsId();
+
+    LOGGER.debug("handleModifiedRequirements for {}.", pnfsId);
+
+    /*
+     *  Check immediately for unsupported changes.   Currently, this only involves the move
+     *  from CUSTODIAL TO REPLICA.
+     */
+    FileAttributes currentAttributes = newRequirements.getAttributes();
+    if (currentAttributes == null || !currentAttributes.isDefined(FileAttribute.RETENTION_POLICY)) {
+      currentAttributes = fetchAttributes(pnfsId);
+    }
+
+    if (currentAttributes.getRetentionPolicy() == CUSTODIAL && newRequirements.getRequiredTape() == 0) {
+      throw new QoSException("Unsupported transition from tape to disk: "
+          + "QoS currently does not support removal of tape locations.");
+    }
+
+    FileAttributes modifiedAttributes = new FileAttributes();
+    if (newRequirements.getRequiredDisk() > 0) {
+      modifiedAttributes.setAccessLatency(ONLINE);
+    } else {
+      modifiedAttributes.setAccessLatency(NEARLINE);
+    }
+
+    if (newRequirements.getRequiredTape() > 0) {
+      modifiedAttributes.setRetentionPolicy(CUSTODIAL);
+    } else {
+      modifiedAttributes.setRetentionPolicy(REPLICA);
+    }
+
+    try {
+      pnfsHandler().setFileAttributes(pnfsId, modifiedAttributes);
+    } catch (CacheException e) {
+      throw new QoSException("Failed to set attributes for " + newRequirements.getPnfsId(), e);
+    }
+  }
+
+  public void setPnfsManager(CellStub pnfsManager) {
+    this.pnfsManager = pnfsManager;
+  }
+
+  /*
+   *  This is exposed for overriding when testing
+   */
+  @VisibleForTesting
+  protected FileAttributes fetchAttributes(PnfsId pnfsId) throws QoSException {
+    try {
+      LOGGER.debug("fetchAttributes for {}.", pnfsId);
+      return pnfsHandler().getFileAttributes(pnfsId, REQUIRED_QOS_ATTRIBUTES);
+    } catch (CacheException e) {
+      throw new QoSException(String.format("No attributes returned for %s", pnfsId), e);
+    }
+  }
+
+  private FileQoSRequirements initialize(FileQoSUpdate update) throws QoSException {
+    PnfsId pnfsId = update.getPnfsId();
+    QoSMessageType messageType = update.getMessageType();
+
+    LOGGER.debug("initialize {}.", update);
+
+    if (VALIDATE_ONLY == messageType) {
+      /*
+       *  Do not revalidate the attributes.
+       */
+      return new FileQoSRequirements(pnfsId, fetchAttributes(pnfsId));
+    }
+
+    FileAttributes attributes = validateAttributes(update);
+    if (attributes == null) {
+      return null;
+    }
+
+    return new FileQoSRequirements(pnfsId, attributes);
+  }
+
+  private PnfsHandler pnfsHandler() {
+    PnfsHandler pnfsHandler = new PnfsHandler(pnfsManager);
+    pnfsHandler.setSubject(Subjects.ROOT);
+    pnfsHandler.setRestriction(Restrictions.none());
+    return pnfsHandler;
+  }
+
+  private synchronized PoolSelectionUnit poolSelectionUnit() {
+    return poolMonitor.getPoolSelectionUnit();
+  }
+
+  /*
+   *  Return <code>null</code> if the file is not found or there are no locations
+   *  for it and the message being processed is for a clear cache location; otherwise
+   *  the file attribute set required to process resilience.
+   */
+  private FileAttributes validateAttributes(FileQoSUpdate update) throws QoSException {
+      PnfsId pnfsId = update.getPnfsId();
+      QoSMessageType messageType = update.getMessageType();
+      FileAttributes attributes = fetchAttributes(pnfsId);
+
+      LOGGER.debug("validateAttributes, got required attributes for {}.", pnfsId);
+
+      if (messageType == CHECK_CUSTODIAL_ONLINE || messageType == QOS_MODIFIED) {
+        /*
+         *  The pool location will be undefined here.
+         *  The namespace locations may be empty for QOS_MODIFIED if
+         *  it is a tape to disk+tape transition where there are currently
+         *  no replicas on disk.
+         */
+        return attributes;
+      }
+
+      if (attributes.getLocations().isEmpty()) {
+        if (messageType == CLEAR_CACHE_LOCATION) {
+          LOGGER.debug("ClearCacheLocationMessage for {}; no current locations.", pnfsId);
+          return null;
+        }
+
+        String pool = update.getPool();
+
+        /*
+         *  Scan activities and add cache location should not have a null pool.
+         */
+        if (pool == null) {
+          throw new QoSException(String.format("QoS file update for %s, messageType %s, "
+              + "has no pool location!", pnfsId, messageType));
+        }
+
+        /*
+         *  May be due to a race with PnfsManager to process the message into/from the namespace.
+         *  We just add the originating location to the attribute location list.
+         */
+        LOGGER.debug("{} has no attribute locations yet, adding origination location {}.",
+                      pnfsId, pool);
+        Collection<String> singleLoc = new ArrayList<>();
+        singleLoc.add(pool);
+        attributes.setLocations(singleLoc);
+      }
+
+      LOGGER.debug("After call to namespace, {} has locations {}.", pnfsId, attributes.getLocations());
+      return attributes;
+  }
+}
diff --git a/modules/dcache-qos/src/main/java/org/dcache/qos/services/engine/provider/QoSRequirementsProvider.java b/modules/dcache-qos/src/main/java/org/dcache/qos/services/engine/provider/QoSRequirementsProvider.java
new file mode 100644
index 0000000000000000000000000000000000000000..dd0e9b9dbd2286218c5633b74682443c107b7f56
--- /dev/null
+++ b/modules/dcache-qos/src/main/java/org/dcache/qos/services/engine/provider/QoSRequirementsProvider.java
@@ -0,0 +1,84 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos.services.engine.provider;
+
+import org.dcache.qos.QoSException;
+import org.dcache.qos.data.FileQoSRequirements;
+import org.dcache.qos.data.FileQoSUpdate;
+
+public interface QoSRequirementsProvider {
+  /**
+   *  Implementation-dependent response to request for file's QoS requirements.
+   *
+   *  @param update containing file pnfsid, originating type of message, and optional location
+   *                for the file source.
+   *  @return requirements, in particular the number
+   *          and distribution of persistent disk and tape replicas.
+   */
+  FileQoSRequirements fetchRequirements(FileQoSUpdate update) throws QoSException;
+
+  /**
+   *  Implementation-dependent response to requested change in QoS requirements.
+   *
+   *  @param newRequirements in particular the number and distribution
+   *                         of persistent disk and tape replicas.
+   */
+  void handleModifiedRequirements(FileQoSRequirements newRequirements) throws QoSException;
+}
diff --git a/modules/dcache-qos/src/main/java/org/dcache/qos/services/engine/util/QoSEngineCounters.java b/modules/dcache-qos/src/main/java/org/dcache/qos/services/engine/util/QoSEngineCounters.java
new file mode 100644
index 0000000000000000000000000000000000000000..849dd983f82f69d23718b9adf8d55833a9dff575
--- /dev/null
+++ b/modules/dcache-qos/src/main/java/org/dcache/qos/services/engine/util/QoSEngineCounters.java
@@ -0,0 +1,175 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.qos.services.engine.util;
+
+import java.time.Instant;
+import java.util.HashMap;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.TimeUnit;
+import org.dcache.qos.util.QoSCounter;
+import org.dcache.qos.util.QoSCounterGroup;
+import org.dcache.qos.util.QoSCounters;
+
+import static org.dcache.qos.data.QoSMessageType.ADD_CACHE_LOCATION;
+import static org.dcache.qos.data.QoSMessageType.CLEAR_CACHE_LOCATION;
+import static org.dcache.qos.data.QoSMessageType.CORRUPT_FILE;
+import static org.dcache.qos.data.QoSMessageType.QOS_MODIFIED;
+import static org.dcache.qos.data.QoSMessageType.QOS_MODIFIED_CANCELED;
+
+public final class QoSEngineCounters extends QoSCounters implements Runnable {
+  public static final String QOS_REQUIREMENTS_REQUEST = "QOS_REQUIREMENTS_REQUEST";
+  public static final String QOS_ACTION_COMPLETED = "QOS_ACTION_COMPLETED";
+
+  private static final String MESSAGES       = "MESSAGES";
+  private static final String FORMAT_CNTS    = "%-26s %12s\n";
+  private static final String FORMAT_STATS   = "%-15s | %25s | %12s\n";
+  private static final String[] CNTS_HEADER  = {"MSG TYPE", "RECEIVED"};
+  private static final String[] STATS_HEADER = {"EPOCH", "DATETIME", "MESSAGE"};
+
+  class QoSEngineCounterGroup extends QoSCounterGroup<QoSCounter> {
+
+    protected QoSEngineCounterGroup(String name) {
+      super(name);
+    }
+
+    @Override
+    public void toFormattedString(StringBuilder builder) {
+      getKeys().stream()
+               .forEach(k->builder.append(String.format(FORMAT_CNTS, k, getCounter(k).getTotal())));
+    }
+
+    @Override
+    protected QoSCounter createCounter(String key) {
+      return new QoSCounter(key);
+    }
+  }
+
+  private ScheduledExecutorService service;
+
+  @Override
+  public void appendCounts(StringBuilder builder) {
+    builder.append("\n").append(String.format(FORMAT_CNTS, CNTS_HEADER));
+    groupMap.values().stream().forEach(g -> g.toFormattedString(builder));
+  }
+
+  @Override
+  public void appendDetails(StringBuilder builder) {
+    // NOP for engine
+  }
+
+  @Override
+  public void initialize() {
+    groupMap = new HashMap<>();
+    QoSEngineCounterGroup group = new QoSEngineCounterGroup(MESSAGES);
+    group.addCounter(ADD_CACHE_LOCATION.name());
+    group.addCounter(CORRUPT_FILE.name());
+    group.addCounter(CLEAR_CACHE_LOCATION.name());
+    group.addCounter(QOS_MODIFIED.name());
+    group.addCounter(QOS_MODIFIED_CANCELED.name());
+    group.addCounter(QOS_ACTION_COMPLETED);
+    group.addCounter(QOS_REQUIREMENTS_REQUEST);
+    groupMap.put(MESSAGES, group);
+  }
+
+  public synchronized void increment(String counter) {
+    QoSCounterGroup counterGroup = groupMap.get(MESSAGES);
+    if (counterGroup == null) {
+      LOGGER.debug("trying to increment non-existent counter group {}", MESSAGES);
+      return;
+    }
+    counterGroup.getCounter(counter).incrementTotal();
+    if (toFile) {
+      Instant i = Instant.now();
+      synchronized (statisticsBuffer) {
+        statisticsBuffer
+            .add(String.format(FORMAT_STATS, i.toEpochMilli(), DATE_FORMATER.format(i), counter));
+      }
+    }
+  }
+
+  public long getCount(String counter) {
+    return groupMap.get(MESSAGES).getCounter(counter).getTotal();
+  }
+
+  public void run() {
+    writeStatistics();
+    scheduleStatistics();
+  }
+
+  public void setService(ScheduledExecutorService service) {
+    this.service = service;
+  }
+
+  public void scheduleStatistics() {
+    if (toFile) {
+      service.schedule(this, 1, TimeUnit.MINUTES);
+    }
+  }
+
+  @Override
+  protected String getStatisticsFormat() {
+    return FORMAT_STATS;
+  }
+
+  @Override
+  protected String[] getStatisticsHeader() {
+    return STATS_HEADER;
+  }
+}
