diff --git a/modules/dcache-xrootd/src/main/java/org/dcache/xrootd/pool/XrootdPoolRequestHandler.java b/modules/dcache-xrootd/src/main/java/org/dcache/xrootd/pool/XrootdPoolRequestHandler.java
index ef3bb9cdd0..c02611f916 100644
--- a/modules/dcache-xrootd/src/main/java/org/dcache/xrootd/pool/XrootdPoolRequestHandler.java
+++ b/modules/dcache-xrootd/src/main/java/org/dcache/xrootd/pool/XrootdPoolRequestHandler.java
@@ -42,6 +42,7 @@ import com.google.common.util.concurrent.Uninterruptibles;
 import diskCacheV111.util.CacheException;
 import diskCacheV111.util.FileCorruptedCacheException;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.ssl.SslHandler;
 import io.netty.handler.timeout.IdleState;
 import io.netty.handler.timeout.IdleStateEvent;
 import java.io.IOException;
@@ -614,9 +615,14 @@ public class XrootdPoolRequestHandler extends AbstractXrootdRequestHandler {
 
         if (msg.bytesToRead() == 0) {
             return withOk(msg);
-        } else {
+        } else if (ctx.pipeline().get(SslHandler.class) != null) {
             return new ChunkedFileDescriptorReadResponse(msg, _maxFrameSize, getDescriptor(fd));
         }
+        try {
+            return new ZeroCopyRepositoryChannelReadResponse(msg, getDescriptor(fd).getChannel());
+        } catch (IOException e) {
+            throw new XrootdException(kXR_IOError, e.toString());
+        }
     }
 
     /**
diff --git a/modules/dcache-xrootd/src/main/java/org/dcache/xrootd/pool/ZeroCopyRepositoryChannelReadResponse.java b/modules/dcache-xrootd/src/main/java/org/dcache/xrootd/pool/ZeroCopyRepositoryChannelReadResponse.java
new file mode 100644
index 0000000000..59e019cfff
--- /dev/null
+++ b/modules/dcache-xrootd/src/main/java/org/dcache/xrootd/pool/ZeroCopyRepositoryChannelReadResponse.java
@@ -0,0 +1,97 @@
+/* dCache - http://www.dcache.org/
+ *
+ * Copyright (C) 2014 Deutsches Elektronen-Synchrotron
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as
+ * published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package org.dcache.xrootd.pool;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+import static org.dcache.xrootd.protocol.XrootdProtocol.kXR_ok;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelFutureListener;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelPromise;
+import java.io.IOException;
+import org.dcache.pool.movers.NettyTransferService.NettyMoverChannel;
+import org.dcache.pool.movers.RepositoryFileRegion;
+import org.dcache.xrootd.protocol.messages.ReadRequest;
+import org.dcache.xrootd.protocol.messages.XrootdResponse;
+
+public class ZeroCopyRepositoryChannelReadResponse implements XrootdResponse<ReadRequest> {
+    private final ReadRequest request;
+    private final NettyMoverChannel channel;
+    private final int count;
+
+    public ZeroCopyRepositoryChannelReadResponse(ReadRequest request, NettyMoverChannel channel)
+          throws IOException {
+        this.request = checkNotNull(request);
+        this.channel = checkNotNull(channel);
+        this.count = (int) Math.min(request.bytesToRead(),
+              channel.size() - request.getReadOffset());
+    }
+
+    @Override
+    public ReadRequest getRequest() {
+        return request;
+    }
+
+    @Override
+    public int getStatus() {
+        return kXR_ok;
+    }
+
+    @Override
+    public int getDataLength() {
+        return count;
+    }
+
+    @Override
+    public void writeTo(ChannelHandlerContext ctx, final ChannelPromise promise) {
+        ByteBuf header = ctx.alloc().buffer(8);
+        header.writeShort(request.getStreamId());
+        header.writeShort(kXR_ok);
+        header.writeInt(count);
+        ctx.write(header).addListener(
+              new ChannelFutureListener() {
+                  @Override
+                  public void operationComplete(ChannelFuture future) throws Exception {
+                      if (!future.isSuccess()) {
+                          promise.tryFailure(future.cause());
+                      }
+                  }
+              });
+
+        ctx.write(new RepositoryFileRegion(channel, request.getReadOffset(), request.bytesToRead()))
+              .addListener(
+                    new ChannelFutureListener() {
+                        @Override
+                        public void operationComplete(ChannelFuture future) throws Exception {
+                            if (future.isSuccess()) {
+                                promise.trySuccess();
+                            } else {
+                                promise.tryFailure(future.cause());
+                            }
+                        }
+                    });
+    }
+
+    @Override
+    public String toString() {
+        return String.format("zero-copy-read-response[offset=%d,bytes=%d]", request.getReadOffset(),
+              count);
+    }
+}
