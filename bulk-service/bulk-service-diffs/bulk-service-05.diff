diff --git a/modules/dcache-bulk/src/main/java/org/dcache/services/bulk/store/BulkRequestStore.java b/modules/dcache-bulk/src/main/java/org/dcache/services/bulk/store/BulkRequestStore.java
new file mode 100644
index 0000000..c045a40
--- /dev/null
+++ b/modules/dcache-bulk/src/main/java/org/dcache/services/bulk/store/BulkRequestStore.java
@@ -0,0 +1,87 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.services.bulk.store;
+
+import javax.security.auth.Subject;
+
+import java.util.NoSuchElementException;
+
+import org.dcache.auth.Subjects;
+
+/**
+ *  Combined interface implemented by the underlying stores.
+ */
+public interface BulkRequestStore extends BulkRequestStorePublic,
+                                          BulkRequestStorePrivate
+{
+    static String uidGidKey(Subject subject)
+    {
+        try {
+            if (subject == null) {
+                return "<unknown>:<unknown>";
+            }
+
+            return Subjects.getUid(subject) + ":"
+                            + Subjects.getPrimaryGid(subject);
+        } catch (NoSuchElementException | IllegalArgumentException e) {
+            return "<unknown>:<unknown>";
+        }
+    }
+}
diff --git a/modules/dcache-bulk/src/main/java/org/dcache/services/bulk/store/BulkRequestStorePrivate.java b/modules/dcache-bulk/src/main/java/org/dcache/services/bulk/store/BulkRequestStorePrivate.java
new file mode 100644
index 0000000..ab148ce
--- /dev/null
+++ b/modules/dcache-bulk/src/main/java/org/dcache/services/bulk/store/BulkRequestStorePrivate.java
@@ -0,0 +1,236 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.services.bulk.store;
+
+import javax.security.auth.Subject;
+
+import java.util.Comparator;
+import java.util.List;
+import java.util.Optional;
+import java.util.function.Predicate;
+import java.util.stream.Stream;
+
+import org.dcache.auth.attributes.Restriction;
+import org.dcache.services.bulk.BulkRequest;
+import org.dcache.services.bulk.BulkRequestStatus;
+import org.dcache.services.bulk.BulkRequestStatus.Status;
+import org.dcache.services.bulk.BulkRequestStorageException;
+import org.dcache.services.bulk.BulkStorageException;
+
+/**
+ *  Used strictly by the service: operational calls to the store which do not
+ *  need to verify user permissions on the request.
+ */
+public interface BulkRequestStorePrivate
+{
+    /**
+     * Does not throw exception, as this is a last resort cancellation.
+     *
+     * Should not clear the request from store unless automatic clear
+     * is set.
+     *
+     * @param requestId unique id for request.
+     * @param exception possibly associated with the abort.
+     */
+    void abort(String requestId, Throwable exception);
+
+    /**
+     * Updates the target count.
+     *
+     * @param requestId unique id for request.
+     * @throws BulkRequestStorageException
+     */
+    void addTarget(String requestId) throws BulkRequestStorageException;
+
+    /**
+     * @param requestId unique id for request.
+     */
+    void clear(String requestId);
+
+    /**
+     * @param user originator of the requests (=uidGidKey).
+     * @return the number of (matching) requests owned by the owner
+     *         which have yet to be completed.
+     * @throws BulkRequestStorageException
+     */
+    int countNonTerminated(String user) throws BulkRequestStorageException;
+
+    /**
+     * @param requestFilter optional filter on the request.
+     * @param statusFilter  optional filter on the request status
+     * @param limit         max requests to return (can be <code>null</code>).
+     * @return a stream of requests in the store which match
+     *                      the filters, if present; no filter means return all.
+     * @throws BulkRequestStorageException
+     */
+    Stream<BulkRequest> find(Optional<Predicate<BulkRequest>> requestFilter,
+                             Optional<Predicate<BulkRequestStatus>> statusFilter,
+                             Long limit)
+                    throws BulkRequestStorageException;
+
+    /**
+     * @param requestId unique id for request.
+     * @return optional of the request.
+     */
+    Optional<BulkRequest> getRequest(String requestId)
+                    throws BulkRequestStorageException;
+
+    /**
+     * @param requestId unique id for request.
+     * @return optional of the Restriction of the request.
+     * @throws BulkRequestStorageException
+     */
+    Optional<Restriction> getRestriction(String requestId)
+                    throws BulkRequestStorageException;
+
+    /**
+     * @param requestId unique id for request.
+     * @return optional of the status of the request.
+     * @throws BulkRequestStorageException
+     */
+    Optional<BulkRequestStatus> getStatus(String requestId)
+                    throws BulkRequestStorageException;
+
+    /**
+     * @return comparator for request status by timestamp.  Takes
+     *         requestId.
+     */
+    Comparator<String> getStatusComparator();
+
+    /**
+     * @param requestId unique id for request.
+     * @return optional of the uid:gid subject of the request.
+     * @throws BulkRequestStorageException
+     */
+    Optional<Subject> getSubject(String requestId)
+                    throws BulkRequestStorageException;
+
+    /**
+     * Checks to see if the subject owns or has access to the request.
+     *
+     * @param subject of the user
+     * @param requestId to check
+     * @return true if request is accessible by user
+     */
+    boolean isRequestSubject(Subject subject, String requestId);
+
+    /**
+     * Load the store into memory.
+     * May be a NOP.
+     */
+    List<BulkRequest> load() throws BulkStorageException;
+
+    /**
+     * @param  limit max requests to return
+     * @return list of requests in the store
+     *          which are queued to start;
+     *          these should be ordered by arrival time.
+     * @throws BulkRequestStorageException
+     */
+    List<BulkRequest> next(long limit) throws BulkRequestStorageException;
+
+    /**
+     * Reset the request to QUEUED state.
+     *
+     * @param requestId unique id for request.
+     * @throws BulkRequestStorageException
+     */
+    void reset(String requestId) throws BulkRequestStorageException;
+
+    /**
+     * Persist the store from memory.
+     * May be a NOP.
+     */
+    void save() throws BulkStorageException;
+
+    /**
+     * Update the request target record error.  Does not increment
+     * the completion count as this target has not been added since it
+     * failed prematurely.
+     *
+     * @param requestId unique id for request.
+     * @param target    belonging to the request.
+     * @param exception if any
+     * @throws BulkRequestStorageException
+     */
+    void targetAborted(String requestId, String target, Throwable exception)
+                    throws BulkRequestStorageException;
+
+    /**
+     * Update the request target completion count and record error.
+     *
+     * @param requestId unique id for request.
+     * @param target    belonging to the request.
+     * @param exception if any
+     * @throws BulkRequestStorageException
+     */
+    void targetCompleted(String requestId, String target, Throwable exception)
+                    throws BulkRequestStorageException;
+
+    /**
+     * Update the status of the request.
+     *
+     * @param requestId unique id for request.
+     * @param status    queued, started, cancelled, completed.
+     * @throws BulkRequestStorageException
+     */
+    void update(String requestId, Status status)
+                    throws BulkRequestStorageException;
+}
diff --git a/modules/dcache-bulk/src/main/java/org/dcache/services/bulk/store/BulkRequestStorePublic.java b/modules/dcache-bulk/src/main/java/org/dcache/services/bulk/store/BulkRequestStorePublic.java
new file mode 100644
index 0000000..217d520
--- /dev/null
+++ b/modules/dcache-bulk/src/main/java/org/dcache/services/bulk/store/BulkRequestStorePublic.java
@@ -0,0 +1,126 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.services.bulk.store;
+
+import javax.security.auth.Subject;
+
+import java.util.List;
+import java.util.Set;
+
+import org.dcache.auth.attributes.Restriction;
+import org.dcache.services.bulk.BulkPermissionDeniedException;
+import org.dcache.services.bulk.BulkRequest;
+import org.dcache.services.bulk.BulkRequestStatus;
+import org.dcache.services.bulk.BulkRequestStatus.Status;
+import org.dcache.services.bulk.BulkRequestStorageException;
+
+/**
+ *  The interface supporting the publicly available operations of
+ *  submit (store), query and clear.
+ */
+public interface BulkRequestStorePublic
+{
+    /**
+     * Releases all resources associated with this request id.
+     * 
+     * @param subject originator of the requests.
+     * @param requestId unique id for request.
+     * @throws BulkRequestStorageException
+     */
+    void clear(Subject subject, String requestId)
+                    throws BulkRequestStorageException,
+                    BulkPermissionDeniedException;
+
+    /**
+     * @param subject of request user
+     * @param status match only the requests with these statuses.
+     * @return list of the corresponding request urls.
+     * @throws BulkRequestStorageException
+     */
+    List<String> getRequestUrls(Subject subject, Set<Status> status)
+                    throws BulkRequestStorageException;
+
+    /**
+     * @param subject of request user
+     * @param requestId unique id for request.
+     * @return optional of the corresponding request status.
+     * @throws BulkRequestStorageException
+     */
+    BulkRequestStatus getStatus(Subject subject, String requestId)
+                                throws BulkRequestStorageException,
+                                BulkPermissionDeniedException;
+
+    /**
+     * Store the request.  It is understood that an associated status
+     * object is also generated and stored with it.
+     *
+     * @param subject     sending the request.
+     * @param restriction on subject's permissions.
+     * @param request     request specifics.
+     * @param status      request status; if <code>null</code> a new instance
+     *                    will be created.
+     * @throws BulkRequestStorageException
+     */
+    void store(Subject subject,
+               Restriction restriction,
+               BulkRequest request,
+               BulkRequestStatus status)
+                    throws BulkRequestStorageException;
+}
diff --git a/modules/dcache-bulk/src/main/java/org/dcache/services/bulk/store/file/AbstractObjectFileStore.java b/modules/dcache-bulk/src/main/java/org/dcache/services/bulk/store/file/AbstractObjectFileStore.java
new file mode 100644
index 0000000..7dbbda3
--- /dev/null
+++ b/modules/dcache-bulk/src/main/java/org/dcache/services/bulk/store/file/AbstractObjectFileStore.java
@@ -0,0 +1,250 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.services.bulk.store.file;
+
+import com.google.common.base.Preconditions;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.FilenameFilter;
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.io.Serializable;
+import java.util.List;
+
+import org.dcache.services.bulk.BulkRequestStorageException;
+import org.dcache.services.bulk.BulkServiceException;
+import org.dcache.services.bulk.BulkStorageException;
+
+/**
+ *  Handles writing and reading from disk.
+ *
+ *  The contract is that this class is to be used with an in-memory map
+ *  which holds the entire store.
+ *
+ *  This internal map is populated from disk at startup.
+ *
+ *  New or updated data is written out singly when the child class deems
+ *  appropriate.
+ *
+ *  If the cell shuts down peacefully, the entire contents are written out
+ *  again just before.
+ *
+ * @param <T> the object type to be stored.
+ */
+abstract class AbstractObjectFileStore<T extends Serializable>
+{
+    protected static final Logger LOGGER
+                    = LoggerFactory.getLogger(AbstractObjectFileStore.class);
+
+    private static final String OBJ_SUFFIX = ".obj";
+
+    private static final FilenameFilter OBJ_FILTER = new FilenameFilter()
+    {
+        @Override
+        public boolean accept(File dir, String name)
+        {
+            return name.endsWith(OBJ_SUFFIX);
+        }
+    };
+
+    protected final File storageDir;
+    protected final Class<T> storageType;
+
+    protected AbstractObjectFileStore(File storageDir, Class<T> storageType)
+    {
+        Preconditions.checkNotNull(storageDir, "Object File Store "
+                        + "must be given an explicit base directory to write to.");
+        Preconditions.checkNotNull(storageType, "Object File Store "
+                        + "must be given an explicit object class.");
+        this.storageDir = storageDir;
+        this.storageType = storageType;
+    }
+
+    protected void deleteFromDisk(String id)
+    {
+        LOGGER.trace("deleteFromDisk {}.", id);
+
+        File file = new File(storageDir, id + OBJ_SUFFIX);
+        if (file.exists()) {
+            file.delete();
+        }
+    }
+
+    /**
+     * It is assumed the storage directory points to a shallow directory
+     * containing files which have the ".obj" extension and whose
+     * names correspond to the key values of the map.
+     */
+    protected void readFromDisk()
+    {
+        if (!storageDir.exists()) {
+            storageDir.mkdirs();
+        }
+
+        File[] files = storageDir.listFiles(OBJ_FILTER);
+
+        String name;
+        T wrapper;
+
+        for (File file : files) {
+            name = file.getName();
+            name = name.substring(0, name.lastIndexOf(OBJ_SUFFIX));
+
+            try {
+                wrapper = deserialize(file);
+            } catch (BulkStorageException e) {
+                LOGGER.warn("Deserialization failed for {}: {}; file "
+                                            + "is corrupt or incomplete; "
+                                            + "removing ...",
+                            file, e.getMessage());
+                file.delete();
+                continue;
+            }
+
+            try {
+                postProcessDeserialized(name, wrapper);
+            } catch (BulkServiceException e) {
+                LOGGER.warn("There was a problem post-processing object from {}: "
+                                            + "{}.",
+                            file, e.getMessage());
+            }
+        }
+    }
+
+    protected void writeToDisk()
+    {
+        listIds().forEach(id -> writeToDisk(id));
+    }
+
+    protected synchronized void writeToDisk(String id)
+    {
+        LOGGER.trace("writeToDisk {}.", id);
+
+        T wrapper;
+        try {
+            wrapper = newInstance(id);
+        } catch (BulkServiceException e) {
+            LOGGER.warn("There was a problem instantiating wrapper for {}: {}; "
+                                        + "cannot write to disk.",
+                        id, e.getMessage());
+            return;
+        }
+
+        try {
+            serializeToDisk(id, wrapper);
+        } catch (BulkStorageException e) {
+            LOGGER.warn("Failed to save {} to disk: "
+                                        + "{}, {}.", id, e.getMessage(),
+                        e.getCause());
+        }
+    }
+
+    protected abstract void postProcessDeserialized(String id, T object)
+                    throws BulkServiceException;
+
+    protected abstract T newInstance(String id) throws BulkServiceException;
+
+    protected abstract List<String> listIds();
+
+    private T deserialize(File file) throws BulkStorageException
+    {
+        try {
+            FileInputStream fstream = new FileInputStream(file);
+            ObjectInputStream ostream = new ObjectInputStream(new FileInputStream(file));
+            T serializable = storageType.cast(ostream.readObject());
+            ostream.close();
+            fstream.close();
+            return serializable;
+        } catch (FileNotFoundException e) {
+            LOGGER.warn("File not found: {}; could not deserialize.", file);
+            return null;
+        } catch (ClassNotFoundException e) {
+            throw new BulkRequestStorageException("Wrapper class seems not to "
+                                                                  + "have been "
+                                                                  + "loaded!.",
+                                                  e);
+        } catch (IOException e) {
+            throw new BulkRequestStorageException("deserialize failed", e);
+        }
+    }
+
+    private void serializeToDisk(String name,
+                                 T serializable) throws BulkStorageException
+    {
+        File file = new File(storageDir, name + OBJ_SUFFIX);
+        try {
+            FileOutputStream fstream = new FileOutputStream(file);
+            ObjectOutputStream ostream = new ObjectOutputStream(fstream);
+            ostream.writeObject(serializable);
+            ostream.close();
+            fstream.close();
+        } catch (IOException e) {
+            throw new BulkRequestStorageException("problem serializing to disk "
+                                                                  + "for "
+                                                                  + name, e);
+        }
+    }
+}
diff --git a/modules/dcache-bulk/src/main/java/org/dcache/services/bulk/store/file/FileBulkRequestStore.java b/modules/dcache-bulk/src/main/java/org/dcache/services/bulk/store/file/FileBulkRequestStore.java
new file mode 100644
index 0000000..462cf76
--- /dev/null
+++ b/modules/dcache-bulk/src/main/java/org/dcache/services/bulk/store/file/FileBulkRequestStore.java
@@ -0,0 +1,578 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.services.bulk.store.file;
+
+import com.google.common.collect.ImmutableMap;
+import org.springframework.beans.factory.annotation.Required;
+
+import javax.security.auth.Subject;
+
+import java.io.File;
+import java.io.Serializable;
+import java.util.Comparator;
+import java.util.List;
+import java.util.Map;
+import java.util.Optional;
+import java.util.Set;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.TimeUnit;
+import java.util.function.Predicate;
+import java.util.stream.Stream;
+
+import org.dcache.auth.attributes.Restriction;
+import org.dcache.services.bulk.BulkFailures;
+import org.dcache.services.bulk.BulkPermissionDeniedException;
+import org.dcache.services.bulk.BulkRequest;
+import org.dcache.services.bulk.BulkRequest.Depth;
+import org.dcache.services.bulk.BulkRequestNotFoundException;
+import org.dcache.services.bulk.BulkRequestStatus;
+import org.dcache.services.bulk.BulkRequestStatus.Status;
+import org.dcache.services.bulk.BulkRequestStorageException;
+import org.dcache.services.bulk.BulkStorageException;
+import org.dcache.services.bulk.store.BulkRequestStore;
+import org.dcache.services.bulk.store.file.FileBulkRequestStore.FileBulkRequestWrapper;
+import org.dcache.services.bulk.store.memory.InMemoryBulkRequestStore;
+
+import static org.dcache.services.bulk.store.BulkRequestStore.uidGidKey;
+
+/**
+ *  Delegates main storage to in-memory implementation.
+ *
+ *  On put or update, it writes out the data to a file.
+ *
+ *  At start-up, it reads back in the files and populates the in-memory store.
+ */
+public class FileBulkRequestStore extends AbstractObjectFileStore<FileBulkRequestWrapper>
+                implements BulkRequestStore
+{
+    static class FileBulkRequestWrapper implements Serializable
+    {
+        private static final long serialVersionUID = 2678690448465233963L;
+
+        String                    requestId;
+        String                    urlPrefix;
+        String                    target;
+        String                    targetPrefix;
+        String                    activity;
+        Boolean                   clearOnSuccess;
+        Boolean                   clearOnFailure;
+        Integer                   delayClear;
+        Map<String, String>       arguments;
+        Depth                     expandDirectories;
+        long                      firstArrived;
+        long                      lastModified;
+        Status                    status;
+        int                       targets;
+        int                       processed;
+        Map<String, List<String>> failures;
+        Subject                   subject;
+        Restriction               restriction;
+
+        FileBulkRequestWrapper(BulkRequest request,
+                               BulkRequestStatus status,
+                               Subject subject,
+                               Restriction restriction)
+        {
+            if (request != null) {
+                setRequest(request);
+            }
+
+            if (status != null) {
+                setStatus(status);
+            }
+
+            this.subject = subject;
+            this.restriction = restriction;
+        }
+
+        BulkRequest getRequest()
+        {
+            BulkRequest request = new BulkRequest();
+            request.setId(requestId);
+            request.setUrlPrefix(urlPrefix);
+            request.setTarget(target);
+            request.setTargetPrefix(targetPrefix);
+            request.setActivity(activity);
+            request.setClearOnFailure(clearOnFailure);
+            request.setClearOnSuccess(clearOnSuccess);
+            request.setDelayClear(delayClear);
+            request.setExpandDirectories(expandDirectories);
+            return request;
+        }
+
+        Restriction getRestriction()
+        {
+            return restriction;
+        }
+
+        BulkRequestStatus getStatus()
+        {
+            BulkRequestStatus status = new BulkRequestStatus();
+            status.setFirstArrived(firstArrived);
+            status.setLastModified(lastModified);
+            status.setStatus(this.status);
+            status.setTargets(targets);
+            status.setProcessed(processed);
+            BulkFailures bulkFailures = new BulkFailures();
+            bulkFailures.setFailures(failures);
+            status.setFailures(bulkFailures);
+
+            return status;
+        }
+
+        Subject getSubject()
+        {
+            return subject;
+        }
+
+        void setRequest(BulkRequest request)
+        {
+            requestId = request.getId();
+            urlPrefix = request.getUrlPrefix();
+            target = request.getTarget();
+            targetPrefix = request.getTargetPrefix();
+            activity = request.getActivity();
+            clearOnSuccess = request.getClearOnSuccess();
+            clearOnFailure = request.getClearOnFailure();
+            delayClear = request.getDelayClear();
+            Map<String, String> args = request.getArguments();
+            if (args != null) {
+                arguments = ImmutableMap.copyOf(args);
+            }
+            expandDirectories = request.getExpandDirectories();
+        }
+
+        void setRestriction(Restriction restriction)
+        {
+            this.restriction = restriction;
+        }
+
+        void setStatus(BulkRequestStatus status)
+        {
+            firstArrived = status.getFirstArrived();
+            lastModified = status.getLastModified();
+            this.status = status.getStatus();
+            targets = status.getTargets();
+            processed = status.getProcessed();
+            BulkFailures bulkFailures = status.getFailures();
+            if (bulkFailures != null) {
+                failures = bulkFailures.cloneFailures();
+            }
+        }
+
+        void setSubject(Subject subject)
+        {
+            this.subject = subject;
+        }
+    }
+
+    private final InMemoryBulkRequestStore delegate;
+
+    /**
+     *  For handling delayed clear requests.
+     */
+    private ScheduledExecutorService scheduler;
+
+    public FileBulkRequestStore(File storageDir,
+                                InMemoryBulkRequestStore delegate)
+    {
+        super(storageDir, FileBulkRequestWrapper.class);
+        this.delegate = delegate;
+    }
+
+    @Override
+    public void abort(String requestId, Throwable exception)
+    {
+        LOGGER.trace("abort {}, {}.", requestId, exception.toString());
+
+        Optional<BulkRequest> optionalRequest = delegate.getRequest(requestId);
+        if (!optionalRequest.isPresent()) {
+            LOGGER.error("Fatal error trying to abort {}: "
+                                         + "request not found; error which "
+                                         + "caused the abort: {}.", requestId);
+        }
+
+        BulkRequest request = optionalRequest.get();
+
+        Optional<Subject> optionalSubject = delegate.getSubject(requestId);
+        if (!optionalSubject.isPresent()) {
+            LOGGER.error("Fatal error trying to abort {}: "
+                                         + "request has no subject; error which "
+                                         + "caused the abort: {}.", requestId);
+        }
+
+        if (request.getClearOnFailure()) {
+            clear(requestId);
+        } else {
+            delegate.abort(requestId, exception);
+        }
+    }
+
+    @Override
+    public void addTarget(String requestId)
+    {
+        delegate.addTarget(requestId);
+    }
+
+    @Override
+    public void clear(Subject subject, String requestId)
+                    throws BulkRequestStorageException,
+                    BulkPermissionDeniedException
+    {
+        LOGGER.trace("clear {}, {}.", uidGidKey(subject),
+                     requestId);
+
+        if (!delegate.isRequestSubject(subject, requestId)) {
+            throw new BulkPermissionDeniedException(requestId);
+        }
+
+        if (!delegate.getRequest(requestId).isPresent()) {
+            throw new BulkRequestNotFoundException(requestId);
+        }
+
+        clear(requestId);
+    }
+
+    @Override
+    public void clear(String requestId)
+    {
+        LOGGER.trace("clear {}.", requestId);
+
+        Optional<BulkRequest> request = delegate.getRequest(requestId);
+
+        if (!request.isPresent()) {
+            return;
+        }
+
+        Integer delay = request.get().getDelayClear();
+        if (delay == null || delay == 0) {
+            delegate.clear(requestId);
+            deleteFromDisk(requestId);
+        } else {
+            scheduler.scheduleWithFixedDelay(() -> {
+                delegate.clear(requestId);
+                deleteFromDisk(requestId);
+            }, 0, delay, TimeUnit.SECONDS);
+        }
+    }
+
+    @Override
+    public int countNonTerminated(String user)
+    {
+        LOGGER.trace("count {}, {}.", user);
+
+        return delegate.countNonTerminated(user);
+    }
+
+    @Override
+    public Stream<BulkRequest> find(Optional<Predicate<BulkRequest>> requestFilter,
+                             Optional<Predicate<BulkRequestStatus>> statusFilter,
+                             Long limit)
+                    throws BulkRequestStorageException
+    {
+        return delegate.find(requestFilter, statusFilter, limit);
+    }
+
+    @Override
+    public List<String> getRequestUrls(Subject subject, Set<Status> status)
+    {
+        LOGGER.trace("getRequestUrls {}, {}.", uidGidKey(subject),
+                     status);
+
+        return delegate.getRequestUrls(subject, status);
+    }
+
+    @Override
+    public Optional<BulkRequest> getRequest(String requestId)
+    {
+        LOGGER.trace("getRequest {}.", requestId);
+
+        return delegate.getRequest(requestId);
+    }
+
+    @Override
+    public Optional<Restriction> getRestriction(String requestId)
+    {
+        LOGGER.trace("getRestriction {}.", requestId);
+
+        return delegate.getRestriction(requestId);
+    }
+
+    @Override
+    public BulkRequestStatus getStatus(Subject subject, String requestId)
+                    throws BulkPermissionDeniedException,
+                    BulkRequestStorageException
+    {
+        LOGGER.trace("getStatus {}, {}.", uidGidKey(subject),
+                     requestId);
+        return delegate.getStatus(subject, requestId);
+    }
+
+    @Override
+    public Comparator<String> getStatusComparator()
+    {
+        return delegate.getStatusComparator();
+    }
+
+    @Override
+    public Optional<BulkRequestStatus> getStatus(String requestId)
+    {
+        LOGGER.trace("getStatus {}.", requestId);
+
+        return delegate.getStatus(requestId);
+    }
+
+    @Override
+    public Optional<Subject> getSubject(String requestId)
+    {
+        LOGGER.trace("getSubject {}.", requestId);
+
+        return delegate.getSubject(requestId);
+    }
+
+    @Override
+    public boolean isRequestSubject(Subject subject, String requestId)
+    {
+        return delegate.isRequestSubject(subject, requestId);
+    }
+
+    @Override
+    public List<BulkRequest> load() throws BulkStorageException
+
+    {
+        LOGGER.trace("load called.");
+
+        readFromDisk();
+        resetUnfinished();
+        return delegate.load();
+    }
+
+    @Override
+    public List<BulkRequest> next(long limit)
+    {
+        LOGGER.trace("next {}.", limit);
+
+        return delegate.next(limit);
+    }
+
+    @Override
+    public void reset(String requestId) throws BulkRequestStorageException
+    {
+        LOGGER.trace("reset {}.", requestId);
+        delegate.reset(requestId);
+        writeToDisk(requestId);
+    }
+
+    @Override
+    public void save()
+    {
+        writeToDisk();
+    }
+
+    @Required
+    public void setScheduler(ScheduledExecutorService scheduler)
+    {
+        this.scheduler = scheduler;
+    }
+
+    @Override
+    public void store(Subject subject,
+                      Restriction restriction,
+                      BulkRequest request,
+                      BulkRequestStatus status)
+    {
+        LOGGER.trace("store {}, subject {}.", request.getId(),
+                     uidGidKey(subject));
+        delegate.store(subject, restriction, request, status);
+
+        String requestId = request.getId();
+        writeToDisk(requestId);
+    }
+
+    @Override
+    public void targetAborted(String requestId,
+                              String target,
+                              Throwable exception)
+                    throws BulkRequestStorageException
+    {
+        LOGGER.trace("targetAborted {}, {}, {}.", requestId, target,
+                     exception.toString());
+        delegate.targetAborted(requestId, target, exception);
+        writeToDisk(requestId);
+    }
+
+    @Override
+    public void targetCompleted(String requestId,
+                                String target,
+                                Throwable exception)
+                    throws BulkRequestStorageException
+    {
+        LOGGER.trace("targetCompleted {}, {}.", requestId, target);
+
+        if (exception != null) {
+            Optional<BulkRequest> optionalRequest
+                            = delegate.getRequest(requestId);
+            if (!optionalRequest.isPresent()) {
+                throw new BulkRequestStorageException("Request " + requestId
+                                                                 + " not found.");
+            }
+
+            BulkRequest request = optionalRequest.get();
+
+            if (request.getClearOnFailure()) {
+                LOGGER.trace("target failed, request is clear on failure: {}, {}.",
+                             requestId, target);
+                clear(requestId);
+                return;
+            }
+        }
+
+        delegate.targetCompleted(requestId, target, exception);
+        writeToDisk(requestId);
+    }
+
+    @Override
+    public void update(String requestId, Status status)
+                    throws BulkRequestStorageException
+    {
+        LOGGER.trace("update {}, {}.", requestId, status);
+
+        Optional<BulkRequest> optionalRequest
+                        = delegate.getRequest(requestId);
+        if (!optionalRequest.isPresent()) {
+            throw new BulkRequestStorageException("Request " + requestId
+                                                             + " not found.");
+        }
+
+        BulkRequest request = optionalRequest.get();
+        switch (status)
+        {
+            case COMPLETED:
+                if (request.getClearOnSuccess()) {
+                    LOGGER.trace("request is clear on success: {}.", requestId);
+                    clear(requestId);
+                    break;
+                }
+                /*
+                 *  Fall through to update.
+                 */
+            default:
+                delegate.update(requestId, status);
+                writeToDisk(requestId);
+        }
+    }
+
+    protected List<String> listIds()
+    {
+        LOGGER.trace("listIds called.");
+
+        return delegate.listIds();
+    }
+
+    protected FileBulkRequestWrapper newInstance(String id)  throws
+                    BulkStorageException
+    {
+        BulkRequest request = delegate.getRequest(id).orElse(null);
+        if (request == null) {
+            throw new BulkRequestStorageException("could not find request " + id);
+        }
+        BulkRequestStatus status = delegate.getStatus(id).orElse(null);
+        Subject subject = delegate.getSubject(id).orElse(null);
+        Restriction restriction = delegate.getRestriction(id).orElse(null);
+        return new FileBulkRequestWrapper(request, status, subject, restriction);
+    }
+
+    @Override
+    protected void postProcessDeserialized(String id,
+                                           FileBulkRequestWrapper wrapper)
+    {
+        delegate.store(wrapper.subject,
+                       wrapper.restriction,
+                       wrapper.getRequest(),
+                       wrapper.getStatus());
+    }
+
+    private void resetUnfinished()
+    {
+        LOGGER.trace("resetUnfinished called.");
+
+        Predicate<String> resetFilter = id -> {
+            Optional<BulkRequestStatus> optional = delegate.getStatus(id);
+            if (!optional.isPresent()) {
+                LOGGER.warn("request {} has no status object.", id);
+                return false;
+            }
+            return optional.get().getStatus() == Status.STARTED;
+        };
+
+        delegate.listIds()
+                .stream()
+                .filter(resetFilter)
+                .forEach(id -> {
+                    try {
+                        reset(id);
+                    } catch (BulkRequestStorageException e) {
+                        LOGGER.warn("reload failed to reset STARTED "
+                                                    + "request {} "
+                                                    + "to QUEUED.",
+                                    id);
+                    }});
+    }
+}
diff --git a/modules/dcache-bulk/src/main/java/org/dcache/services/bulk/store/memory/InMemoryBulkRequestStore.java b/modules/dcache-bulk/src/main/java/org/dcache/services/bulk/store/memory/InMemoryBulkRequestStore.java
new file mode 100644
index 0000000..3fe87c4
--- /dev/null
+++ b/modules/dcache-bulk/src/main/java/org/dcache/services/bulk/store/memory/InMemoryBulkRequestStore.java
@@ -0,0 +1,587 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.services.bulk.store.memory;
+
+import com.google.common.base.Strings;
+import com.google.common.collect.HashMultimap;
+import com.google.common.collect.Multimap;
+
+import javax.annotation.concurrent.GuardedBy;
+import javax.security.auth.Subject;
+
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Optional;
+import java.util.Set;
+import java.util.TreeSet;
+import java.util.function.Predicate;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+import org.dcache.auth.Subjects;
+import org.dcache.auth.attributes.Restriction;
+import org.dcache.services.bulk.BulkPermissionDeniedException;
+import org.dcache.services.bulk.BulkRequest;
+import org.dcache.services.bulk.BulkRequestNotFoundException;
+import org.dcache.services.bulk.BulkRequestStatus;
+import org.dcache.services.bulk.BulkRequestStatus.Status;
+import org.dcache.services.bulk.BulkRequestStorageException;
+import org.dcache.services.bulk.store.BulkRequestStore;
+
+import static org.dcache.services.bulk.store.BulkRequestStore.uidGidKey;
+
+/**
+ *  Simple set of maps and indices.
+ */
+public class InMemoryBulkRequestStore extends InMemoryStore
+                implements BulkRequestStore
+{
+    /**
+     *  Maintains ordering where earlier timestamps
+     *  precede later ones.
+     */
+    public class StatusComparator implements Comparator<String>
+    {
+        @Override
+        public int compare(String left, String right)
+        {
+            if (left == null) {
+                return 1;
+            }
+
+            if (right == null) {
+                return -1;
+            }
+
+            BulkRequestStatus statusLeft = status.get(left);
+            BulkRequestStatus statusRight = status.get(right);
+
+            if (statusLeft.getFirstArrived() < statusRight.getFirstArrived()) {
+                return -1;
+            }
+
+            if (statusLeft.getFirstArrived() > statusRight.getFirstArrived()) {
+                return 1;
+            }
+
+            return 0;
+        }
+    }
+
+    /**
+     * We treat synchronization on these maps en bloc.
+     */
+    private final Map<String, BulkRequest>       requests;
+    private final Map<String, BulkRequestStatus> status;
+    private final Map<String, Subject>           requestSubject;
+    private final Map<String, Restriction>       requestRestriction;
+    private final Multimap<String, String>       uidGidRequests;
+    private final StatusComparator               comparator;
+
+    /**
+     * Maintains order of arrival via comparator (above).
+     */
+    private final Set<String> queued;
+
+    public InMemoryBulkRequestStore()
+    {
+        requests = new HashMap<>();
+        status = new HashMap<>();
+        requestSubject = new HashMap<>();
+        requestRestriction = new HashMap<>();
+        uidGidRequests = HashMultimap.create();
+        comparator = new StatusComparator();
+        queued = new TreeSet<>(comparator);
+    }
+
+    @Override
+    public void abort(String requestId, Throwable exception)
+    {
+        write.lock();
+        try {
+            queued.remove(requestId);
+            BulkRequestStatus status = this.status.get(requestId);
+            BulkRequest request = requests.get(requestId);
+            status.targetCompleted(request.getTarget(), exception);
+            status.setStatus(Status.COMPLETED);
+        } finally {
+            write.unlock();
+        }
+    }
+
+    @Override
+    public void addTarget(String requestId)
+    {
+        write.lock();
+        try {
+            status.get(requestId).targetAdded();
+        } finally {
+            write.unlock();
+        }
+    }
+
+    public void clear(String requestId)
+    {
+        write.lock();
+        try {
+            Subject subject = requestSubject.remove(requestId);
+            requests.remove(requestId);
+            status.remove(requestId);
+            requestRestriction.remove(requestId);
+            uidGidRequests.remove(uidGidKey(subject), requestId);
+            queued.remove(requestId);
+        } finally {
+            write.unlock();
+        }
+    }
+
+    @Override
+    public void clear(Subject subject, String requestId)
+                    throws BulkPermissionDeniedException
+    {
+        if (!isRequestSubject(subject, requestId)) {
+            throw new BulkPermissionDeniedException(requestId);
+        }
+
+        clear(requestId);
+    }
+
+    @Override
+    public int countNonTerminated(String user)
+    {
+        Predicate<String> notTerminated =
+                        id -> {
+                            BulkRequestStatus bstat = this.status.get(id);
+                            if (bstat == null) {
+                                return true;
+                            }
+                            Status status = bstat.getStatus();
+                            if (status == null) {
+                                return true;
+                            }
+                            return status != Status.CANCELLED
+                                            && status != Status.COMPLETED;
+                        };
+
+        read.lock();
+        try {
+             return (int) uidGidRequests.get(user)
+                                        .stream()
+                                        .filter(notTerminated)
+                                        .count();
+        } finally {
+            read.unlock();
+        }
+    }
+
+    @Override
+    public Stream<BulkRequest> find(Optional<Predicate<BulkRequest>> requestFilter,
+                                    Optional<Predicate<BulkRequestStatus>> statusFilter,
+                                    Long limit)
+    {
+        read.lock();
+        try {
+            if (limit == null) {
+                limit = Long.MAX_VALUE;
+            }
+
+            Stream<String> keys;
+
+            if (statusFilter.isPresent()) {
+                Predicate<BulkRequestStatus> sf = statusFilter.get();
+                keys = status.entrySet().stream().filter(e -> sf.test(e.getValue()))
+                             .map(Entry::getKey);
+            } else {
+                keys = requests.keySet().stream();
+            }
+
+            if (requestFilter.isPresent()) {
+                Predicate<BulkRequest> rf = requestFilter.get();
+                return keys.map(requests::get)
+                           .filter(rf::test)
+                           .limit(limit);
+            } else {
+                return keys.map(requests::get).limit(limit);
+            }
+        } finally {
+            read.unlock();
+        }
+    }
+
+    @Override
+    public Comparator<String> getStatusComparator()
+    {
+        return comparator;
+    }
+
+    @Override
+    public List<String> getRequestUrls(Subject subject, Set<Status> status)
+    {
+        read.lock();
+        try {
+            /*
+             *  do not allow non-root users to see other's requests
+             */
+            Predicate<Entry<String, BulkRequestStatus>> isUsersRequest
+                = e -> Subjects.isRoot(subject) || uidGidKey(subject).equals
+                                 (uidGidKey(requestSubject.get(e.getKey())));
+
+            return this.status.entrySet().stream()
+                                         .filter(e -> status.contains(e.getValue()
+                                                                       .getStatus()))
+                                         .filter(isUsersRequest)
+                                         .map(e -> requests.get(e.getKey()))
+                                         .map(r -> r.getUrlPrefix()
+                                                         + "/" + r.getId())
+                                         .collect(Collectors.toList());
+        } finally {
+            read.unlock();
+        }
+    }
+
+    @Override
+    public Optional<BulkRequest> getRequest(String requestId)
+    {
+        read.lock();
+        try {
+            return Optional.ofNullable(requests.get(requestId));
+        } finally {
+            read.unlock();
+        }
+    }
+
+    @Override
+    public Optional<Restriction> getRestriction(String requestId)
+    {
+        read.lock();
+        try {
+            return Optional.ofNullable(requestRestriction.get(requestId));
+        } finally {
+            read.unlock();
+        }
+    }
+
+    @Override
+    public Optional<BulkRequestStatus> getStatus(String requestId)
+    {
+        read.lock();
+        try {
+            return Optional.ofNullable(status.get(requestId));
+        } finally {
+            read.unlock();
+        }
+    }
+
+    @Override
+    public BulkRequestStatus getStatus(Subject subject,
+                                                 String requestId)
+                    throws BulkPermissionDeniedException,
+                    BulkRequestStorageException
+    {
+        read.lock();
+        try {
+            if (!isRequestSubject(subject, requestId)) {
+                throw new BulkPermissionDeniedException(requestId);
+            }
+            return getNonNullStatus(requestId);
+        } finally {
+            read.unlock();
+        }
+    }
+
+    @Override
+    public Optional<Subject> getSubject(String requestId)
+    {
+        read.lock();
+        try {
+            return Optional.ofNullable(requestSubject.get(requestId));
+        } finally {
+            read.unlock();
+        }
+    }
+
+    @Override
+    public boolean isRequestSubject(Subject subject, String requestId)
+    {
+        read.lock();
+        try {
+            Subject requestSubject = this.requestSubject.get(requestId);
+            return Subjects.isRoot(subject) ||
+                            uidGidKey(subject).equals(
+                                            uidGidKey(requestSubject));
+        } finally {
+            read.unlock();
+        }
+    }
+
+    /*
+     *  Used by wrapper class
+     */
+    public List<String> listIds()
+    {
+        read.lock();
+        try {
+            return requests.keySet().stream().collect(Collectors.toList());
+        } finally {
+            read.unlock();
+        }
+    }
+
+    /**
+     * Not synchronized, should only be called by wrapper delegating to
+     * this class.
+     */
+    @Override
+    public List<BulkRequest> load()
+    {
+        return requests.values().stream().collect(Collectors.toList());
+    }
+
+    /*
+     * Since this is called frequently, it has been optimized
+     * against the in-memory queue index.
+     */
+    @Override
+    public List<BulkRequest> next(long limit)
+    {
+        read.lock();
+        try {
+            if (queued.isEmpty()) {
+                return Collections.EMPTY_LIST;
+            }
+            return queued.stream()
+                         .map(requests::get)
+                         .limit(limit)
+                         .collect(Collectors.toList());
+        } finally {
+            read.unlock();
+        }
+    }
+
+    @Override
+    public void reset(String requestId) throws BulkRequestStorageException
+    {
+        write.lock();
+        try {
+            BulkRequestStatus stored = getNonNullStatus(requestId);
+            stored.setFailures(null);
+            stored.setProcessed(0);
+            stored.setTargets(0);
+            stored.setStatus(Status.QUEUED);
+            queued.add(requestId);
+        } finally {
+            write.unlock();
+        }
+    }
+
+    @Override
+    public void store(Subject subject,
+                      Restriction restriction,
+                      BulkRequest request,
+                      BulkRequestStatus status)
+    {
+        write.lock();
+        try {
+            String requestId = request.getId();
+            storeRequest(requestId, request, status);
+            storePermissions(requestId, subject, restriction);
+        } finally {
+            write.unlock();
+        }
+    }
+
+    @Override
+    public void targetAborted(String requestId, String target, Throwable exception)
+                    throws BulkRequestStorageException
+    {
+        write.lock();
+        try {
+            target = checkTarget(requestId, target);
+            getNonNullStatus(requestId).targetAborted(target, exception);
+        } finally {
+            write.unlock();
+        }
+    }
+
+    @Override
+    public void targetCompleted(String requestId, String target, Throwable exception)
+        throws BulkRequestStorageException
+    {
+        write.lock();
+        try {
+            target = checkTarget(requestId, target);
+            getNonNullStatus(requestId).targetCompleted(target, exception);
+        } finally {
+            write.unlock();
+        }
+    }
+
+    @Override
+    public void update(String requestId, Status status)
+                    throws BulkRequestStorageException
+    {
+        write.lock();
+        try {
+            switch (status)
+            {
+                case COMPLETED:
+                case CANCELLED:
+                case STARTED:
+                    queued.remove(requestId);
+                default:
+                    break;
+            }
+
+            BulkRequestStatus current = getNonNullStatus(requestId);
+
+            switch (current.getStatus())
+            {
+                case COMPLETED:
+                case CANCELLED:
+                    break;
+                case STARTED:
+                    switch (status) {
+                        case COMPLETED:
+                        case CANCELLED:
+                            current.setStatus(status);
+                            break;
+                    }
+                    break;
+                case QUEUED:
+                default:
+                    current.setStatus(status);
+                    break;
+            }
+
+        } finally {
+            write.unlock();
+        }
+    }
+
+    @GuardedBy("write")
+    private BulkRequestStatus getNonNullStatus(String requestId)
+                    throws BulkRequestNotFoundException
+    {
+        BulkRequestStatus stored = this.status.get(requestId);
+        if (stored == null) {
+            String error = "request id " + requestId
+                            + " is no longer valid!";
+            throw new BulkRequestNotFoundException(error);
+        }
+        return stored;
+    }
+
+    @GuardedBy("write")
+    private String checkTarget(String requestId, String target)
+                    throws BulkRequestStorageException
+    {
+        BulkRequest request = this.requests.get(requestId);
+        if (request == null) {
+            String error = "request id " + requestId
+                            + " is no longer valid!";
+            throw new BulkRequestNotFoundException(error);
+        }
+
+        String prefix = request.getTargetPrefix();
+        if (Strings.emptyToNull(prefix) != null && target.startsWith(prefix)) {
+            target = target.substring(prefix.length());
+        }
+
+        return target;
+    }
+
+    @GuardedBy("write")
+    private void storeRequest(String requestId,
+                              BulkRequest request,
+                              BulkRequestStatus status)
+    {
+        requests.put(requestId, request);
+
+        if (status == null) {
+            status = new BulkRequestStatus();
+            long now = System.currentTimeMillis();
+            status.setFirstArrived(now);
+            status.setStatus(Status.QUEUED);
+        }
+
+        /*
+         * Since queue comparator references status, add that first.
+         */
+        this.status.put(requestId, status);
+
+        if (status.getStatus() == Status.QUEUED) {
+            queued.add(requestId);
+        }
+    }
+
+    @GuardedBy("store,load")
+    private void storePermissions(String requestId,
+                                  Subject subject,
+                                  Restriction restriction)
+    {
+        requestSubject.put(requestId, subject);
+        uidGidRequests.put(uidGidKey(subject), requestId);
+        requestRestriction.put(requestId, restriction);
+    }
+}
diff --git a/modules/dcache-vehicles/src/main/java/org/dcache/services/bulk/BulkFailures.java b/modules/dcache-vehicles/src/main/java/org/dcache/services/bulk/BulkFailures.java
new file mode 100644
index 0000000..7d38e60
--- /dev/null
+++ b/modules/dcache-vehicles/src/main/java/org/dcache/services/bulk/BulkFailures.java
@@ -0,0 +1,138 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.services.bulk;
+
+import com.google.common.collect.ImmutableList;
+
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicInteger;
+
+/**
+ *  Groups requests by failure type, which is the canonical name of the
+ *  associated Throwable class.
+ */
+public class BulkFailures implements Serializable
+{
+    private static final long serialVersionUID = 8533779422283110521L;
+
+    private Map<String, List<String>> failures;
+
+    public Map<String, List<String>> getFailures()
+    {
+        return failures;
+    }
+
+    public void setFailures(Map<String, List<String>> failures)
+    {
+        this.failures = failures;
+    }
+
+    public void put(String path, Throwable e)
+    {
+        /*
+         *  Find the immediate cause.
+         */
+        Throwable next;
+        while ((next = e.getCause()) != null)
+        {
+            e = next;
+        }
+
+        if (failures == null) {
+            failures = new HashMap<>();
+        }
+
+        String clzz = e.getClass().getCanonicalName();
+        List<String> paths = failures.get(clzz);
+        if (paths == null) {
+            paths = new ArrayList<>();
+            failures.put(clzz, paths);
+        }
+
+        paths.add(path + " : " + e.getMessage());
+    }
+
+    public int count()
+    {
+        if (failures == null) {
+            return 0;
+        }
+        AtomicInteger count = new AtomicInteger(0);
+        failures.values().stream().forEach(list -> count.addAndGet(list.size()));
+        return count.get();
+    }
+
+    public Map<String, List<String>> cloneFailures()
+    {
+        Map<String, List<String>> map = new HashMap<>();
+        if (failures != null) {
+            failures.entrySet().stream()
+                    .forEach(entry -> {
+                        map.put(entry.getKey(),
+                                ImmutableList.copyOf(entry.getValue()));
+                    });
+        }
+        return map;
+    }
+}
diff --git a/modules/dcache-vehicles/src/main/java/org/dcache/services/bulk/BulkPermissionDeniedException.java b/modules/dcache-vehicles/src/main/java/org/dcache/services/bulk/BulkPermissionDeniedException.java
new file mode 100644
index 0000000..45c6a9e
--- /dev/null
+++ b/modules/dcache-vehicles/src/main/java/org/dcache/services/bulk/BulkPermissionDeniedException.java
@@ -0,0 +1,75 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.services.bulk;
+
+public class BulkPermissionDeniedException extends BulkServiceException
+{
+    private static final long serialVersionUID = -2776212873761086957L;
+
+    public BulkPermissionDeniedException(String message)
+    {
+        super(message);
+    }
+
+    public BulkPermissionDeniedException(String message, Throwable cause)
+    {
+        super(message, cause);
+    }
+}
diff --git a/modules/dcache-vehicles/src/main/java/org/dcache/services/bulk/BulkRequestNotFoundException.java b/modules/dcache-vehicles/src/main/java/org/dcache/services/bulk/BulkRequestNotFoundException.java
new file mode 100644
index 0000000..700822b
--- /dev/null
+++ b/modules/dcache-vehicles/src/main/java/org/dcache/services/bulk/BulkRequestNotFoundException.java
@@ -0,0 +1,75 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.services.bulk;
+
+public class BulkRequestNotFoundException extends BulkRequestStorageException
+{
+    private static final long serialVersionUID = 1881388905813183790L;
+
+    public BulkRequestNotFoundException(String message)
+    {
+        super(message);
+    }
+
+    public BulkRequestNotFoundException(String message, Throwable cause)
+    {
+        super(message, cause);
+    }
+}
diff --git a/modules/dcache-vehicles/src/main/java/org/dcache/services/bulk/BulkRequestStatus.java b/modules/dcache-vehicles/src/main/java/org/dcache/services/bulk/BulkRequestStatus.java
new file mode 100644
index 0000000..f0d8f25
--- /dev/null
+++ b/modules/dcache-vehicles/src/main/java/org/dcache/services/bulk/BulkRequestStatus.java
@@ -0,0 +1,181 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.services.bulk;
+
+import java.io.Serializable;
+
+/**
+ *  Generic bulk status.  In addition to the required fields,
+ *  tracks timestamps.
+ */
+public class BulkRequestStatus implements Serializable
+{
+    private static final long serialVersionUID = -7992364565691790254L;
+
+    public enum Status
+    {
+        QUEUED, STARTED, COMPLETED, CANCELLED
+    }
+
+    private long         firstArrived;
+    private long         lastModified;
+    private Status       status;
+    private int          targets;
+    private int          processed;
+    private BulkFailures failures;
+
+    public long getFirstArrived()
+    {
+        return firstArrived;
+    }
+
+    public long getLastModified()
+    {
+        return lastModified;
+    }
+
+    public Status getStatus()
+    {
+        return status;
+    }
+
+    public void setStatus(Status status)
+    {
+        this.status = status;
+        lastModified = System.currentTimeMillis();
+    }
+
+    public int getTargets()
+    {
+        return targets;
+    }
+
+    public void targetAdded()
+    {
+        ++targets;
+    }
+
+    public void setFirstArrived(long firstArrived)
+    {
+        this.firstArrived = firstArrived;
+    }
+
+    public void setLastModified(long lastModified)
+    {
+        this.lastModified = lastModified;
+    }
+
+    public void setTargets(int targets)
+    {
+        this.targets = targets;
+        lastModified = System.currentTimeMillis();
+    }
+
+    public int getProcessed()
+    {
+        return processed;
+    }
+
+    public void setProcessed(int processed)
+    {
+        this.processed = processed;
+        lastModified = System.currentTimeMillis();
+    }
+
+    public BulkFailures getFailures()
+    {
+        return failures;
+    }
+
+    public void setFailures(BulkFailures failures)
+    {
+        this.failures = failures;
+        lastModified = System.currentTimeMillis();
+    }
+
+    public void targetAborted(String target, Throwable exception)
+    {
+        if (target != null) {
+            addException(target, exception);
+        }
+
+        lastModified = System.currentTimeMillis();
+    }
+
+    public void targetCompleted(String target, Throwable exception)
+    {
+        if (target != null) {
+            ++processed;
+            addException(target, exception);
+        }
+
+        lastModified = System.currentTimeMillis();
+    }
+
+    private void addException(String target, Throwable exception)
+    {
+        if (exception != null) {
+            if (failures == null) {
+                failures = new BulkFailures();
+            }
+            failures.put(target, exception);
+        }
+    }
+}
diff --git a/modules/dcache-vehicles/src/main/java/org/dcache/services/bulk/BulkRequestStorageException.java b/modules/dcache-vehicles/src/main/java/org/dcache/services/bulk/BulkRequestStorageException.java
new file mode 100644
index 0000000..8cc5204
--- /dev/null
+++ b/modules/dcache-vehicles/src/main/java/org/dcache/services/bulk/BulkRequestStorageException.java
@@ -0,0 +1,75 @@
+/*
+COPYRIGHT STATUS:
+Dec 1st 2001, Fermi National Accelerator Laboratory (FNAL) documents and
+software are sponsored by the U.S. Department of Energy under Contract No.
+DE-AC02-76CH03000. Therefore, the U.S. Government retains a  world-wide
+non-exclusive, royalty-free license to publish or reproduce these documents
+and software for U.S. Government purposes.  All documents and software
+available from this server are protected under the U.S. and Foreign
+Copyright Laws, and FNAL reserves all rights.
+
+Distribution of the software available from this server is free of
+charge subject to the user following the terms of the Fermitools
+Software Legal Information.
+
+Redistribution and/or modification of the software shall be accompanied
+by the Fermitools Software Legal Information  (including the copyright
+notice).
+
+The user is asked to feed back problems, benefits, and/or suggestions
+about the software to the Fermilab Software Providers.
+
+Neither the name of Fermilab, the  URA, nor the names of the contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+DISCLAIMER OF LIABILITY (BSD):
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FERMILAB,
+OR THE URA, OR THE U.S. DEPARTMENT of ENERGY, OR CONTRIBUTORS BE LIABLE
+FOR  ANY  DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.
+
+Liabilities of the Government:
+
+This software is provided by URA, independent from its Prime Contract
+with the U.S. Department of Energy. URA is acting independently from
+the Government and in its own private capacity and is not acting on
+behalf of the U.S. Government, nor as its contractor nor its agent.
+Correspondingly, it is understood and agreed that the U.S. Government
+has no connection to this software and in no manner whatsoever shall
+be liable for nor assume any responsibility or obligation for any claim,
+cost, or damages arising out of or resulting from the use of the software
+available from this server.
+
+Export Control:
+
+All documents and software available from this server are subject to U.S.
+export control laws.  Anyone downloading information from this server is
+obligated to secure any necessary Government licenses before exporting
+documents or software obtained from this server.
+ */
+package org.dcache.services.bulk;
+
+public class BulkRequestStorageException extends BulkStorageException
+{
+    private static final long serialVersionUID = 1881388905813183790L;
+
+    public BulkRequestStorageException(String message)
+    {
+        super(message);
+    }
+
+    public BulkRequestStorageException(String message, Throwable cause)
+    {
+        super(message, cause);
+    }
+}
